# name       : show_slave_status_nolock.patch
# introduced : 12
# maintainer : Oleg
#
#!!! notice !!!
# Any small change to this file in the main branch
# should be done or reviewed by the maintainer!
--- /dev/null
+++ b/patch_info/show_slave_status_nolock.patch
@@ -0,0 +1,6 @@
+File=show_slave_status_nolock.patch
+Name= SHOW SLAVE STATUS NOLOCK
+Version=1.0
+Author=Percona <info@percona.com>
+License=GPL
+Comment= Implement SHOW SLAVE STATUS without lock (STOP SLAVE lock the same mutex what lock SHOW SLAVE STATUS)
--- a/sql/lex.h
+++ b/sql/lex.h
@@ -367,6 +367,7 @@
   { "NONE",		SYM(NONE_SYM)},
   { "NOT",		SYM(NOT_SYM)},
   { "NO_WRITE_TO_BINLOG",  SYM(NO_WRITE_TO_BINLOG)},
+  { "NOLOCK",           SYM(NOLOCK_SYM)},
   { "NULL",		SYM(NULL_SYM)},
   { "NUMERIC",		SYM(NUMERIC_SYM)},
   { "NVARCHAR",		SYM(NVARCHAR_SYM)},
--- a/sql/mysqld.cc
+++ b/sql/mysqld.cc
@@ -3275,6 +3275,7 @@
   {"show_profiles",        (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_PROFILES]), SHOW_LONG_STATUS},
   {"show_slave_hosts",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_SLAVE_HOSTS]), SHOW_LONG_STATUS},
   {"show_slave_status",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_SLAVE_STAT]), SHOW_LONG_STATUS},
+  {"show_slave_status_nolock", (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_SLAVE_NOLOCK_STAT]), SHOW_LONG_STATUS},
   {"show_status",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_STATUS]), SHOW_LONG_STATUS},
   {"show_storage_engines", (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_STORAGE_ENGINES]), SHOW_LONG_STATUS},
   {"show_table_statistics",(char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_TABLE_STATS]), SHOW_LONG_STATUS},
--- a/sql/sql_lex.h
+++ b/sql/sql_lex.h
@@ -119,7 +119,8 @@
   SQLCOM_ALTER_DB_UPGRADE, SQLCOM_SHOW_TEMPORARY_TABLES,
   SQLCOM_SHOW_PROFILE, SQLCOM_SHOW_PROFILES,
   SQLCOM_SHOW_PATCHES,
-
+  /* SHOW SLAVE STATUS NOLOCK */
+  SQLCOM_SHOW_SLAVE_NOLOCK_STAT,
   /*
     When a command is added here, be sure it's also added in mysqld.cc
     in "struct show_var_st status_vars[]= {" ...
--- a/sql/sql_parse.cc
+++ b/sql/sql_parse.cc
@@ -328,6 +328,7 @@
   sql_command_flags[SQLCOM_SHOW_CREATE]=  CF_STATUS_COMMAND;
   sql_command_flags[SQLCOM_SHOW_MASTER_STAT]=  CF_STATUS_COMMAND;
   sql_command_flags[SQLCOM_SHOW_SLAVE_STAT]=  CF_STATUS_COMMAND;
+  sql_command_flags[SQLCOM_SHOW_SLAVE_NOLOCK_STAT]=  CF_STATUS_COMMAND;
   sql_command_flags[SQLCOM_SHOW_CREATE_PROC]=  CF_STATUS_COMMAND;
   sql_command_flags[SQLCOM_SHOW_CREATE_FUNC]=  CF_STATUS_COMMAND;
   sql_command_flags[SQLCOM_SHOW_CREATE_TRIGGER]=  CF_STATUS_COMMAND;
@@ -2589,12 +2590,16 @@
     pthread_mutex_unlock(&LOCK_active_mi);
     break;
   }
+  case SQLCOM_SHOW_SLAVE_NOLOCK_STAT:
   case SQLCOM_SHOW_SLAVE_STAT:
   {
     /* Accept one of two privileges */
     if (check_global_access(thd, SUPER_ACL | REPL_CLIENT_ACL))
       goto error;
-    pthread_mutex_lock(&LOCK_active_mi);
+    if(SQLCOM_SHOW_SLAVE_NOLOCK_STAT != lex->sql_command)
+    {
+      pthread_mutex_lock(&LOCK_active_mi);
+    }
     if (active_mi != NULL)
     {
       res = show_master_info(thd, active_mi);
@@ -2605,7 +2610,10 @@
                    WARN_NO_MASTER_INFO, ER(WARN_NO_MASTER_INFO));
       my_ok(thd);
     }
-    pthread_mutex_unlock(&LOCK_active_mi);
+    if(SQLCOM_SHOW_SLAVE_NOLOCK_STAT != lex->sql_command)
+    {
+      pthread_mutex_unlock(&LOCK_active_mi);
+    }
     break;
   }
   case SQLCOM_SHOW_MASTER_STAT:
--- a/sql/sql_yacc.yy
+++ b/sql/sql_yacc.yy
@@ -1173,6 +1173,7 @@
 %token  STARTS_SYM
 %token  START_SYM                     /* SQL-2003-R */
 %token  STATUS_SYM
+%token  NOLOCK_SYM                    /* SHOW SLAVE STATUS NOLOCK */
 %token  STDDEV_SAMP_SYM               /* SQL-2003-N */
 %token  STD_SYM
 %token  STOP_SYM
@@ -10367,6 +10368,11 @@
           {
             Lex->sql_command = SQLCOM_SHOW_SLAVE_STAT;
           }
+	/* SHOW SLAVE STATUS NOLOCK */
+        | SLAVE STATUS_SYM NOLOCK_SYM
+          {
+	    Lex->sql_command = SQLCOM_SHOW_SLAVE_NOLOCK_STAT; //SQLCOM_SHOW_SLAVE_NOLOCK_STAT;
+          }
         | CLIENT_STATS_SYM wild_and_where 
           {
            LEX *lex= Lex;
--- /dev/null
+++ b/mysql-test/r/percona_show_slave_status_nolock.result
@@ -0,0 +1,21 @@
+include/master-slave.inc
+[connection master]
+DROP TABLE IF EXISTS t;
+CREATE TABLE t(id INT);
+INSERT INTO t SELECT SLEEP(10);
+STOP SLAVE;
+Warnings:
+Note	1592	Statement may not be safe to log in statement format.
+master	count(*)
+master	1
+slave	count(*)
+slave	0
+SHOW SLAVE STATUS NOLOCK;
+include/wait_for_slave_to_stop.inc
+START SLAVE;
+include/wait_for_slave_to_start.inc
+slave	count(*)
+slave	1
+DROP TABLE t;
+STOP SLAVE;
+include/wait_for_slave_to_stop.inc
--- /dev/null
+++ b/mysql-test/t/percona_show_slave_status_nolock.test
@@ -0,0 +1,50 @@
+--source include/master-slave.inc
+--source include/have_binlog_format_statement.inc
+
+connection master;
+  --disable_warnings
+  DROP TABLE IF EXISTS t;
+  --enable_warnings
+  CREATE TABLE t(id INT);
+  sync_slave_with_master;
+
+connection master;
+  send INSERT INTO t SELECT SLEEP(10);
+
+connection slave;
+  sleep 15;
+  send STOP SLAVE;
+
+connection master;
+  reap;
+
+  --disable_query_log
+  select "master",count(*) from t;
+  --enable_query_log
+
+connection slave1;
+  --disable_query_log
+  select "slave",count(*) from t;
+  --enable_query_log
+
+  --disable_result_log
+  SHOW SLAVE STATUS NOLOCK;
+  --enable_result_log
+
+connection slave;
+  reap;
+
+  --source include/wait_for_slave_to_stop.inc
+  START SLAVE;
+  --source include/wait_for_slave_to_start.inc
+
+  --disable_query_log
+  select "slave",count(*) from t;
+  --enable_query_log
+
+connection master;
+  DROP TABLE t;
+sync_slave_with_master;
+
+STOP SLAVE;
+--source include/wait_for_slave_to_stop.inc
