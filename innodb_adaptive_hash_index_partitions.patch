# name       : innodb_adaptive_hash_index_num.patch
# introduced : XtraDB on 5.5 (-13?)
# maintainer : Yasufumi
#
#!!! notice !!!
# Any small change to this file in the main branch
# should be done or reviewed by the maintainer!
--- a/storage/innobase/btr/btr0btr.c
+++ b/storage/innobase/btr/btr0btr.c
@@ -1523,7 +1523,7 @@
 	}
 	ut_a(block);
 
-	btr_search_drop_page_hash_index(block);
+	btr_search_drop_page_hash_index(block, NULL);
 
 	header = buf_block_get_frame(block) + PAGE_HEADER + PAGE_BTR_SEG_TOP;
 #ifdef UNIV_BTR_DEBUG
@@ -1592,7 +1592,7 @@
 
 #ifndef UNIV_HOTBACKUP
 	if (UNIV_LIKELY(!recovery)) {
-		btr_search_drop_page_hash_index(block);
+		btr_search_drop_page_hash_index(block, index);
 	}
 
 	block->check_index_page_at_flush = TRUE;
@@ -1760,7 +1760,7 @@
 	ut_a(!page_zip || page_zip_validate(page_zip, page));
 #endif /* UNIV_ZIP_DEBUG */
 
-	btr_search_drop_page_hash_index(block);
+	btr_search_drop_page_hash_index(block, index);
 	btr_blob_dbg_remove(page, index, "btr_page_empty");
 
 	/* Recreate the page: note that global data on page (possible
@@ -3093,7 +3093,7 @@
 		mem_heap_free(heap);
 	}
 
-	btr_search_drop_page_hash_index(block);
+	btr_search_drop_page_hash_index(block, index);
 
 	/* Make the father empty */
 	btr_page_empty(father_block, father_page_zip, index, page_level, mtr);
@@ -3317,7 +3317,7 @@
 			goto err_exit;
 		}
 
-		btr_search_drop_page_hash_index(block);
+		btr_search_drop_page_hash_index(block, index);
 
 		/* Remove the page from the level list */
 		btr_level_list_remove(space, zip_size, page, index, mtr);
@@ -3358,7 +3358,7 @@
 			goto err_exit;
 		}
 
-		btr_search_drop_page_hash_index(block);
+		btr_search_drop_page_hash_index(block, index);
 
 #ifdef UNIV_BTR_DEBUG
 		if (UNIV_LIKELY_NULL(merge_page_zip)) {
@@ -3473,7 +3473,7 @@
 		ut_a(btr_page_get_next(page, mtr) == FIL_NULL);
 
 		ut_ad(mtr_memo_contains(mtr, block, MTR_MEMO_PAGE_X_FIX));
-		btr_search_drop_page_hash_index(block);
+		btr_search_drop_page_hash_index(block, index);
 
 		btr_page_get_father(index, block, mtr, &cursor);
 		father = btr_cur_get_block(&cursor);
@@ -3578,7 +3578,7 @@
 
 	page = buf_block_get_frame(block);
 	ut_a(page_is_comp(merge_page) == page_is_comp(page));
-	btr_search_drop_page_hash_index(block);
+	btr_search_drop_page_hash_index(block, index);
 
 	if (left_page_no == FIL_NULL && !page_is_leaf(page)) {
 
--- a/storage/innobase/btr/btr0cur.c
+++ b/storage/innobase/btr/btr0cur.c
@@ -500,7 +500,7 @@
 #ifdef UNIV_SEARCH_PERF_STAT
 	info->n_searches++;
 #endif
-	if (rw_lock_get_writer(&btr_search_latch) == RW_LOCK_NOT_LOCKED
+	if (rw_lock_get_writer(btr_search_get_latch(cursor->index->id)) == RW_LOCK_NOT_LOCKED
 	    && latch_mode <= BTR_MODIFY_LEAF
 	    && info->last_hash_succ
 	    && !estimate
@@ -536,7 +536,7 @@
 
 	if (has_search_latch) {
 		/* Release possible search latch to obey latching order */
-		rw_lock_s_unlock(&btr_search_latch);
+		rw_lock_s_unlock(btr_search_get_latch(cursor->index->id));
 	}
 
 	/* Store the position of the tree latch we push to mtr so that we
@@ -847,7 +847,7 @@
 
 	if (has_search_latch) {
 
-		rw_lock_s_lock(&btr_search_latch);
+		rw_lock_s_lock(btr_search_get_latch(cursor->index->id));
 	}
 }
 
@@ -1977,13 +1977,13 @@
 			btr_search_update_hash_on_delete(cursor);
 		}
 
-		rw_lock_x_lock(&btr_search_latch);
+		rw_lock_x_lock(btr_search_get_latch(cursor->index->id));
 	}
 
 	row_upd_rec_in_place(rec, index, offsets, update, page_zip);
 
 	if (is_hashed) {
-		rw_lock_x_unlock(&btr_search_latch);
+		rw_lock_x_unlock(btr_search_get_latch(cursor->index->id));
 	}
 
 	if (page_zip && !dict_index_is_clust(index)
--- a/storage/innobase/btr/btr0sea.c
+++ b/storage/innobase/btr/btr0sea.c
@@ -47,6 +47,8 @@
 Protected by btr_search_latch. */
 UNIV_INTERN char		btr_search_enabled	= TRUE;
 
+UNIV_INTERN ulint		btr_search_index_num	= 1;
+
 #ifdef UNIV_PFS_MUTEX
 /* Key to register btr_search_enabled_mutex with performance schema */
 UNIV_INTERN mysql_pfs_key_t	btr_search_enabled_mutex_key;
@@ -75,7 +77,9 @@
 
 /* We will allocate the latch from dynamic memory to get it to the
 same DRAM page as other hotspot semaphores */
-UNIV_INTERN rw_lock_t*		btr_search_latch_temp;
+//UNIV_INTERN rw_lock_t*		btr_search_latch_temp;
+
+UNIV_INTERN rw_lock_t**		btr_search_latch_part;
 
 /** padding to prevent other memory update hotspots from residing on
 the same memory cache line */
@@ -127,18 +131,19 @@
 will not guarantee success. */
 static
 void
-btr_search_check_free_space_in_heap(void)
+btr_search_check_free_space_in_heap(
 /*=====================================*/
+	index_id_t	key)
 {
 	hash_table_t*	table;
 	mem_heap_t*	heap;
 
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_SHARED));
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+	ut_ad(!rw_lock_own(btr_search_get_latch(key), RW_LOCK_SHARED));
+	ut_ad(!rw_lock_own(btr_search_get_latch(key), RW_LOCK_EX));
 #endif /* UNIV_SYNC_DEBUG */
 
-	table = btr_search_sys->hash_index;
+	table = btr_search_get_hash_index(key);
 
 	heap = table->heap;
 
@@ -149,7 +154,7 @@
 	if (heap->free_block == NULL) {
 		buf_block_t*	block = buf_block_alloc(NULL);
 
-		rw_lock_x_lock(&btr_search_latch);
+		rw_lock_x_lock(btr_search_get_latch(key));
 
 		if (heap->free_block == NULL) {
 			heap->free_block = block;
@@ -157,7 +162,7 @@
 			buf_block_free(block);
 		}
 
-		rw_lock_x_unlock(&btr_search_latch);
+		rw_lock_x_unlock(btr_search_get_latch(key));
 	}
 }
 
@@ -169,17 +174,28 @@
 /*==================*/
 	ulint	hash_size)	/*!< in: hash index hash table size */
 {
+	ulint i;
 	/* We allocate the search latch from dynamic memory:
 	see above at the global variable definition */
 
-	btr_search_latch_temp = mem_alloc(sizeof(rw_lock_t));
+	//btr_search_latch_temp = mem_alloc(sizeof(rw_lock_t));
 
-	rw_lock_create(btr_search_latch_key, &btr_search_latch,
-		       SYNC_SEARCH_SYS);
+	//rw_lock_create(btr_search_latch_key, &btr_search_latch,
+	//	       SYNC_SEARCH_SYS);
 
 	btr_search_sys = mem_alloc(sizeof(btr_search_sys_t));
 
-	btr_search_sys->hash_index = ha_create(hash_size, 0, 0);
+	/* btr_search_index_num should be <= 32. (bits of trx->has_search_latch) */
+	btr_search_latch_part = mem_alloc(sizeof(rw_lock_t*) * btr_search_index_num);
+	btr_search_sys->hash_index = mem_alloc(sizeof(hash_table_t*) * btr_search_index_num);
+	for (i = 0; i < btr_search_index_num; i++) {
+		btr_search_latch_part[i] = mem_alloc(sizeof(rw_lock_t));
+
+		rw_lock_create(btr_search_latch_key,
+				btr_search_latch_part[i], SYNC_SEARCH_SYS);
+
+		btr_search_sys->hash_index[i] = ha_create(hash_size, 0, 0);
+	}
 }
 
 /*****************************************************************//**
@@ -189,11 +205,22 @@
 btr_search_sys_free(void)
 /*=====================*/
 {
-	rw_lock_free(&btr_search_latch);
-	mem_free(btr_search_latch_temp);
-	btr_search_latch_temp = NULL;
-	mem_heap_free(btr_search_sys->hash_index->heap);
-	hash_table_free(btr_search_sys->hash_index);
+	ulint i;
+
+	for (i = 0; i < btr_search_index_num; i++) {
+		mem_heap_free(btr_search_sys->hash_index[i]->heap);
+		hash_table_free(btr_search_sys->hash_index[i]);
+
+		rw_lock_free(btr_search_latch_part[i]);
+
+		mem_free(btr_search_latch_part[i]);
+	}
+	mem_free(btr_search_sys->hash_index);
+	mem_free(btr_search_latch_part);
+
+	//rw_lock_free(&btr_search_latch);
+	//mem_free(btr_search_latch_temp);
+	//btr_search_latch_temp = NULL;
 	mem_free(btr_search_sys);
 	btr_search_sys = NULL;
 }
@@ -206,9 +233,10 @@
 /*====================*/
 {
 	dict_table_t*	table;
+	ulint i;
 
 	mutex_enter(&dict_sys->mutex);
-	rw_lock_x_lock(&btr_search_latch);
+	btr_search_x_lock_all();
 
 	btr_search_enabled = FALSE;
 
@@ -232,10 +260,12 @@
 	buf_pool_clear_hash_index();
 
 	/* Clear the adaptive hash index. */
-	hash_table_clear(btr_search_sys->hash_index);
-	mem_heap_empty(btr_search_sys->hash_index->heap);
+	for (i = 0; i < btr_search_index_num; i++) {
+		hash_table_clear(btr_search_sys->hash_index[i]);
+		mem_heap_empty(btr_search_sys->hash_index[i]->heap);
+	}
 
-	rw_lock_x_unlock(&btr_search_latch);
+	btr_search_x_unlock_all();
 }
 
 /********************************************************************//**
@@ -245,11 +275,11 @@
 btr_search_enable(void)
 /*====================*/
 {
-	rw_lock_x_lock(&btr_search_latch);
+	btr_search_x_lock_all();
 
 	btr_search_enabled = TRUE;
 
-	rw_lock_x_unlock(&btr_search_latch);
+	btr_search_x_unlock_all();
 }
 
 /*****************************************************************//**
@@ -301,20 +331,21 @@
 ulint
 btr_search_info_get_ref_count(
 /*==========================*/
-	btr_search_t*   info)	/*!< in: search info. */
+	btr_search_t*   info,	/*!< in: search info. */
+	index_id_t	key)
 {
 	ulint ret;
 
 	ut_ad(info);
 
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_SHARED));
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+	ut_ad(!rw_lock_own(btr_search_get_latch(key), RW_LOCK_SHARED));
+	ut_ad(!rw_lock_own(btr_search_get_latch(key), RW_LOCK_EX));
 #endif /* UNIV_SYNC_DEBUG */
 
-	rw_lock_s_lock(&btr_search_latch);
+	rw_lock_s_lock(btr_search_get_latch(key));
 	ret = info->ref_count;
-	rw_lock_s_unlock(&btr_search_latch);
+	rw_lock_s_unlock(btr_search_get_latch(key));
 
 	return(ret);
 }
@@ -335,8 +366,8 @@
 	int		cmp;
 
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_SHARED));
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+	ut_ad(!rw_lock_own(btr_search_get_latch(cursor->index->id), RW_LOCK_SHARED));
+	ut_ad(!rw_lock_own(btr_search_get_latch(cursor->index->id), RW_LOCK_EX));
 #endif /* UNIV_SYNC_DEBUG */
 
 	index = cursor->index;
@@ -454,8 +485,8 @@
 				/*!< in: cursor */
 {
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_SHARED));
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+	ut_ad(!rw_lock_own(btr_search_get_latch(cursor->index->id), RW_LOCK_SHARED));
+	ut_ad(!rw_lock_own(btr_search_get_latch(cursor->index->id), RW_LOCK_EX));
 	ut_ad(rw_lock_own(&block->lock, RW_LOCK_SHARED)
 	      || rw_lock_own(&block->lock, RW_LOCK_EX));
 #endif /* UNIV_SYNC_DEBUG */
@@ -539,7 +570,7 @@
 
 	ut_ad(cursor->flag == BTR_CUR_HASH_FAIL);
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+	ut_ad(rw_lock_own(btr_search_get_latch(cursor->index->id), RW_LOCK_EX));
 	ut_ad(rw_lock_own(&(block->lock), RW_LOCK_SHARED)
 	      || rw_lock_own(&(block->lock), RW_LOCK_EX));
 #endif /* UNIV_SYNC_DEBUG */
@@ -580,10 +611,10 @@
 			mem_heap_free(heap);
 		}
 #ifdef UNIV_SYNC_DEBUG
-		ut_ad(rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+		ut_ad(rw_lock_own(btr_search_get_latch(cursor->index->id), RW_LOCK_EX));
 #endif /* UNIV_SYNC_DEBUG */
 
-		ha_insert_for_fold(btr_search_sys->hash_index, fold,
+		ha_insert_for_fold(btr_search_get_hash_index(cursor->index->id), fold,
 				   block, rec);
 	}
 }
@@ -603,8 +634,8 @@
 	ulint*		params2;
 
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_SHARED));
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+	ut_ad(!rw_lock_own(btr_search_get_latch(cursor->index->id), RW_LOCK_SHARED));
+	ut_ad(!rw_lock_own(btr_search_get_latch(cursor->index->id), RW_LOCK_EX));
 #endif /* UNIV_SYNC_DEBUG */
 
 	block = btr_cur_get_block(cursor);
@@ -625,7 +656,7 @@
 
 	if (build_index || (cursor->flag == BTR_CUR_HASH_FAIL)) {
 
-		btr_search_check_free_space_in_heap();
+		btr_search_check_free_space_in_heap(cursor->index->id);
 	}
 
 	if (cursor->flag == BTR_CUR_HASH_FAIL) {
@@ -635,11 +666,11 @@
 		btr_search_n_hash_fail++;
 #endif /* UNIV_SEARCH_PERF_STAT */
 
-		rw_lock_x_lock(&btr_search_latch);
+		rw_lock_x_lock(btr_search_get_latch(cursor->index->id));
 
 		btr_search_update_hash_ref(info, block, cursor);
 
-		rw_lock_x_unlock(&btr_search_latch);
+		rw_lock_x_unlock(btr_search_get_latch(cursor->index->id));
 	}
 
 	if (build_index) {
@@ -884,17 +915,17 @@
 	cursor->flag = BTR_CUR_HASH;
 
 	if (UNIV_LIKELY(!has_search_latch)) {
-		rw_lock_s_lock(&btr_search_latch);
+		rw_lock_s_lock(btr_search_get_latch(index_id));
 
 		if (UNIV_UNLIKELY(!btr_search_enabled)) {
 			goto failure_unlock;
 		}
 	}
 
-	ut_ad(rw_lock_get_writer(&btr_search_latch) != RW_LOCK_EX);
-	ut_ad(rw_lock_get_reader_count(&btr_search_latch) > 0);
+	ut_ad(rw_lock_get_writer(btr_search_get_latch(index_id)) != RW_LOCK_EX);
+	ut_ad(rw_lock_get_reader_count(btr_search_get_latch(index_id)) > 0);
 
-	rec = ha_search_and_get_data(btr_search_sys->hash_index, fold);
+	rec = ha_search_and_get_data(btr_search_get_hash_index(index_id), fold);
 
 	if (UNIV_UNLIKELY(!rec)) {
 		goto failure_unlock;
@@ -912,7 +943,7 @@
 			goto failure_unlock;
 		}
 
-		rw_lock_s_unlock(&btr_search_latch);
+		rw_lock_s_unlock(btr_search_get_latch(index_id));
 
 		buf_block_dbg_add_level(block, SYNC_TREE_NODE_FROM_HASH);
 	}
@@ -1009,7 +1040,7 @@
 	/*-------------------------------------------*/
 failure_unlock:
 	if (UNIV_LIKELY(!has_search_latch)) {
-		rw_lock_s_unlock(&btr_search_latch);
+		rw_lock_s_unlock(btr_search_get_latch(index_id));
 	}
 failure:
 	cursor->flag = BTR_CUR_HASH_FAIL;
@@ -1032,10 +1063,11 @@
 void
 btr_search_drop_page_hash_index(
 /*============================*/
-	buf_block_t*	block)	/*!< in: block containing index page,
+	buf_block_t*	block,	/*!< in: block containing index page,
 				s- or x-latched, or an index page
 				for which we know that
 				block->buf_fix_count == 0 */
+	dict_index_t*	index_in)
 {
 	hash_table_t*		table;
 	ulint			n_fields;
@@ -1054,23 +1086,55 @@
 	ulint*			offsets;
 
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_SHARED));
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+	if (index_in) {
+		ut_ad(!rw_lock_own(btr_search_get_latch(index_in->id), RW_LOCK_SHARED));
+		ut_ad(!rw_lock_own(btr_search_get_latch(index_in->id), RW_LOCK_EX));
+	}
 #endif /* UNIV_SYNC_DEBUG */
 
 retry:
-	rw_lock_s_lock(&btr_search_latch);
-	index = block->index;
+	if (btr_search_index_num > 1) {
+		rw_lock_t*	btr_search_latch;
+
+		/* FIXME: This may be optimistic implementation still. */
+		btr_search_latch = (rw_lock_t*)(block->btr_search_latch);
+		if (UNIV_LIKELY(!btr_search_latch)) {
+			if (block->index) {
+				goto retry;
+			}
+			return;
+		}
+		rw_lock_s_lock(btr_search_latch);
+		if (UNIV_LIKELY(btr_search_latch != block->btr_search_latch)) {
+			rw_lock_s_unlock(btr_search_latch);
+			goto retry;
+		}
+		if (UNIV_LIKELY(!block->index)) {
+			rw_lock_s_unlock(btr_search_latch);
+			goto retry;
+		}
+		index = block->index;
+		ut_a(btr_search_latch == btr_search_get_latch(index->id));
+	} else {
+		/* btr_search_index_num == 1 */
+		/* btr_search_latch is only one and able to obtain
+		   before evaluating block->index. */
+		rw_lock_s_lock(btr_search_latch_part[0]);
+		if (UNIV_LIKELY(!block->index)) {
+			rw_lock_s_unlock(btr_search_latch_part[0]);
+			return;
+		}
+		index = block->index;
+	}
 
 	if (UNIV_LIKELY(!index)) {
 
-		rw_lock_s_unlock(&btr_search_latch);
+		rw_lock_s_unlock(btr_search_get_latch(index->id));
 
 		return;
 	}
 
-	ut_a(!dict_index_is_ibuf(index));
-	table = btr_search_sys->hash_index;
+	table = btr_search_get_hash_index(index->id);
 
 #ifdef UNIV_SYNC_DEBUG
 	ut_ad(rw_lock_own(&(block->lock), RW_LOCK_SHARED)
@@ -1080,12 +1144,14 @@
 
 	n_fields = block->curr_n_fields;
 	n_bytes = block->curr_n_bytes;
+	ut_a(index == block->index);
+	ut_a(!dict_index_is_ibuf(index));
 
 	/* NOTE: The fields of block must not be accessed after
 	releasing btr_search_latch, as the index page might only
 	be s-latched! */
 
-	rw_lock_s_unlock(&btr_search_latch);
+	rw_lock_s_unlock(btr_search_get_latch(index->id));
 
 	ut_a(n_fields + n_bytes > 0);
 
@@ -1136,7 +1202,7 @@
 		mem_heap_free(heap);
 	}
 
-	rw_lock_x_lock(&btr_search_latch);
+	rw_lock_x_lock(btr_search_get_latch(index->id));
 
 	if (UNIV_UNLIKELY(!block->index)) {
 		/* Someone else has meanwhile dropped the hash index */
@@ -1152,7 +1218,7 @@
 		/* Someone else has meanwhile built a new hash index on the
 		page, with different parameters */
 
-		rw_lock_x_unlock(&btr_search_latch);
+		rw_lock_x_unlock(btr_search_get_latch(index->id));
 
 		mem_free(folds);
 		goto retry;
@@ -1167,6 +1233,7 @@
 	index->search_info->ref_count--;
 
 	block->index = NULL;
+	block->btr_search_latch = NULL;
 
 cleanup:
 #if defined UNIV_AHI_DEBUG || defined UNIV_DEBUG
@@ -1179,14 +1246,14 @@
 			"InnoDB: the hash index to a page of %s,"
 			" still %lu hash nodes remain.\n",
 			index->name, (ulong) block->n_pointers);
-		rw_lock_x_unlock(&btr_search_latch);
+		rw_lock_x_unlock(btr_search_get_latch(index->id));
 
 		btr_search_validate();
 	} else {
-		rw_lock_x_unlock(&btr_search_latch);
+		rw_lock_x_unlock(btr_search_get_latch(index->id));
 	}
 #else /* UNIV_AHI_DEBUG || UNIV_DEBUG */
-	rw_lock_x_unlock(&btr_search_latch);
+	rw_lock_x_unlock(btr_search_get_latch(index->id));
 #endif /* UNIV_AHI_DEBUG || UNIV_DEBUG */
 
 	mem_free(folds);
@@ -1218,9 +1285,9 @@
 	ulint*		offsets;
 	ibool		released_search_latch;
 
-	rw_lock_s_lock(&btr_search_latch);
+	rw_lock_s_lock(btr_search_get_latch(index->id));
 
-	table = btr_search_sys->hash_index;
+	table = btr_search_get_hash_index(index->id);
 
 	for (j = 0; j < srv_buf_pool_instances; j++) {
 		buf_pool_t*	buf_pool;
@@ -1254,7 +1321,7 @@
 
 
 					/* keeping latch order */
-					rw_lock_s_unlock(&btr_search_latch);
+					rw_lock_s_unlock(btr_search_get_latch(index->id));
 					released_search_latch = TRUE;
 					rw_lock_x_lock(&block->lock);
 
@@ -1306,7 +1373,7 @@
 						mem_heap_empty(heap);
 					}
 
-					rw_lock_x_lock(&btr_search_latch);
+					rw_lock_x_lock(btr_search_get_latch(index->id));
 
 					if (UNIV_UNLIKELY(!block->index)) {
 						goto cleanup;
@@ -1316,12 +1383,12 @@
 
 					if (UNIV_UNLIKELY(block->curr_n_fields != n_fields)
 					    || UNIV_UNLIKELY(block->curr_n_bytes != n_bytes)) {
-						rw_lock_x_unlock(&btr_search_latch);
+						rw_lock_x_unlock(btr_search_get_latch(index->id));
 						rw_lock_x_unlock(&block->lock);
 
 						mem_free(folds);
 
-						rw_lock_s_lock(&btr_search_latch);
+						rw_lock_s_lock(btr_search_get_latch(index->id));
 						goto retry;
 					}
 
@@ -1334,6 +1401,7 @@
 					index->search_info->ref_count--;
 
 					block->index = NULL;
+					block->btr_search_latch = NULL;
 
 cleanup:
 #if defined UNIV_AHI_DEBUG || defined UNIV_DEBUG
@@ -1346,18 +1414,18 @@
 							index->name, (ulong) block->n_pointers);
 					}
 #endif /* UNIV_AHI_DEBUG || UNIV_DEBUG */
-					rw_lock_x_unlock(&btr_search_latch);
+					rw_lock_x_unlock(btr_search_get_latch(index->id));
 					rw_lock_x_unlock(&block->lock);
 
 					mem_free(folds);
 
-					rw_lock_s_lock(&btr_search_latch);
+					rw_lock_s_lock(btr_search_get_latch(index->id));
 				}
 			}
 		} while (released_search_latch);
 	}
 
-	rw_lock_s_unlock(&btr_search_latch);
+	rw_lock_s_unlock(btr_search_get_latch(index->id));
 
 	if (UNIV_LIKELY_NULL(heap)) {
 		mem_heap_free(heap);
@@ -1395,7 +1463,7 @@
 
 		buf_block_dbg_add_level(block, SYNC_TREE_NODE_FROM_HASH);
 
-		btr_search_drop_page_hash_index(block);
+		btr_search_drop_page_hash_index(block, NULL);
 	}
 
 	mtr_commit(&mtr);
@@ -1436,31 +1504,26 @@
 	ut_ad(index);
 	ut_a(!dict_index_is_ibuf(index));
 
+	table = btr_search_get_hash_index(index->id);
+	page = buf_block_get_frame(block);
+
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+	ut_ad(!rw_lock_own(btr_search_get_latch(index->id), RW_LOCK_EX));
 	ut_ad(rw_lock_own(&(block->lock), RW_LOCK_SHARED)
 	      || rw_lock_own(&(block->lock), RW_LOCK_EX));
 #endif /* UNIV_SYNC_DEBUG */
 
-	rw_lock_s_lock(&btr_search_latch);
-
-	if (!btr_search_enabled) {
-		rw_lock_s_unlock(&btr_search_latch);
-		return;
-	}
-
-	table = btr_search_sys->hash_index;
-	page = buf_block_get_frame(block);
+	rw_lock_s_lock(btr_search_get_latch(index->id));
 
 	if (block->index && ((block->curr_n_fields != n_fields)
-			     || (block->curr_n_bytes != n_bytes)
-			     || (block->curr_left_side != left_side))) {
+				 || (block->curr_n_bytes != n_bytes)
+				 || (block->curr_left_side != left_side))) {
 
-		rw_lock_s_unlock(&btr_search_latch);
+		rw_lock_s_unlock(btr_search_get_latch(index->id));
 
-		btr_search_drop_page_hash_index(block);
+		btr_search_drop_page_hash_index(block, index);
 	} else {
-		rw_lock_s_unlock(&btr_search_latch);
+		rw_lock_s_unlock(btr_search_get_latch(index->id));
 	}
 
 	n_recs = page_get_n_recs(page);
@@ -1554,9 +1617,9 @@
 		fold = next_fold;
 	}
 
-	btr_search_check_free_space_in_heap();
+	btr_search_check_free_space_in_heap(index->id);
 
-	rw_lock_x_lock(&btr_search_latch);
+	rw_lock_x_lock(btr_search_get_latch(index->id));
 
 	if (UNIV_UNLIKELY(!btr_search_enabled)) {
 		goto exit_func;
@@ -1583,6 +1646,7 @@
 	block->curr_n_bytes = n_bytes;
 	block->curr_left_side = left_side;
 	block->index = index;
+	block->btr_search_latch = btr_search_get_latch(index->id);
 
 	for (i = 0; i < n_cached; i++) {
 
@@ -1590,7 +1654,7 @@
 	}
 
 exit_func:
-	rw_lock_x_unlock(&btr_search_latch);
+	rw_lock_x_unlock(btr_search_get_latch(index->id));
 
 	mem_free(folds);
 	mem_free(recs);
@@ -1625,7 +1689,7 @@
 	ut_ad(rw_lock_own(&(new_block->lock), RW_LOCK_EX));
 #endif /* UNIV_SYNC_DEBUG */
 
-	rw_lock_s_lock(&btr_search_latch);
+	rw_lock_s_lock(btr_search_get_latch(index->id));
 
 	ut_a(!new_block->index || new_block->index == index);
 	ut_a(!block->index || block->index == index);
@@ -1634,9 +1698,9 @@
 
 	if (new_block->index) {
 
-		rw_lock_s_unlock(&btr_search_latch);
+		rw_lock_s_unlock(btr_search_get_latch(index->id));
 
-		btr_search_drop_page_hash_index(block);
+		btr_search_drop_page_hash_index(block, index);
 
 		return;
 	}
@@ -1651,7 +1715,7 @@
 		new_block->n_bytes = block->curr_n_bytes;
 		new_block->left_side = left_side;
 
-		rw_lock_s_unlock(&btr_search_latch);
+		rw_lock_s_unlock(btr_search_get_latch(index->id));
 
 		ut_a(n_fields + n_bytes > 0);
 
@@ -1663,7 +1727,7 @@
 		return;
 	}
 
-	rw_lock_s_unlock(&btr_search_latch);
+	rw_lock_s_unlock(btr_search_get_latch(index->id));
 }
 
 /********************************************************************//**
@@ -1702,7 +1766,7 @@
 	ut_a(block->curr_n_fields + block->curr_n_bytes > 0);
 	ut_a(!dict_index_is_ibuf(index));
 
-	table = btr_search_sys->hash_index;
+	table = btr_search_get_hash_index(cursor->index->id);
 
 	rec = btr_cur_get_rec(cursor);
 
@@ -1713,7 +1777,7 @@
 		mem_heap_free(heap);
 	}
 
-	rw_lock_x_lock(&btr_search_latch);
+	rw_lock_x_lock(btr_search_get_latch(cursor->index->id));
 
 	if (block->index) {
 		ut_a(block->index == index);
@@ -1721,7 +1785,7 @@
 		ha_search_and_delete_if_found(table, fold, rec);
 	}
 
-	rw_lock_x_unlock(&btr_search_latch);
+	rw_lock_x_unlock(btr_search_get_latch(cursor->index->id));
 }
 
 /********************************************************************//**
@@ -1758,7 +1822,7 @@
 	ut_a(cursor->index == index);
 	ut_a(!dict_index_is_ibuf(index));
 
-	rw_lock_x_lock(&btr_search_latch);
+	rw_lock_x_lock(btr_search_get_latch(cursor->index->id));
 
 	if (!block->index) {
 
@@ -1772,15 +1836,15 @@
 	    && (cursor->n_bytes == block->curr_n_bytes)
 	    && !block->curr_left_side) {
 
-		table = btr_search_sys->hash_index;
+		table = btr_search_get_hash_index(cursor->index->id);
 
 		ha_search_and_update_if_found(table, cursor->fold, rec,
 					      block, page_rec_get_next(rec));
 
 func_exit:
-		rw_lock_x_unlock(&btr_search_latch);
+		rw_lock_x_unlock(btr_search_get_latch(cursor->index->id));
 	} else {
-		rw_lock_x_unlock(&btr_search_latch);
+		rw_lock_x_unlock(btr_search_get_latch(cursor->index->id));
 
 		btr_search_update_hash_on_insert(cursor);
 	}
@@ -1815,9 +1879,9 @@
 	ulint*		offsets		= offsets_;
 	rec_offs_init(offsets_);
 
-	table = btr_search_sys->hash_index;
+	table = btr_search_get_hash_index(cursor->index->id);
 
-	btr_search_check_free_space_in_heap();
+	btr_search_check_free_space_in_heap(cursor->index->id);
 
 	rec = btr_cur_get_rec(cursor);
 
@@ -1862,7 +1926,7 @@
 	} else {
 		if (left_side) {
 
-			rw_lock_x_lock(&btr_search_latch);
+			rw_lock_x_lock(btr_search_get_latch(index->id));
 
 			locked = TRUE;
 
@@ -1880,7 +1944,7 @@
 
 		if (!locked) {
 
-			rw_lock_x_lock(&btr_search_latch);
+			rw_lock_x_lock(btr_search_get_latch(index->id));
 
 			locked = TRUE;
 
@@ -1902,7 +1966,7 @@
 		if (!left_side) {
 
 			if (!locked) {
-				rw_lock_x_lock(&btr_search_latch);
+				rw_lock_x_lock(btr_search_get_latch(index->id));
 
 				locked = TRUE;
 
@@ -1921,7 +1985,7 @@
 
 		if (!locked) {
 
-			rw_lock_x_lock(&btr_search_latch);
+			rw_lock_x_lock(btr_search_get_latch(index->id));
 
 			locked = TRUE;
 
@@ -1948,7 +2012,7 @@
 		mem_heap_free(heap);
 	}
 	if (locked) {
-		rw_lock_x_unlock(&btr_search_latch);
+		rw_lock_x_unlock(btr_search_get_latch(index->id));
 	}
 }
 
@@ -1964,7 +2028,7 @@
 	ha_node_t*	node;
 	ulint		n_page_dumps	= 0;
 	ibool		ok		= TRUE;
-	ulint		i;
+	ulint		i,j;
 	ulint		cell_count;
 	mem_heap_t*	heap		= NULL;
 	ulint		offsets_[REC_OFFS_NORMAL_SIZE];
@@ -1976,23 +2040,25 @@
 
 	rec_offs_init(offsets_);
 
-	rw_lock_x_lock(&btr_search_latch);
+	btr_search_x_lock_all();
 	buf_pool_page_hash_x_lock_all();
 
-	cell_count = hash_get_n_cells(btr_search_sys->hash_index);
+	for (j = 0; j < btr_search_index_num; j++) {
+
+	cell_count = hash_get_n_cells(btr_search_sys->hash_index[j]);
 
 	for (i = 0; i < cell_count; i++) {
 		/* We release btr_search_latch every once in a while to
 		give other queries a chance to run. */
 		if ((i != 0) && ((i % chunk_size) == 0)) {
 			buf_pool_page_hash_x_unlock_all();
-			rw_lock_x_unlock(&btr_search_latch);
+			btr_search_x_unlock_all();
 			os_thread_yield();
-			rw_lock_x_lock(&btr_search_latch);
+			btr_search_x_lock_all();
 			buf_pool_page_hash_x_lock_all();
 		}
 
-		node = hash_get_nth_cell(btr_search_sys->hash_index, i)->node;
+		node = hash_get_nth_cell(btr_search_sys->hash_index[j], i)->node;
 
 		for (; node != NULL; node = node->next) {
 			const buf_block_t*	block
@@ -2099,19 +2165,21 @@
 		give other queries a chance to run. */
 		if (i != 0) {
 			buf_pool_page_hash_x_unlock_all();
-			rw_lock_x_unlock(&btr_search_latch);
+			btr_search_x_unlock_all();
 			os_thread_yield();
-			rw_lock_x_lock(&btr_search_latch);
+			btr_search_x_lock_all();
 			buf_pool_page_hash_x_lock_all();
 		}
 
-		if (!ha_validate(btr_search_sys->hash_index, i, end_index)) {
+		if (!ha_validate(btr_search_sys->hash_index[j], i, end_index)) {
 			ok = FALSE;
 		}
 	}
 
+	} /*for (j = 0; j < btr_search_index_num; j++)*/
+
 	buf_pool_page_hash_x_unlock_all();
-	rw_lock_x_unlock(&btr_search_latch);
+	btr_search_x_unlock_all();
 	if (UNIV_LIKELY_NULL(heap)) {
 		mem_heap_free(heap);
 	}
--- a/storage/innobase/buf/buf0buf.c
+++ b/storage/innobase/buf/buf0buf.c
@@ -960,6 +960,7 @@
 
 	block->check_index_page_at_flush = FALSE;
 	block->index = NULL;
+	block->btr_search_latch = NULL;
 
 #ifdef UNIV_DEBUG
 	block->page.in_page_hash = FALSE;
@@ -1427,7 +1428,11 @@
 	ulint	p;
 
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+	ulint	j;
+
+	for (j = 0; j < btr_search_index_num; j++) {
+		ut_ad(rw_lock_own(btr_search_latch_part[j], RW_LOCK_EX));
+	}
 #endif /* UNIV_SYNC_DEBUG */
 	ut_ad(!btr_search_enabled);
 
@@ -2142,6 +2147,7 @@
 {
 	block->check_index_page_at_flush = FALSE;
 	block->index		= NULL;
+	block->btr_search_latch	= NULL;
 
 	block->n_hash_helps	= 0;
 	block->n_fields		= 1;
--- a/storage/innobase/buf/buf0lru.c
+++ b/storage/innobase/buf/buf0lru.c
@@ -560,7 +560,7 @@
 
 		mutex_exit(&buf_pool->LRU_list_mutex);
 
-		rw_lock_s_lock(&btr_search_latch);
+		btr_search_s_lock_all();
 		chunk = buf_pool->chunks;
 		for (j = buf_pool->n_chunks; j--; chunk++) {
 			buf_block_t*	block	= chunk->blocks;
@@ -572,16 +572,16 @@
 					continue;
 				}
 
-				rw_lock_s_unlock(&btr_search_latch);
+				btr_search_s_unlock_all();
 
 				rw_lock_x_lock(&block->lock);
-				btr_search_drop_page_hash_index(block);
+				btr_search_drop_page_hash_index(block, NULL);
 				rw_lock_x_unlock(&block->lock);
 
-				rw_lock_s_lock(&btr_search_latch);
+				btr_search_s_lock_all();
 			}
 		}
-		rw_lock_s_unlock(&btr_search_latch);
+		btr_search_s_unlock_all();
 	}
 }
 
@@ -1744,7 +1744,7 @@
 
 		UNIV_MEM_VALID(((buf_block_t*) bpage)->frame,
 			       UNIV_PAGE_SIZE);
-		btr_search_drop_page_hash_index((buf_block_t*) bpage);
+		btr_search_drop_page_hash_index((buf_block_t*) bpage, NULL);
 		UNIV_MEM_INVALID(((buf_block_t*) bpage)->frame,
 				 UNIV_PAGE_SIZE);
 
--- a/storage/innobase/dict/dict0dict.c
+++ b/storage/innobase/dict/dict0dict.c
@@ -1846,7 +1846,7 @@
 	zero. */
 
 	for (;;) {
-		ulint ref_count = btr_search_info_get_ref_count(info);
+		ulint ref_count = btr_search_info_get_ref_count(info, index->id);
 		if (ref_count == 0) {
 			break;
 		}
--- a/storage/innobase/handler/ha_innodb.cc
+++ b/storage/innobase/handler/ha_innodb.cc
@@ -11833,6 +11833,11 @@
   "Disable with --skip-innodb-adaptive-hash-index.",
   NULL, innodb_adaptive_hash_index_update, TRUE);
 
+static MYSQL_SYSVAR_ULONG(adaptive_hash_index_partitions, btr_search_index_num,
+  PLUGIN_VAR_RQCMDARG | PLUGIN_VAR_READONLY,
+  "Number of InnoDB adaptive hash index partitions (default 1: disable partitioning)",
+  NULL, NULL, 1, 1, sizeof(ulint) * 8, 0);
+
 static MYSQL_SYSVAR_ULONG(replication_delay, srv_replication_delay,
   PLUGIN_VAR_RQCMDARG,
   "Replication thread delay (ms) on the slave server if "
@@ -12213,6 +12218,7 @@
   MYSQL_SYSVAR(use_sys_stats_table),
   MYSQL_SYSVAR(stats_sample_pages),
   MYSQL_SYSVAR(adaptive_hash_index),
+  MYSQL_SYSVAR(adaptive_hash_index_partitions),
   MYSQL_SYSVAR(stats_method),
   MYSQL_SYSVAR(replication_delay),
   MYSQL_SYSVAR(status_file),
--- a/storage/innobase/include/btr0sea.h
+++ b/storage/innobase/include/btr0sea.h
@@ -85,7 +85,8 @@
 ulint
 btr_search_info_get_ref_count(
 /*==========================*/
-	btr_search_t*   info);	/*!< in: search info. */
+	btr_search_t*   info,	/*!< in: search info. */
+	index_id_t	key);
 /*********************************************************************//**
 Updates the search info. */
 UNIV_INLINE
@@ -136,10 +137,11 @@
 void
 btr_search_drop_page_hash_index(
 /*============================*/
-	buf_block_t*	block);	/*!< in: block containing index page,
+	buf_block_t*	block,	/*!< in: block containing index page,
 				s- or x-latched, or an index page
 				for which we know that
 				block->buf_fix_count == 0 */
+	dict_index_t*	index_in);
 /************************************************************************
 Drops a page hash index based on index */
 UNIV_INTERN
@@ -199,6 +201,40 @@
 # define btr_search_validate()	TRUE
 #endif /* defined UNIV_AHI_DEBUG || defined UNIV_DEBUG */
 
+/********************************************************************//**
+New functions to control split btr_search_index */
+UNIV_INLINE
+hash_table_t*
+btr_search_get_hash_index(
+/*======================*/
+	index_id_t	key);
+
+UNIV_INLINE
+rw_lock_t*
+btr_search_get_latch(
+/*=================*/
+	index_id_t	key);
+
+UNIV_INLINE
+void
+btr_search_x_lock_all(void);
+/*========================*/
+
+UNIV_INLINE
+void
+btr_search_x_unlock_all(void);
+/*==========================*/
+
+UNIV_INLINE
+void
+btr_search_s_lock_all(void);
+/*========================*/
+
+UNIV_INLINE
+void
+btr_search_s_unlock_all(void);
+/*==========================*/
+
 /** The search info struct in an index */
 struct btr_search_struct{
 	ulint	ref_count;	/*!< Number of blocks in this index tree
@@ -259,7 +295,7 @@
 
 /** The hash index system */
 struct btr_search_sys_struct{
-	hash_table_t*	hash_index;	/*!< the adaptive hash index,
+	hash_table_t**	hash_index;	/*!< the adaptive hash index,
 					mapping dtuple_fold values
 					to rec_t pointers on index pages */
 };
--- a/storage/innobase/include/btr0sea.ic
+++ b/storage/innobase/include/btr0sea.ic
@@ -62,8 +62,8 @@
 	btr_search_t*	info;
 
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_SHARED));
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+	ut_ad(!rw_lock_own(btr_search_get_latch(index->id), RW_LOCK_SHARED));
+	ut_ad(!rw_lock_own(btr_search_get_latch(index->id), RW_LOCK_EX));
 #endif /* UNIV_SYNC_DEBUG */
 
 	info = btr_search_get_info(index);
@@ -82,3 +82,72 @@
 
 	btr_search_info_update_slow(info, cursor);
 }
+
+/*********************************************************************//**
+New functions to control split btr_search_index */
+UNIV_INLINE
+hash_table_t*
+btr_search_get_hash_index(
+/*======================*/
+	index_id_t	key)
+{
+	return(btr_search_sys->hash_index[key % btr_search_index_num]);
+}
+
+UNIV_INLINE
+rw_lock_t*
+btr_search_get_latch(
+/*=================*/
+	index_id_t	key)
+{
+	return(btr_search_latch_part[key % btr_search_index_num]);
+}
+
+UNIV_INLINE
+void
+btr_search_x_lock_all(void)
+/*=======================*/
+{
+	ulint	i;
+
+	for (i = 0; i < btr_search_index_num; i++) {
+		rw_lock_x_lock(btr_search_latch_part[i]);
+	}
+}
+
+UNIV_INLINE
+void
+btr_search_x_unlock_all(void)
+/*==========================*/
+{
+	ulint	i;
+
+	for (i = 0; i < btr_search_index_num; i++) {
+		rw_lock_x_unlock(btr_search_latch_part[i]);
+	}
+}
+
+UNIV_INLINE
+void
+btr_search_s_lock_all(void)
+/*=======================*/
+{
+	ulint	i;
+
+	for (i = 0; i < btr_search_index_num; i++) {
+		rw_lock_s_lock(btr_search_latch_part[i]);
+	}
+}
+
+UNIV_INLINE
+void
+btr_search_s_unlock_all(void)
+/*=========================*/
+{
+	ulint	i;
+
+	for (i = 0; i < btr_search_index_num; i++) {
+		rw_lock_s_unlock(btr_search_latch_part[i]);
+	}
+}
+
--- a/storage/innobase/page/page0zip.c
+++ b/storage/innobase/page/page0zip.c
@@ -4456,7 +4456,7 @@
 
 #ifndef UNIV_HOTBACKUP
 	temp_block = buf_block_alloc(buf_pool);
-	btr_search_drop_page_hash_index(block);
+	btr_search_drop_page_hash_index(block, index);
 	block->check_index_page_at_flush = TRUE;
 #else /* !UNIV_HOTBACKUP */
 	ut_ad(block == back_block1);
--- a/storage/innobase/row/row0mysql.c
+++ b/storage/innobase/row/row0mysql.c
@@ -2594,7 +2594,7 @@
 			/* check adaptive hash entries */
 			index = dict_table_get_first_index(table);
 			while (index) {
-				ulint ref_count = btr_search_info_get_ref_count(index->search_info);
+				ulint ref_count = btr_search_info_get_ref_count(index->search_info, index->id);
 				if (ref_count) {
 					fprintf(stderr, "InnoDB: Warning:"
 						" hash index ref_count (%lu) is not zero"
@@ -2955,7 +2955,7 @@
 			table->space = space;
 			index = dict_table_get_first_index(table);
 			do {
-				ulint ref_count = btr_search_info_get_ref_count(index->search_info);
+				ulint ref_count = btr_search_info_get_ref_count(index->search_info, index->id);
 				/* check adaptive hash entries */
 				if (ref_count) {
 					fprintf(stderr, "InnoDB: Warning:"
--- a/storage/innobase/row/row0sel.c
+++ b/storage/innobase/row/row0sel.c
@@ -1222,7 +1222,7 @@
 	ut_ad(plan->unique_search);
 	ut_ad(!plan->must_get_clust);
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(rw_lock_own(&btr_search_latch, RW_LOCK_SHARED));
+	ut_ad(rw_lock_own(btr_search_get_latch(index->id), RW_LOCK_SHARED));
 #endif /* UNIV_SYNC_DEBUG */
 
 	row_sel_open_pcur(plan, TRUE, mtr);
@@ -1393,10 +1393,10 @@
 	    && !plan->must_get_clust
 	    && !plan->table->big_rows) {
 		if (!search_latch_locked) {
-			rw_lock_s_lock(&btr_search_latch);
+			rw_lock_s_lock(btr_search_get_latch(index->id));
 
 			search_latch_locked = TRUE;
-		} else if (rw_lock_get_writer(&btr_search_latch) == RW_LOCK_WAIT_EX) {
+		} else if (rw_lock_get_writer(btr_search_get_latch(index->id)) == RW_LOCK_WAIT_EX) {
 
 			/* There is an x-latch request waiting: release the
 			s-latch for a moment; as an s-latch here is often
@@ -1405,8 +1405,8 @@
 			from acquiring an s-latch for a long time, lowering
 			performance significantly in multiprocessors. */
 
-			rw_lock_s_unlock(&btr_search_latch);
-			rw_lock_s_lock(&btr_search_latch);
+			rw_lock_s_unlock(btr_search_get_latch(index->id));
+			rw_lock_s_lock(btr_search_get_latch(index->id));
 		}
 
 		found_flag = row_sel_try_search_shortcut(node, plan, &mtr);
@@ -1429,7 +1429,7 @@
 	}
 
 	if (search_latch_locked) {
-		rw_lock_s_unlock(&btr_search_latch);
+		rw_lock_s_unlock(btr_search_get_latch(index->id));
 
 		search_latch_locked = FALSE;
 	}
@@ -2005,7 +2005,7 @@
 
 func_exit:
 	if (search_latch_locked) {
-		rw_lock_s_unlock(&btr_search_latch);
+		rw_lock_s_unlock(btr_search_get_latch(index->id));
 	}
 	if (UNIV_LIKELY_NULL(heap)) {
 		mem_heap_free(heap);
@@ -3408,6 +3408,8 @@
 	/* if the returned record was locked and we did a semi-consistent
 	read (fetch the newest committed version), then this is set to
 	TRUE */
+	ulint		i;
+	ulint		should_release;
 #ifdef UNIV_SEARCH_DEBUG
 	ulint		cnt				= 0;
 #endif /* UNIV_SEARCH_DEBUG */
@@ -3505,18 +3507,33 @@
 	/* PHASE 0: Release a possible s-latch we are holding on the
 	adaptive hash index latch if there is someone waiting behind */
 
-	if (UNIV_UNLIKELY(rw_lock_get_writer(&btr_search_latch) != RW_LOCK_NOT_LOCKED)
-	    && trx->has_search_latch) {
+	should_release = 0;
+	for (i = 0; i < btr_search_index_num; i++) {
+		/* we should check all latches (fix Bug#791030) */
+		if (rw_lock_get_writer(btr_search_latch_part[i])
+		    != RW_LOCK_NOT_LOCKED) {
+			should_release |= ((ulint)1 << i);
+		}
+	}
+
+	if (should_release) {
 
 		/* There is an x-latch request on the adaptive hash index:
 		release the s-latch to reduce starvation and wait for
 		BTR_SEA_TIMEOUT rounds before trying to keep it again over
 		calls from MySQL */
 
-		rw_lock_s_unlock(&btr_search_latch);
-		trx->has_search_latch = FALSE;
+		for (i = 0; i < btr_search_index_num; i++) {
+			/* we should release all s-latches (fix Bug#791030) */
+			if (trx->has_search_latch & ((ulint)1 << i)) {
+				rw_lock_s_unlock(btr_search_latch_part[i]);
+				trx->has_search_latch &= (~((ulint)1 << i));
+			}
+		}
 
+		if (!trx->has_search_latch) {
 		trx->search_latch_timeout = BTR_SEA_TIMEOUT;
+		}
 	}
 
 	/* Reset the new record lock info if srv_locks_unsafe_for_binlog
@@ -3667,9 +3684,28 @@
 			hash index semaphore! */
 
 #ifndef UNIV_SEARCH_DEBUG
-			if (!trx->has_search_latch) {
-				rw_lock_s_lock(&btr_search_latch);
-				trx->has_search_latch = TRUE;
+			if (!(trx->has_search_latch
+			      & ((ulint)1 << (index->id % btr_search_index_num)))) {
+				if (trx->has_search_latch
+				    < ((ulint)1 << (index->id % btr_search_index_num))) {
+					rw_lock_s_lock(btr_search_get_latch(index->id));
+					trx->has_search_latch |=
+						((ulint)1 << (index->id % btr_search_index_num));
+				} else {
+					/* should re-lock to obay latch-order */
+					for (i = 0; i < btr_search_index_num; i++) {
+						if (trx->has_search_latch & ((ulint)1 << i)) {
+							rw_lock_s_unlock(btr_search_latch_part[i]);
+						}
+					}
+					trx->has_search_latch |=
+						((ulint)1 << (index->id % btr_search_index_num));
+					for (i = 0; i < btr_search_index_num; i++) {
+						if (trx->has_search_latch & ((ulint)1 << i)) {
+							rw_lock_s_lock(btr_search_latch_part[i]);
+						}
+					}
+				}
 			}
 #endif
 			switch (row_sel_try_search_shortcut_for_mysql(
@@ -3730,7 +3766,11 @@
 
 					trx->search_latch_timeout--;
 
-					rw_lock_s_unlock(&btr_search_latch);
+					for (i = 0; i < btr_search_index_num; i++) {
+						if (trx->has_search_latch & ((ulint)1 << i)) {
+							rw_lock_s_unlock(btr_search_latch_part[i]);
+						}
+					}
 					trx->has_search_latch = FALSE;
 				}
 
@@ -3754,7 +3794,12 @@
 	/* PHASE 3: Open or restore index cursor position */
 
 	if (trx->has_search_latch) {
-		rw_lock_s_unlock(&btr_search_latch);
+
+		for (i = 0; i < btr_search_index_num; i++) {
+			if (trx->has_search_latch & ((ulint)1 << i)) {
+				rw_lock_s_unlock(btr_search_latch_part[i]);
+			}
+		}
 		trx->has_search_latch = FALSE;
 	}
 
--- a/storage/innobase/srv/srv0srv.c
+++ b/storage/innobase/srv/srv0srv.c
@@ -2051,7 +2051,9 @@
 	      "-------------------------------------\n", file);
 	ibuf_print(file);
 
-	ha_print_info(file, btr_search_sys->hash_index);
+	for (i = 0; i < btr_search_index_num; i++) {
+		ha_print_info(file, btr_search_get_hash_index((index_id_t)i));
+	}
 
 	fprintf(file,
 		"%.2f hash searches/s, %.2f non-hash searches/s\n",
@@ -2076,14 +2078,15 @@
 			ut_total_allocated_memory,
 			mem_pool_get_reserved(mem_comm_pool));
 	/* Calcurate reserved memories */
-	if (btr_search_sys && btr_search_sys->hash_index->heap) {
-		btr_search_sys_subtotal = mem_heap_get_size(btr_search_sys->hash_index->heap);
+	if (btr_search_sys && btr_search_sys->hash_index[0]->heap) {
+		btr_search_sys_subtotal = mem_heap_get_size(btr_search_sys->hash_index[0]->heap);
 	} else {
 		btr_search_sys_subtotal = 0;
-		for (i=0; i < btr_search_sys->hash_index->n_mutexes; i++) {
-			btr_search_sys_subtotal += mem_heap_get_size(btr_search_sys->hash_index->heaps[i]);
+		for (i=0; i < btr_search_sys->hash_index[0]->n_mutexes; i++) {
+			btr_search_sys_subtotal += mem_heap_get_size(btr_search_sys->hash_index[0]->heaps[i]);
 		}
 	}
+	btr_search_sys_subtotal *= btr_search_index_num;
 
 	lock_sys_subtotal = 0;
 	if (trx_sys) {
@@ -2109,10 +2112,10 @@
 			"    Recovery system     %lu \t(%lu + %lu)\n",
 
 			(ulong) (btr_search_sys
-				? (btr_search_sys->hash_index->n_cells * sizeof(hash_cell_t)) : 0)
+				? (btr_search_sys->hash_index[0]->n_cells * btr_search_index_num * sizeof(hash_cell_t)) : 0)
 			+ btr_search_sys_subtotal,
 			(ulong) (btr_search_sys
-				? (btr_search_sys->hash_index->n_cells * sizeof(hash_cell_t)) : 0),
+				? (btr_search_sys->hash_index[0]->n_cells * btr_search_index_num * sizeof(hash_cell_t)) : 0),
 			(ulong) btr_search_sys_subtotal,
 
 			(ulong) (buf_pool_from_array(0)->page_hash->n_cells * sizeof(hash_cell_t)),
--- a/storage/innobase/trx/trx0trx.c
+++ b/storage/innobase/trx/trx0trx.c
@@ -265,8 +265,14 @@
 /*=================================*/
 	trx_t*	   trx) /*!< in: transaction */
 {
+	ulint	i;
+
 	if (trx->has_search_latch) {
-		rw_lock_s_unlock(&btr_search_latch);
+		for (i = 0; i < btr_search_index_num; i++) {
+			if (trx->has_search_latch & ((ulint)1 << i)) {
+				rw_lock_s_unlock(btr_search_latch_part[i]);
+			}
+		}
 
 		trx->has_search_latch = FALSE;
 	}
--- a/storage/innobase/include/btr0types.h
+++ b/storage/innobase/include/btr0types.h
@@ -52,15 +52,19 @@
 
 Bear in mind (3) and (4) when using the hash index.
 */
-extern rw_lock_t*	btr_search_latch_temp;
+//extern rw_lock_t*	btr_search_latch_temp;
+
+extern rw_lock_t**	btr_search_latch_part;
 
 /** The latch protecting the adaptive search system */
-#define btr_search_latch	(*btr_search_latch_temp)
+//#define btr_search_latch	(*btr_search_latch_temp)
 
 /** Flag: has the search system been enabled?
 Protected by btr_search_latch. */
 extern char	btr_search_enabled;
 
+extern ulint	btr_search_index_num;
+
 #ifdef UNIV_BLOB_DEBUG
 # include "buf0types.h"
 /** An index->blobs entry for keeping track of off-page column references */
--- a/storage/innobase/ha/ha0ha.c
+++ b/storage/innobase/ha/ha0ha.c
@@ -120,7 +120,7 @@
 	ut_a(block->frame == page_align(data));
 #endif /* UNIV_AHI_DEBUG || UNIV_DEBUG */
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+	ut_ad(rw_lock_own(block->btr_search_latch, RW_LOCK_EX));
 #endif /* UNIV_SYNC_DEBUG */
 	ASSERT_HASH_MUTEX_OWN(table, fold);
 	ut_ad(btr_search_enabled);
@@ -213,7 +213,7 @@
 	ut_ad(table);
 	ut_ad(table->magic_n == HASH_TABLE_MAGIC_N);
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+	//	ut_ad(rw_lock_own(&btr_search_latch, RW_LOCK_EX));
 #endif /* UNIV_SYNC_DEBUG */
 	ut_ad(btr_search_enabled);
 #if defined UNIV_AHI_DEBUG || defined UNIV_DEBUG
@@ -253,7 +253,7 @@
 	ut_a(new_block->frame == page_align(new_data));
 #endif /* UNIV_AHI_DEBUG || UNIV_DEBUG */
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+	//	ut_ad(rw_lock_own(&btr_search_latch, RW_LOCK_EX));
 #endif /* UNIV_SYNC_DEBUG */
 
 	if (!btr_search_enabled) {
@@ -296,7 +296,7 @@
 	ut_ad(table->magic_n == HASH_TABLE_MAGIC_N);
 	ASSERT_HASH_MUTEX_OWN(table, fold);
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+	//	ut_ad(rw_lock_own(&btr_search_latch, RW_LOCK_EX));
 #endif /* UNIV_SYNC_DEBUG */
 	ut_ad(btr_search_enabled);
 
--- a/storage/innobase/include/ha0ha.ic
+++ b/storage/innobase/include/ha0ha.ic
@@ -121,7 +121,7 @@
 
 	ASSERT_HASH_MUTEX_OWN(table, fold);
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(rw_lock_own(&btr_search_latch, RW_LOCK_SHARED));
+//	ut_ad(rw_lock_own(&btr_search_latch, RW_LOCK_SHARED));
 #endif /* UNIV_SYNC_DEBUG */
 	ut_ad(btr_search_enabled);
 
@@ -186,7 +186,7 @@
 
 	ASSERT_HASH_MUTEX_OWN(table, fold);
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+//	ut_ad(rw_lock_own(&btr_search_latch, RW_LOCK_EX));
 #endif /* UNIV_SYNC_DEBUG */
 	ut_ad(btr_search_enabled);
 
--- a/storage/innobase/include/buf0buf.h
+++ b/storage/innobase/include/buf0buf.h
@@ -1580,6 +1580,7 @@
 					complete, though: there may
 					have been hash collisions,
 					record deletions, etc. */
+	volatile rw_lock_t*     btr_search_latch;
 	/* @} */
 # ifdef UNIV_SYNC_DEBUG
 	/** @name Debug fields */
--- a/storage/innobase/sync/sync0sync.c
+++ b/storage/innobase/sync/sync0sync.c
@@ -1222,7 +1222,6 @@
 	case SYNC_OUTER_ANY_LATCH:
 	case SYNC_FILE_FORMAT_TAG:
 	case SYNC_DOUBLEWRITE:
-	case SYNC_SEARCH_SYS:
 	case SYNC_TRX_LOCK_HEAP:
 	case SYNC_KERNEL:
 	case SYNC_IBUF_BITMAP_MUTEX:
@@ -1243,6 +1242,7 @@
 			ut_error;
 		}
 		break;
+	case SYNC_SEARCH_SYS:
 	case SYNC_BUF_LRU_LIST:
 	case SYNC_BUF_FLUSH_LIST:
 	case SYNC_BUF_PAGE_HASH:
