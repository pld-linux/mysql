# name       : innodb_adaptive_hash_index_num.patch
# introduced : XtraDB on 5.5 (-13?)
# maintainer : Yasufumi
#
#!!! notice !!!
# Any small change to this file in the main branch
# should be done or reviewed by the maintainer!
--- a/storage/innobase/btr/btr0btr.c
+++ b/storage/innobase/btr/btr0btr.c
@@ -1523,7 +1523,7 @@
 	}
 	ut_a(block);
 
-	btr_search_drop_page_hash_index(block);
+	btr_search_drop_page_hash_index(block, NULL);
 
 	header = buf_block_get_frame(block) + PAGE_HEADER + PAGE_BTR_SEG_TOP;
 #ifdef UNIV_BTR_DEBUG
@@ -1592,7 +1592,7 @@
 
 #ifndef UNIV_HOTBACKUP
 	if (UNIV_LIKELY(!recovery)) {
-		btr_search_drop_page_hash_index(block);
+		btr_search_drop_page_hash_index(block, index);
 	}
 
 	block->check_index_page_at_flush = TRUE;
@@ -1760,7 +1760,7 @@
 	ut_a(!page_zip || page_zip_validate(page_zip, page));
 #endif /* UNIV_ZIP_DEBUG */
 
-	btr_search_drop_page_hash_index(block);
+	btr_search_drop_page_hash_index(block, index);
 	btr_blob_dbg_remove(page, index, "btr_page_empty");
 
 	/* Recreate the page: note that global data on page (possible
@@ -3093,7 +3093,7 @@
 		mem_heap_free(heap);
 	}
 
-	btr_search_drop_page_hash_index(block);
+	btr_search_drop_page_hash_index(block, index);
 
 	/* Make the father empty */
 	btr_page_empty(father_block, father_page_zip, index, page_level, mtr);
@@ -3317,7 +3317,7 @@
 			goto err_exit;
 		}
 
-		btr_search_drop_page_hash_index(block);
+		btr_search_drop_page_hash_index(block, index);
 
 		/* Remove the page from the level list */
 		btr_level_list_remove(space, zip_size, page, index, mtr);
@@ -3358,7 +3358,7 @@
 			goto err_exit;
 		}
 
-		btr_search_drop_page_hash_index(block);
+		btr_search_drop_page_hash_index(block, index);
 
 #ifdef UNIV_BTR_DEBUG
 		if (UNIV_LIKELY_NULL(merge_page_zip)) {
@@ -3473,7 +3473,7 @@
 		ut_a(btr_page_get_next(page, mtr) == FIL_NULL);
 
 		ut_ad(mtr_memo_contains(mtr, block, MTR_MEMO_PAGE_X_FIX));
-		btr_search_drop_page_hash_index(block);
+		btr_search_drop_page_hash_index(block, index);
 
 		btr_page_get_father(index, block, mtr, &cursor);
 		father = btr_cur_get_block(&cursor);
@@ -3578,7 +3578,7 @@
 
 	page = buf_block_get_frame(block);
 	ut_a(page_is_comp(merge_page) == page_is_comp(page));
-	btr_search_drop_page_hash_index(block);
+	btr_search_drop_page_hash_index(block, index);
 
 	if (left_page_no == FIL_NULL && !page_is_leaf(page)) {
 
--- a/storage/innobase/btr/btr0cur.c
+++ b/storage/innobase/btr/btr0cur.c
@@ -502,7 +502,7 @@
 #ifdef UNIV_SEARCH_PERF_STAT
 	info->n_searches++;
 #endif
-	if (rw_lock_get_writer(&btr_search_latch) == RW_LOCK_NOT_LOCKED
+	if (rw_lock_get_writer(btr_search_get_latch(cursor->index->id)) == RW_LOCK_NOT_LOCKED
 	    && latch_mode <= BTR_MODIFY_LEAF
 	    && info->last_hash_succ
 	    && !estimate
@@ -538,7 +538,7 @@
 
 	if (has_search_latch) {
 		/* Release possible search latch to obey latching order */
-		rw_lock_s_unlock(&btr_search_latch);
+		rw_lock_s_unlock(btr_search_get_latch(cursor->index->id));
 	}
 
 	/* Store the position of the tree latch we push to mtr so that we
@@ -862,7 +862,7 @@
 
 	if (has_search_latch) {
 
-		rw_lock_s_lock(&btr_search_latch);
+		rw_lock_s_lock(btr_search_get_latch(cursor->index->id));
 	}
 }
 
@@ -1992,13 +1992,13 @@
 			btr_search_update_hash_on_delete(cursor);
 		}
 
-		rw_lock_x_lock(&btr_search_latch);
+		rw_lock_x_lock(btr_search_get_latch(cursor->index->id));
 	}
 
 	row_upd_rec_in_place(rec, index, offsets, update, page_zip);
 
 	if (is_hashed) {
-		rw_lock_x_unlock(&btr_search_latch);
+		rw_lock_x_unlock(btr_search_get_latch(cursor->index->id));
 	}
 
 	if (page_zip && !dict_index_is_clust(index)
--- a/storage/innobase/btr/btr0sea.c
+++ b/storage/innobase/btr/btr0sea.c
@@ -48,6 +48,8 @@
 UNIV_INTERN char		btr_search_enabled	= TRUE;
 UNIV_INTERN ibool		btr_search_fully_disabled = FALSE;
 
+UNIV_INTERN ulint		btr_search_index_num	= 1;
+
 /** Mutex protecting btr_search_enabled */
 static mutex_t			btr_search_enabled_mutex;
 
@@ -79,7 +81,9 @@
 
 /* We will allocate the latch from dynamic memory to get it to the
 same DRAM page as other hotspot semaphores */
-UNIV_INTERN rw_lock_t*		btr_search_latch_temp;
+//UNIV_INTERN rw_lock_t*		btr_search_latch_temp;
+
+UNIV_INTERN rw_lock_t**		btr_search_latch_part;
 
 /** padding to prevent other memory update hotspots from residing on
 the same memory cache line */
@@ -131,18 +135,19 @@
 will not guarantee success. */
 static
 void
-btr_search_check_free_space_in_heap(void)
+btr_search_check_free_space_in_heap(
 /*=====================================*/
+	index_id_t	key)
 {
 	hash_table_t*	table;
 	mem_heap_t*	heap;
 
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_SHARED));
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+	ut_ad(!rw_lock_own(btr_search_get_latch(key), RW_LOCK_SHARED));
+	ut_ad(!rw_lock_own(btr_search_get_latch(key), RW_LOCK_EX));
 #endif /* UNIV_SYNC_DEBUG */
 
-	table = btr_search_sys->hash_index;
+	table = btr_search_get_hash_index(key);
 
 	heap = table->heap;
 
@@ -153,7 +158,7 @@
 	if (heap->free_block == NULL) {
 		buf_block_t*	block = buf_block_alloc(NULL);
 
-		rw_lock_x_lock(&btr_search_latch);
+		rw_lock_x_lock(btr_search_get_latch(key));
 
 		if (heap->free_block == NULL) {
 			heap->free_block = block;
@@ -161,7 +166,7 @@
 			buf_block_free(block);
 		}
 
-		rw_lock_x_unlock(&btr_search_latch);
+		rw_lock_x_unlock(btr_search_get_latch(key));
 	}
 }
 
@@ -173,19 +178,30 @@
 /*==================*/
 	ulint	hash_size)	/*!< in: hash index hash table size */
 {
+	ulint i;
 	/* We allocate the search latch from dynamic memory:
 	see above at the global variable definition */
 
-	btr_search_latch_temp = mem_alloc(sizeof(rw_lock_t));
+	//btr_search_latch_temp = mem_alloc(sizeof(rw_lock_t));
 
-	rw_lock_create(btr_search_latch_key, &btr_search_latch,
-		       SYNC_SEARCH_SYS);
+	//rw_lock_create(btr_search_latch_key, &btr_search_latch,
+	//	       SYNC_SEARCH_SYS);
 	mutex_create(btr_search_enabled_mutex_key,
 		     &btr_search_enabled_mutex, SYNC_SEARCH_SYS_CONF);
 
 	btr_search_sys = mem_alloc(sizeof(btr_search_sys_t));
 
-	btr_search_sys->hash_index = ha_create(hash_size, 0, 0);
+	/* btr_search_index_num should be <= 32. (bits of trx->has_search_latch) */
+	btr_search_latch_part = mem_alloc(sizeof(rw_lock_t*) * btr_search_index_num);
+	btr_search_sys->hash_index = mem_alloc(sizeof(hash_table_t*) * btr_search_index_num);
+	for (i = 0; i < btr_search_index_num; i++) {
+		btr_search_latch_part[i] = mem_alloc(sizeof(rw_lock_t));
+
+		rw_lock_create(btr_search_latch_key,
+				btr_search_latch_part[i], SYNC_SEARCH_SYS);
+
+		btr_search_sys->hash_index[i] = ha_create(hash_size, 0, 0);
+	}
 }
 
 /*****************************************************************//**
@@ -195,11 +211,22 @@
 btr_search_sys_free(void)
 /*=====================*/
 {
-	rw_lock_free(&btr_search_latch);
-	mem_free(btr_search_latch_temp);
-	btr_search_latch_temp = NULL;
-	mem_heap_free(btr_search_sys->hash_index->heap);
-	hash_table_free(btr_search_sys->hash_index);
+	ulint i;
+
+	for (i = 0; i < btr_search_index_num; i++) {
+		mem_heap_free(btr_search_sys->hash_index[i]->heap);
+		hash_table_free(btr_search_sys->hash_index[i]);
+
+		rw_lock_free(btr_search_latch_part[i]);
+
+		mem_free(btr_search_latch_part[i]);
+	}
+	mem_free(btr_search_sys->hash_index);
+	mem_free(btr_search_latch_part);
+
+	//rw_lock_free(&btr_search_latch);
+	//mem_free(btr_search_latch_temp);
+	//btr_search_latch_temp = NULL;
 	mem_free(btr_search_sys);
 	btr_search_sys = NULL;
 }
@@ -212,7 +239,7 @@
 /*====================*/
 {
 	mutex_enter(&btr_search_enabled_mutex);
-	rw_lock_x_lock(&btr_search_latch);
+	btr_search_x_lock_all();
 
 	/* Disable access to hash index, also tell ha_insert_for_fold()
 	stop adding new nodes to hash index, but still allow updating
@@ -230,7 +257,7 @@
 	/* btr_search_enabled_mutex should guarantee this. */
 	ut_ad(!btr_search_enabled);
 
-	rw_lock_x_unlock(&btr_search_latch);
+	btr_search_x_unlock_all();
 	mutex_exit(&btr_search_enabled_mutex);
 }
 
@@ -242,12 +269,12 @@
 /*====================*/
 {
 	mutex_enter(&btr_search_enabled_mutex);
-	rw_lock_x_lock(&btr_search_latch);
+	btr_search_x_lock_all();
 
 	btr_search_enabled = TRUE;
 	btr_search_fully_disabled = FALSE;
 
-	rw_lock_x_unlock(&btr_search_latch);
+	btr_search_x_unlock_all();
 	mutex_exit(&btr_search_enabled_mutex);
 }
 
@@ -300,20 +327,21 @@
 ulint
 btr_search_info_get_ref_count(
 /*==========================*/
-	btr_search_t*   info)	/*!< in: search info. */
+	btr_search_t*   info,	/*!< in: search info. */
+	index_id_t	key)
 {
 	ulint ret;
 
 	ut_ad(info);
 
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_SHARED));
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+	ut_ad(!rw_lock_own(btr_search_get_latch(key), RW_LOCK_SHARED));
+	ut_ad(!rw_lock_own(btr_search_get_latch(key), RW_LOCK_EX));
 #endif /* UNIV_SYNC_DEBUG */
 
-	rw_lock_s_lock(&btr_search_latch);
+	rw_lock_s_lock(btr_search_get_latch(key));
 	ret = info->ref_count;
-	rw_lock_s_unlock(&btr_search_latch);
+	rw_lock_s_unlock(btr_search_get_latch(key));
 
 	return(ret);
 }
@@ -334,8 +362,8 @@
 	int		cmp;
 
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_SHARED));
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+	ut_ad(!rw_lock_own(btr_search_get_latch(cursor->index->id), RW_LOCK_SHARED));
+	ut_ad(!rw_lock_own(btr_search_get_latch(cursor->index->id), RW_LOCK_EX));
 #endif /* UNIV_SYNC_DEBUG */
 
 	index = cursor->index;
@@ -453,8 +481,8 @@
 				/*!< in: cursor */
 {
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_SHARED));
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+	ut_ad(!rw_lock_own(btr_search_get_latch(cursor->index->id), RW_LOCK_SHARED));
+	ut_ad(!rw_lock_own(btr_search_get_latch(cursor->index->id), RW_LOCK_EX));
 	ut_ad(rw_lock_own(&block->lock, RW_LOCK_SHARED)
 	      || rw_lock_own(&block->lock, RW_LOCK_EX));
 #endif /* UNIV_SYNC_DEBUG */
@@ -538,7 +566,7 @@
 
 	ut_ad(cursor->flag == BTR_CUR_HASH_FAIL);
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+	ut_ad(rw_lock_own(btr_search_get_latch(cursor->index->id), RW_LOCK_EX));
 	ut_ad(rw_lock_own(&(block->lock), RW_LOCK_SHARED)
 	      || rw_lock_own(&(block->lock), RW_LOCK_EX));
 #endif /* UNIV_SYNC_DEBUG */
@@ -578,10 +606,10 @@
 			mem_heap_free(heap);
 		}
 #ifdef UNIV_SYNC_DEBUG
-		ut_ad(rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+		ut_ad(rw_lock_own(btr_search_get_latch(cursor->index->id), RW_LOCK_EX));
 #endif /* UNIV_SYNC_DEBUG */
 
-		ha_insert_for_fold(btr_search_sys->hash_index, fold,
+		ha_insert_for_fold(btr_search_get_hash_index(cursor->index->id), fold,
 				   block, rec);
 	}
 }
@@ -601,8 +629,8 @@
 	ulint*		params2;
 
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_SHARED));
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+	ut_ad(!rw_lock_own(btr_search_get_latch(cursor->index->id), RW_LOCK_SHARED));
+	ut_ad(!rw_lock_own(btr_search_get_latch(cursor->index->id), RW_LOCK_EX));
 #endif /* UNIV_SYNC_DEBUG */
 
 	block = btr_cur_get_block(cursor);
@@ -623,7 +651,7 @@
 
 	if (build_index || (cursor->flag == BTR_CUR_HASH_FAIL)) {
 
-		btr_search_check_free_space_in_heap();
+		btr_search_check_free_space_in_heap(cursor->index->id);
 	}
 
 	if (cursor->flag == BTR_CUR_HASH_FAIL) {
@@ -633,11 +661,11 @@
 		btr_search_n_hash_fail++;
 #endif /* UNIV_SEARCH_PERF_STAT */
 
-		rw_lock_x_lock(&btr_search_latch);
+		rw_lock_x_lock(btr_search_get_latch(cursor->index->id));
 
 		btr_search_update_hash_ref(info, block, cursor);
 
-		rw_lock_x_unlock(&btr_search_latch);
+		rw_lock_x_unlock(btr_search_get_latch(cursor->index->id));
 	}
 
 	if (build_index) {
@@ -882,17 +910,17 @@
 	cursor->flag = BTR_CUR_HASH;
 
 	if (UNIV_LIKELY(!has_search_latch)) {
-		rw_lock_s_lock(&btr_search_latch);
+		rw_lock_s_lock(btr_search_get_latch(index_id));
 
 		if (UNIV_UNLIKELY(!btr_search_enabled)) {
 			goto failure_unlock;
 		}
 	}
 
-	ut_ad(rw_lock_get_writer(&btr_search_latch) != RW_LOCK_EX);
-	ut_ad(rw_lock_get_reader_count(&btr_search_latch) > 0);
+	ut_ad(rw_lock_get_writer(btr_search_get_latch(index_id)) != RW_LOCK_EX);
+	ut_ad(rw_lock_get_reader_count(btr_search_get_latch(index_id)) > 0);
 
-	rec = ha_search_and_get_data(btr_search_sys->hash_index, fold);
+	rec = ha_search_and_get_data(btr_search_get_hash_index(index_id), fold);
 
 	if (UNIV_UNLIKELY(!rec)) {
 		goto failure_unlock;
@@ -910,7 +938,7 @@
 			goto failure_unlock;
 		}
 
-		rw_lock_s_unlock(&btr_search_latch);
+		rw_lock_s_unlock(btr_search_get_latch(index_id));
 
 		buf_block_dbg_add_level(block, SYNC_TREE_NODE_FROM_HASH);
 	}
@@ -1007,7 +1035,7 @@
 	/*-------------------------------------------*/
 failure_unlock:
 	if (UNIV_LIKELY(!has_search_latch)) {
-		rw_lock_s_unlock(&btr_search_latch);
+		rw_lock_s_unlock(btr_search_get_latch(index_id));
 	}
 failure:
 	cursor->flag = BTR_CUR_HASH_FAIL;
@@ -1030,10 +1058,11 @@
 void
 btr_search_drop_page_hash_index(
 /*============================*/
-	buf_block_t*	block)	/*!< in: block containing index page,
+	buf_block_t*	block,	/*!< in: block containing index page,
 				s- or x-latched, or an index page
 				for which we know that
 				block->buf_fix_count == 0 */
+	dict_index_t*	index_in)
 {
 	hash_table_t*		table;
 	ulint			n_fields;
@@ -1052,22 +1081,60 @@
 	ulint*			offsets;
 
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_SHARED));
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+	if (index_in) {
+		ut_ad(!rw_lock_own(btr_search_get_latch(index_in->id), RW_LOCK_SHARED));
+		ut_ad(!rw_lock_own(btr_search_get_latch(index_in->id), RW_LOCK_EX));
+	}
 #endif /* UNIV_SYNC_DEBUG */
 
 retry:
-	rw_lock_s_lock(&btr_search_latch);
+	if (index_in) {
+		index = index_in;
+		rw_lock_s_lock(btr_search_get_latch(index->id));
+	} else if (btr_search_index_num > 1) {
+		rw_lock_t*	btr_search_latch;
+
+		/* FIXME: This may be optimistic implementation still. */
+		btr_search_latch = (rw_lock_t*)(block->btr_search_latch);
+		if (UNIV_LIKELY(!btr_search_latch)) {
+			if (block->is_hashed) {
+				goto retry;
+			}
+			return;
+		}
+		rw_lock_s_lock(btr_search_latch);
+		if (UNIV_LIKELY(btr_search_latch != block->btr_search_latch)) {
+			rw_lock_s_unlock(btr_search_latch);
+			goto retry;
+		}
+		if (UNIV_LIKELY(!block->is_hashed)) {
+			rw_lock_s_unlock(btr_search_latch);
+			goto retry;
+		}
+		index = block->index;
+		ut_a(btr_search_latch == btr_search_get_latch(index->id));
+	} else {
+		/* btr_search_index_num == 1 */
+		/* btr_search_latch is only one and able to obtain
+		   before evaluating block->is_hashed. */
+		rw_lock_s_lock(btr_search_latch_part[0]);
+		if (UNIV_LIKELY(!block->is_hashed)) {
+			rw_lock_s_unlock(btr_search_latch_part[0]);
+			return;
+		}
+		index = block->index;
+	}
+
 	page = block->frame;
 
 	if (UNIV_LIKELY(!block->is_hashed)) {
 
-		rw_lock_s_unlock(&btr_search_latch);
+		rw_lock_s_unlock(btr_search_get_latch(index->id));
 
 		return;
 	}
 
-	table = btr_search_sys->hash_index;
+	table = btr_search_get_hash_index(index->id);
 
 #ifdef UNIV_SYNC_DEBUG
 	ut_ad(rw_lock_own(&(block->lock), RW_LOCK_SHARED)
@@ -1077,14 +1144,14 @@
 
 	n_fields = block->curr_n_fields;
 	n_bytes = block->curr_n_bytes;
-	index = block->index;
+	ut_a(index == block->index);
 	ut_a(!dict_index_is_ibuf(index));
 
 	/* NOTE: The fields of block must not be accessed after
 	releasing btr_search_latch, as the index page might only
 	be s-latched! */
 
-	rw_lock_s_unlock(&btr_search_latch);
+	rw_lock_s_unlock(btr_search_get_latch(index->id));
 
 	ut_a(n_fields + n_bytes > 0);
 
@@ -1134,7 +1201,7 @@
 		mem_heap_free(heap);
 	}
 
-	rw_lock_x_lock(&btr_search_latch);
+	rw_lock_x_lock(btr_search_get_latch(index->id));
 
 	if (UNIV_UNLIKELY(!block->is_hashed)) {
 		/* Someone else has meanwhile dropped the hash index */
@@ -1150,7 +1217,7 @@
 		/* Someone else has meanwhile built a new hash index on the
 		page, with different parameters */
 
-		rw_lock_x_unlock(&btr_search_latch);
+		rw_lock_x_unlock(btr_search_get_latch(index->id));
 
 		mem_free(folds);
 		goto retry;
@@ -1166,6 +1233,7 @@
 
 	block->is_hashed = FALSE;
 	block->index = NULL;
+	block->btr_search_latch = NULL;
 	
 cleanup:
 #if defined UNIV_AHI_DEBUG || defined UNIV_DEBUG
@@ -1178,14 +1246,14 @@
 			"InnoDB: the hash index to a page of %s,"
 			" still %lu hash nodes remain.\n",
 			index->name, (ulong) block->n_pointers);
-		rw_lock_x_unlock(&btr_search_latch);
+		rw_lock_x_unlock(btr_search_get_latch(index->id));
 
 		btr_search_validate();
 	} else {
-		rw_lock_x_unlock(&btr_search_latch);
+		rw_lock_x_unlock(btr_search_get_latch(index->id));
 	}
 #else /* UNIV_AHI_DEBUG || UNIV_DEBUG */
-	rw_lock_x_unlock(&btr_search_latch);
+	rw_lock_x_unlock(btr_search_get_latch(index->id));
 #endif /* UNIV_AHI_DEBUG || UNIV_DEBUG */
 
 	mem_free(folds);
@@ -1217,9 +1285,9 @@
 	ulint*		offsets;
 	ibool		released_search_latch;
 
-	rw_lock_s_lock(&btr_search_latch);
+	rw_lock_s_lock(btr_search_get_latch(index->id));
 
-	table = btr_search_sys->hash_index;
+	table = btr_search_get_hash_index(index->id);
 
 	for (j = 0; j < srv_buf_pool_instances; j++) {
 		buf_pool_t*	buf_pool;
@@ -1253,7 +1321,7 @@
 
 
 					/* keeping latch order */
-					rw_lock_s_unlock(&btr_search_latch);
+					rw_lock_s_unlock(btr_search_get_latch(index->id));
 					released_search_latch = TRUE;
 					rw_lock_x_lock(&block->lock);
 
@@ -1305,7 +1373,7 @@
 						mem_heap_empty(heap);
 					}
 
-					rw_lock_x_lock(&btr_search_latch);
+					rw_lock_x_lock(btr_search_get_latch(index->id));
 
 					if (UNIV_UNLIKELY(!block->is_hashed)) {
 						goto cleanup;
@@ -1315,12 +1383,12 @@
 
 					if (UNIV_UNLIKELY(block->curr_n_fields != n_fields)
 					    || UNIV_UNLIKELY(block->curr_n_bytes != n_bytes)) {
-						rw_lock_x_unlock(&btr_search_latch);
+						rw_lock_x_unlock(btr_search_get_latch(index->id));
 						rw_lock_x_unlock(&block->lock);
 
 						mem_free(folds);
 
-						rw_lock_s_lock(&btr_search_latch);
+						rw_lock_s_lock(btr_search_get_latch(index->id));
 						goto retry;
 					}
 
@@ -1334,6 +1402,7 @@
 
 					block->is_hashed = FALSE;
 					block->index = NULL;
+					block->btr_search_latch = NULL;
 
 cleanup:
 #if defined UNIV_AHI_DEBUG || defined UNIV_DEBUG
@@ -1346,18 +1415,18 @@
 							index->name, (ulong) block->n_pointers);
 					}
 #endif /* UNIV_AHI_DEBUG || UNIV_DEBUG */
-					rw_lock_x_unlock(&btr_search_latch);
+					rw_lock_x_unlock(btr_search_get_latch(index->id));
 					rw_lock_x_unlock(&block->lock);
 
 					mem_free(folds);
 
-					rw_lock_s_lock(&btr_search_latch);
+					rw_lock_s_lock(btr_search_get_latch(index->id));
 				}
 			}
 		} while (released_search_latch);
 	}
 
-	rw_lock_s_unlock(&btr_search_latch);
+	rw_lock_s_unlock(btr_search_get_latch(index->id));
 
 	if (UNIV_LIKELY_NULL(heap)) {
 		mem_heap_free(heap);
@@ -1404,7 +1473,7 @@
 
 		buf_block_dbg_add_level(block, SYNC_TREE_NODE_FROM_HASH);
 
-		btr_search_drop_page_hash_index(block);
+		btr_search_drop_page_hash_index(block, NULL);
 	}
 
 	mtr_commit(&mtr);
@@ -1446,26 +1515,26 @@
 	ut_ad(index);
 	ut_a(!dict_index_is_ibuf(index));
 
-	table = btr_search_sys->hash_index;
+	table = btr_search_get_hash_index(index->id);
 	page = buf_block_get_frame(block);
 
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+	ut_ad(!rw_lock_own(btr_search_get_latch(index->id), RW_LOCK_EX));
 	ut_ad(rw_lock_own(&(block->lock), RW_LOCK_SHARED)
 	      || rw_lock_own(&(block->lock), RW_LOCK_EX));
 #endif /* UNIV_SYNC_DEBUG */
 
-	rw_lock_s_lock(&btr_search_latch);
+	rw_lock_s_lock(btr_search_get_latch(index->id));
 
 	if (block->is_hashed && ((block->curr_n_fields != n_fields)
 				 || (block->curr_n_bytes != n_bytes)
 				 || (block->curr_left_side != left_side))) {
 
-		rw_lock_s_unlock(&btr_search_latch);
+		rw_lock_s_unlock(btr_search_get_latch(index->id));
 
-		btr_search_drop_page_hash_index(block);
+		btr_search_drop_page_hash_index(block, index);
 	} else {
-		rw_lock_s_unlock(&btr_search_latch);
+		rw_lock_s_unlock(btr_search_get_latch(index->id));
 	}
 
 	n_recs = page_get_n_recs(page);
@@ -1559,9 +1628,9 @@
 		fold = next_fold;
 	}
 
-	btr_search_check_free_space_in_heap();
+	btr_search_check_free_space_in_heap(index->id);
 
-	rw_lock_x_lock(&btr_search_latch);
+	rw_lock_x_lock(btr_search_get_latch(index->id));
 
 	if (UNIV_UNLIKELY(btr_search_fully_disabled)) {
 		goto exit_func;
@@ -1589,6 +1658,7 @@
 	block->curr_n_bytes = n_bytes;
 	block->curr_left_side = left_side;
 	block->index = index;
+	block->btr_search_latch = btr_search_get_latch(index->id);
 
 	for (i = 0; i < n_cached; i++) {
 
@@ -1596,7 +1666,7 @@
 	}
 
 exit_func:
-	rw_lock_x_unlock(&btr_search_latch);
+	rw_lock_x_unlock(btr_search_get_latch(index->id));
 
 	mem_free(folds);
 	mem_free(recs);
@@ -1635,13 +1705,13 @@
 	ut_a(!(new_block->is_hashed || block->is_hashed)
 	     || !dict_index_is_ibuf(index));
 
-	rw_lock_s_lock(&btr_search_latch);
+	rw_lock_s_lock(btr_search_get_latch(index->id));
 
 	if (new_block->is_hashed) {
 
-		rw_lock_s_unlock(&btr_search_latch);
+		rw_lock_s_unlock(btr_search_get_latch(index->id));
 
-		btr_search_drop_page_hash_index(block);
+		btr_search_drop_page_hash_index(block, index);
 
 		return;
 	}
@@ -1656,7 +1726,7 @@
 		new_block->n_bytes = block->curr_n_bytes;
 		new_block->left_side = left_side;
 
-		rw_lock_s_unlock(&btr_search_latch);
+		rw_lock_s_unlock(btr_search_get_latch(index->id));
 
 		ut_a(n_fields + n_bytes > 0);
 
@@ -1668,7 +1738,7 @@
 		return;
 	}
 
-	rw_lock_s_unlock(&btr_search_latch);
+	rw_lock_s_unlock(btr_search_get_latch(index->id));
 }
 
 /********************************************************************//**
@@ -1707,7 +1777,7 @@
 	ut_a(block->curr_n_fields + block->curr_n_bytes > 0);
 	ut_a(!dict_index_is_ibuf(cursor->index));
 
-	table = btr_search_sys->hash_index;
+	table = btr_search_get_hash_index(cursor->index->id);
 
 	index_id = cursor->index->id;
 	fold = rec_fold(rec, rec_get_offsets(rec, cursor->index, offsets_,
@@ -1716,11 +1786,11 @@
 	if (UNIV_LIKELY_NULL(heap)) {
 		mem_heap_free(heap);
 	}
-	rw_lock_x_lock(&btr_search_latch);
+	rw_lock_x_lock(btr_search_get_latch(cursor->index->id));
 
 	ha_search_and_delete_if_found(table, fold, rec);
 
-	rw_lock_x_unlock(&btr_search_latch);
+	rw_lock_x_unlock(btr_search_get_latch(cursor->index->id));
 }
 
 /********************************************************************//**
@@ -1754,21 +1824,21 @@
 	ut_a(block->index == cursor->index);
 	ut_a(!dict_index_is_ibuf(cursor->index));
 
-	rw_lock_x_lock(&btr_search_latch);
+	rw_lock_x_lock(btr_search_get_latch(cursor->index->id));
 
 	if ((cursor->flag == BTR_CUR_HASH)
 	    && (cursor->n_fields == block->curr_n_fields)
 	    && (cursor->n_bytes == block->curr_n_bytes)
 	    && !block->curr_left_side) {
 
-		table = btr_search_sys->hash_index;
+		table = btr_search_get_hash_index(cursor->index->id);
 
 		ha_search_and_update_if_found(table, cursor->fold, rec,
 					      block, page_rec_get_next(rec));
 
-		rw_lock_x_unlock(&btr_search_latch);
+		rw_lock_x_unlock(btr_search_get_latch(cursor->index->id));
 	} else {
-		rw_lock_x_unlock(&btr_search_latch);
+		rw_lock_x_unlock(btr_search_get_latch(cursor->index->id));
 
 		btr_search_update_hash_on_insert(cursor);
 	}
@@ -1803,9 +1873,9 @@
 	ulint*		offsets		= offsets_;
 	rec_offs_init(offsets_);
 
-	table = btr_search_sys->hash_index;
+	table = btr_search_get_hash_index(cursor->index->id);
 
-	btr_search_check_free_space_in_heap();
+	btr_search_check_free_space_in_heap(cursor->index->id);
 
 	rec = btr_cur_get_rec(cursor);
 
@@ -1850,7 +1920,7 @@
 	} else {
 		if (left_side) {
 
-			rw_lock_x_lock(&btr_search_latch);
+			rw_lock_x_lock(btr_search_get_latch(index_id));
 
 			locked = TRUE;
 
@@ -1864,7 +1934,7 @@
 
 		if (!locked) {
 
-			rw_lock_x_lock(&btr_search_latch);
+			rw_lock_x_lock(btr_search_get_latch(index_id));
 
 			locked = TRUE;
 		}
@@ -1882,7 +1952,7 @@
 		if (!left_side) {
 
 			if (!locked) {
-				rw_lock_x_lock(&btr_search_latch);
+				rw_lock_x_lock(btr_search_get_latch(index_id));
 
 				locked = TRUE;
 			}
@@ -1897,7 +1967,7 @@
 
 		if (!locked) {
 
-			rw_lock_x_lock(&btr_search_latch);
+			rw_lock_x_lock(btr_search_get_latch(index_id));
 
 			locked = TRUE;
 		}
@@ -1920,7 +1990,7 @@
 		mem_heap_free(heap);
 	}
 	if (locked) {
-		rw_lock_x_unlock(&btr_search_latch);
+		rw_lock_x_unlock(btr_search_get_latch(index_id));
 	}
 }
 
@@ -1936,7 +2006,7 @@
 	ha_node_t*	node;
 	ulint		n_page_dumps	= 0;
 	ibool		ok		= TRUE;
-	ulint		i;
+	ulint		i,j;
 	ulint		cell_count;
 	mem_heap_t*	heap		= NULL;
 	ulint		offsets_[REC_OFFS_NORMAL_SIZE];
@@ -1948,23 +2018,25 @@
 
 	rec_offs_init(offsets_);
 
-	rw_lock_x_lock(&btr_search_latch);
+	btr_search_x_lock_all();
 	buf_pool_page_hash_x_lock_all();
 
-	cell_count = hash_get_n_cells(btr_search_sys->hash_index);
+	for (j = 0; j < btr_search_index_num; j++) {
+
+	cell_count = hash_get_n_cells(btr_search_sys->hash_index[j]);
 
 	for (i = 0; i < cell_count; i++) {
 		/* We release btr_search_latch every once in a while to
 		give other queries a chance to run. */
 		if ((i != 0) && ((i % chunk_size) == 0)) {
 			buf_pool_page_hash_x_unlock_all();
-			rw_lock_x_unlock(&btr_search_latch);
+			btr_search_x_unlock_all();
 			os_thread_yield();
-			rw_lock_x_lock(&btr_search_latch);
+			btr_search_x_lock_all();
 			buf_pool_page_hash_x_lock_all();
 		}
 
-		node = hash_get_nth_cell(btr_search_sys->hash_index, i)->node;
+		node = hash_get_nth_cell(btr_search_sys->hash_index[j], i)->node;
 
 		for (; node != NULL; node = node->next) {
 			const buf_block_t*	block
@@ -2073,19 +2145,21 @@
 		give other queries a chance to run. */
 		if (i != 0) {
 			buf_pool_page_hash_x_unlock_all();
-			rw_lock_x_unlock(&btr_search_latch);
+			btr_search_x_unlock_all();
 			os_thread_yield();
-			rw_lock_x_lock(&btr_search_latch);
+			btr_search_x_lock_all();
 			buf_pool_page_hash_x_lock_all();
 		}
 
-		if (!ha_validate(btr_search_sys->hash_index, i, end_index)) {
+		if (!ha_validate(btr_search_sys->hash_index[j], i, end_index)) {
 			ok = FALSE;
 		}
 	}
 
+	} /*for (j = 0; j < btr_search_index_num; j++)*/
+
 	buf_pool_page_hash_x_unlock_all();
-	rw_lock_x_unlock(&btr_search_latch);
+	btr_search_x_unlock_all();
 	if (UNIV_LIKELY_NULL(heap)) {
 		mem_heap_free(heap);
 	}
--- a/storage/innobase/buf/buf0buf.c
+++ b/storage/innobase/buf/buf0buf.c
@@ -950,6 +950,7 @@
 
 	block->check_index_page_at_flush = FALSE;
 	block->index = NULL;
+	block->btr_search_latch = NULL;
 
 	block->is_hashed = FALSE;
 
@@ -1414,7 +1415,7 @@
 			/* To follow the latching order, we
 			have to release btr_search_latch
 			before acquiring block->latch. */
-			rw_lock_x_unlock(&btr_search_latch);
+			btr_search_x_unlock_all();
 			/* When we release the search latch,
 			we must rescan all blocks, because
 			some may become hashed again. */
@@ -1445,11 +1446,11 @@
 			anything.  block->is_hashed can only
 			be set on uncompressed file pages. */
 
-			btr_search_drop_page_hash_index(block);
+			btr_search_drop_page_hash_index(block, NULL);
 
 			rw_lock_x_unlock(&block->lock);
 
-			rw_lock_x_lock(&btr_search_latch);
+			btr_search_x_lock_all();
 
 			ut_ad(!btr_search_enabled);
 		}
@@ -1468,7 +1469,11 @@
 	ibool		released_search_latch;
 
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+	ulint	j;
+
+	for (j = 0; j < btr_search_index_num; j++) {
+		ut_ad(rw_lock_own(btr_search_latch_part[j], RW_LOCK_EX));
+	}
 #endif /* UNIV_SYNC_DEBUG */
 	ut_ad(!btr_search_enabled);
 
@@ -2204,6 +2209,7 @@
 {
 	block->check_index_page_at_flush = FALSE;
 	block->index		= NULL;
+	block->btr_search_latch	= NULL;
 
 	block->n_hash_helps	= 0;
 	block->is_hashed	= FALSE;
--- a/storage/innobase/buf/buf0lru.c
+++ b/storage/innobase/buf/buf0lru.c
@@ -560,7 +560,7 @@
 
 		mutex_exit(&buf_pool->LRU_list_mutex);
 
-		rw_lock_s_lock(&btr_search_latch);
+		btr_search_s_lock_all();
 		chunk = buf_pool->chunks;
 		for (j = buf_pool->n_chunks; j--; chunk++) {
 			buf_block_t*	block	= chunk->blocks;
@@ -572,16 +572,16 @@
 					continue;
 				}
 
-				rw_lock_s_unlock(&btr_search_latch);
+				btr_search_s_unlock_all();
 
 				rw_lock_x_lock(&block->lock);
-				btr_search_drop_page_hash_index(block);
+				btr_search_drop_page_hash_index(block, NULL);
 				rw_lock_x_unlock(&block->lock);
 
-				rw_lock_s_lock(&btr_search_latch);
+				btr_search_s_lock_all();
 			}
 		}
-		rw_lock_s_unlock(&btr_search_latch);
+		btr_search_s_unlock_all();
 	}
 }
 
@@ -1744,7 +1744,7 @@
 
 		UNIV_MEM_VALID(((buf_block_t*) bpage)->frame,
 			       UNIV_PAGE_SIZE);
-		btr_search_drop_page_hash_index((buf_block_t*) bpage);
+		btr_search_drop_page_hash_index((buf_block_t*) bpage, NULL);
 		UNIV_MEM_INVALID(((buf_block_t*) bpage)->frame,
 				 UNIV_PAGE_SIZE);
 
--- a/storage/innobase/dict/dict0dict.c
+++ b/storage/innobase/dict/dict0dict.c
@@ -1846,7 +1846,7 @@
 	zero. */
 
 	for (;;) {
-		ulint ref_count = btr_search_info_get_ref_count(info);
+		ulint ref_count = btr_search_info_get_ref_count(info, index->id);
 		if (ref_count == 0) {
 			break;
 		}
--- a/storage/innobase/ha/ha0ha.c
+++ b/storage/innobase/ha/ha0ha.c
@@ -102,7 +102,8 @@
 	ut_ad(table);
 	ut_ad(table->magic_n == HASH_TABLE_MAGIC_N);
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(rw_lock_own(&btr_search_latch, RW_LOCK_EXCLUSIVE));
+	/* cannot identificate which btr_search_latch[i] for now */
+	//ut_ad(rw_lock_own(&btr_search_latch, RW_LOCK_EXCLUSIVE));
 #endif /* UNIV_SYNC_DEBUG */
 
 #ifndef UNIV_HOTBACKUP
--- a/storage/innobase/handler/ha_innodb.cc
+++ b/storage/innobase/handler/ha_innodb.cc
@@ -11824,6 +11824,11 @@
   "Disable with --skip-innodb-adaptive-hash-index.",
   NULL, innodb_adaptive_hash_index_update, TRUE);
 
+static MYSQL_SYSVAR_ULONG(adaptive_hash_index_partitions, btr_search_index_num,
+  PLUGIN_VAR_RQCMDARG | PLUGIN_VAR_READONLY,
+  "Number of InnoDB adaptive hash index partitions (default 1: disable partitioning)",
+  NULL, NULL, 1, 1, sizeof(ulint) * 8, 0);
+
 static MYSQL_SYSVAR_ULONG(replication_delay, srv_replication_delay,
   PLUGIN_VAR_RQCMDARG,
   "Replication thread delay (ms) on the slave server if "
@@ -12204,6 +12209,7 @@
   MYSQL_SYSVAR(use_sys_stats_table),
   MYSQL_SYSVAR(stats_sample_pages),
   MYSQL_SYSVAR(adaptive_hash_index),
+  MYSQL_SYSVAR(adaptive_hash_index_partitions),
   MYSQL_SYSVAR(stats_method),
   MYSQL_SYSVAR(replication_delay),
   MYSQL_SYSVAR(status_file),
--- a/storage/innobase/include/btr0sea.h
+++ b/storage/innobase/include/btr0sea.h
@@ -85,7 +85,8 @@
 ulint
 btr_search_info_get_ref_count(
 /*==========================*/
-	btr_search_t*   info);	/*!< in: search info. */
+	btr_search_t*   info,	/*!< in: search info. */
+	index_id_t	key);
 /*********************************************************************//**
 Updates the search info. */
 UNIV_INLINE
@@ -136,10 +137,11 @@
 void
 btr_search_drop_page_hash_index(
 /*============================*/
-	buf_block_t*	block);	/*!< in: block containing index page,
+	buf_block_t*	block,	/*!< in: block containing index page,
 				s- or x-latched, or an index page
 				for which we know that
 				block->buf_fix_count == 0 */
+	dict_index_t*	index_in);
 /************************************************************************
 Drops a page hash index based on index */
 UNIV_INTERN
@@ -199,10 +201,47 @@
 # define btr_search_validate()	TRUE
 #endif /* defined UNIV_AHI_DEBUG || defined UNIV_DEBUG */
 
+/********************************************************************//**
+New functions to control split btr_search_index */
+UNIV_INLINE
+hash_table_t*
+btr_search_get_hash_index(
+/*======================*/
+	index_id_t	key);
+
+UNIV_INLINE
+rw_lock_t*
+btr_search_get_latch(
+/*=================*/
+	index_id_t	key);
+
+UNIV_INLINE
+void
+btr_search_x_lock_all(void);
+/*========================*/
+
+UNIV_INLINE
+void
+btr_search_x_unlock_all(void);
+/*==========================*/
+
+UNIV_INLINE
+void
+btr_search_s_lock_all(void);
+/*========================*/
+
+UNIV_INLINE
+void
+btr_search_s_unlock_all(void);
+/*==========================*/
+
+
 /** Flag: has the search system been enabled?
 Protected by btr_search_latch and btr_search_enabled_mutex. */
 extern char	btr_search_enabled;
 
+extern ulint	btr_search_index_num;
+
 /** Flag: whether the search system has completed its disabling process,
 It is set to TRUE right after buf_pool_drop_hash_index() in
 btr_search_disable(), indicating hash index entries are cleaned up.
@@ -269,7 +308,7 @@
 
 /** The hash index system */
 struct btr_search_sys_struct{
-	hash_table_t*	hash_index;	/*!< the adaptive hash index,
+	hash_table_t**	hash_index;	/*!< the adaptive hash index,
 					mapping dtuple_fold values
 					to rec_t pointers on index pages */
 };
@@ -290,10 +329,12 @@
 
 Bear in mind (3) and (4) when using the hash index.
 */
-extern rw_lock_t*	btr_search_latch_temp;
+//extern rw_lock_t*	btr_search_latch_temp;
+
+extern rw_lock_t**	btr_search_latch_part;
 
 /** The latch protecting the adaptive search system */
-#define btr_search_latch	(*btr_search_latch_temp)
+//#define btr_search_latch	(*btr_search_latch_temp)
 
 #ifdef UNIV_SEARCH_PERF_STAT
 /** Number of successful adaptive hash index lookups */
--- a/storage/innobase/include/btr0sea.ic
+++ b/storage/innobase/include/btr0sea.ic
@@ -62,8 +62,8 @@
 	btr_search_t*	info;
 
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_SHARED));
-	ut_ad(!rw_lock_own(&btr_search_latch, RW_LOCK_EX));
+	ut_ad(!rw_lock_own(btr_search_get_latch(index->id), RW_LOCK_SHARED));
+	ut_ad(!rw_lock_own(btr_search_get_latch(index->id), RW_LOCK_EX));
 #endif /* UNIV_SYNC_DEBUG */
 
 	info = btr_search_get_info(index);
@@ -82,3 +82,72 @@
 
 	btr_search_info_update_slow(info, cursor);
 }
+
+/*********************************************************************//**
+New functions to control split btr_search_index */
+UNIV_INLINE
+hash_table_t*
+btr_search_get_hash_index(
+/*======================*/
+	index_id_t	key)
+{
+	return(btr_search_sys->hash_index[key % btr_search_index_num]);
+}
+
+UNIV_INLINE
+rw_lock_t*
+btr_search_get_latch(
+/*=================*/
+	index_id_t	key)
+{
+	return(btr_search_latch_part[key % btr_search_index_num]);
+}
+
+UNIV_INLINE
+void
+btr_search_x_lock_all(void)
+/*=======================*/
+{
+	ulint	i;
+
+	for (i = 0; i < btr_search_index_num; i++) {
+		rw_lock_x_lock(btr_search_latch_part[i]);
+	}
+}
+
+UNIV_INLINE
+void
+btr_search_x_unlock_all(void)
+/*==========================*/
+{
+	ulint	i;
+
+	for (i = 0; i < btr_search_index_num; i++) {
+		rw_lock_x_unlock(btr_search_latch_part[i]);
+	}
+}
+
+UNIV_INLINE
+void
+btr_search_s_lock_all(void)
+/*=======================*/
+{
+	ulint	i;
+
+	for (i = 0; i < btr_search_index_num; i++) {
+		rw_lock_s_lock(btr_search_latch_part[i]);
+	}
+}
+
+UNIV_INLINE
+void
+btr_search_s_unlock_all(void)
+/*=========================*/
+{
+	ulint	i;
+
+	for (i = 0; i < btr_search_index_num; i++) {
+		rw_lock_s_unlock(btr_search_latch_part[i]);
+	}
+}
+
--- a/storage/innobase/include/buf0buf.h
+++ b/storage/innobase/include/buf0buf.h
@@ -1576,7 +1576,7 @@
 					pointers in the adaptive hash index
 					pointing to this frame */
 #endif /* UNIV_AHI_DEBUG || UNIV_DEBUG */
-	unsigned	is_hashed:1;	/*!< TRUE if hash index has
+	volatile unsigned	is_hashed:1;	/*!< TRUE if hash index has
 					already been built on this
 					page; note that it does not
 					guarantee that the index is
@@ -1590,6 +1590,7 @@
 	unsigned	curr_left_side:1;/*!< TRUE or FALSE in hash indexing */
 	dict_index_t*	index;		/*!< Index for which the adaptive
 					hash index has been created. */
+	volatile rw_lock_t*	btr_search_latch;
 	/* @} */
 # ifdef UNIV_SYNC_DEBUG
 	/** @name Debug fields */
--- a/storage/innobase/page/page0page.c
+++ b/storage/innobase/page/page0page.c
@@ -218,7 +218,7 @@
 	const ibool	is_hashed	= block->is_hashed;
 
 	if (is_hashed) {
-		rw_lock_x_lock(&btr_search_latch);
+		rw_lock_x_lock(btr_search_get_latch(block->index->id));
 	}
 
 	ut_ad(!mtr || mtr_memo_contains(mtr, block, MTR_MEMO_PAGE_X_FIX));
@@ -244,7 +244,7 @@
 
 #ifndef UNIV_HOTBACKUP
 	if (is_hashed) {
-		rw_lock_x_unlock(&btr_search_latch);
+		rw_lock_x_unlock(btr_search_get_latch(block->index->id));
 	}
 #endif /* !UNIV_HOTBACKUP */
 }
--- a/storage/innobase/page/page0zip.c
+++ b/storage/innobase/page/page0zip.c
@@ -4456,7 +4456,7 @@
 
 #ifndef UNIV_HOTBACKUP
 	temp_block = buf_block_alloc(buf_pool);
-	btr_search_drop_page_hash_index(block);
+	btr_search_drop_page_hash_index(block, index);
 	block->check_index_page_at_flush = TRUE;
 #else /* !UNIV_HOTBACKUP */
 	ut_ad(block == back_block1);
--- a/storage/innobase/row/row0mysql.c
+++ b/storage/innobase/row/row0mysql.c
@@ -2594,7 +2594,7 @@
 			/* check adaptive hash entries */
 			index = dict_table_get_first_index(table);
 			while (index) {
-				ulint ref_count = btr_search_info_get_ref_count(index->search_info);
+				ulint ref_count = btr_search_info_get_ref_count(index->search_info, index->id);
 				if (ref_count) {
 					fprintf(stderr, "InnoDB: Warning:"
 						" hash index ref_count (%lu) is not zero"
@@ -2955,7 +2955,7 @@
 			table->space = space;
 			index = dict_table_get_first_index(table);
 			do {
-				ulint ref_count = btr_search_info_get_ref_count(index->search_info);
+				ulint ref_count = btr_search_info_get_ref_count(index->search_info, index->id);
 				/* check adaptive hash entries */
 				if (ref_count) {
 					fprintf(stderr, "InnoDB: Warning:"
--- a/storage/innobase/row/row0sel.c
+++ b/storage/innobase/row/row0sel.c
@@ -1222,7 +1222,7 @@
 	ut_ad(plan->unique_search);
 	ut_ad(!plan->must_get_clust);
 #ifdef UNIV_SYNC_DEBUG
-	ut_ad(rw_lock_own(&btr_search_latch, RW_LOCK_SHARED));
+	ut_ad(rw_lock_own(btr_search_get_latch(index->id), RW_LOCK_SHARED));
 #endif /* UNIV_SYNC_DEBUG */
 
 	row_sel_open_pcur(plan, TRUE, mtr);
@@ -1393,10 +1393,10 @@
 	    && !plan->must_get_clust
 	    && !plan->table->big_rows) {
 		if (!search_latch_locked) {
-			rw_lock_s_lock(&btr_search_latch);
+			rw_lock_s_lock(btr_search_get_latch(index->id));
 
 			search_latch_locked = TRUE;
-		} else if (rw_lock_get_writer(&btr_search_latch) == RW_LOCK_WAIT_EX) {
+		} else if (rw_lock_get_writer(btr_search_get_latch(index->id)) == RW_LOCK_WAIT_EX) {
 
 			/* There is an x-latch request waiting: release the
 			s-latch for a moment; as an s-latch here is often
@@ -1405,8 +1405,8 @@
 			from acquiring an s-latch for a long time, lowering
 			performance significantly in multiprocessors. */
 
-			rw_lock_s_unlock(&btr_search_latch);
-			rw_lock_s_lock(&btr_search_latch);
+			rw_lock_s_unlock(btr_search_get_latch(index->id));
+			rw_lock_s_lock(btr_search_get_latch(index->id));
 		}
 
 		found_flag = row_sel_try_search_shortcut(node, plan, &mtr);
@@ -1429,7 +1429,7 @@
 	}
 
 	if (search_latch_locked) {
-		rw_lock_s_unlock(&btr_search_latch);
+		rw_lock_s_unlock(btr_search_get_latch(index->id));
 
 		search_latch_locked = FALSE;
 	}
@@ -2005,7 +2005,7 @@
 
 func_exit:
 	if (search_latch_locked) {
-		rw_lock_s_unlock(&btr_search_latch);
+		rw_lock_s_unlock(btr_search_get_latch(index->id));
 	}
 	if (UNIV_LIKELY_NULL(heap)) {
 		mem_heap_free(heap);
@@ -3408,6 +3408,8 @@
 	/* if the returned record was locked and we did a semi-consistent
 	read (fetch the newest committed version), then this is set to
 	TRUE */
+	ulint		i;
+	ulint		should_release;
 #ifdef UNIV_SEARCH_DEBUG
 	ulint		cnt				= 0;
 #endif /* UNIV_SEARCH_DEBUG */
@@ -3505,18 +3507,33 @@
 	/* PHASE 0: Release a possible s-latch we are holding on the
 	adaptive hash index latch if there is someone waiting behind */
 
-	if (UNIV_UNLIKELY(rw_lock_get_writer(&btr_search_latch) != RW_LOCK_NOT_LOCKED)
-	    && trx->has_search_latch) {
+	should_release = 0;
+	for (i = 0; i < btr_search_index_num; i++) {
+		/* we should check all latches (fix Bug#791030) */
+		if (rw_lock_get_writer(btr_search_latch_part[i])
+		    != RW_LOCK_NOT_LOCKED) {
+			should_release |= ((ulint)1 << i);
+		}
+	}
+
+	if (should_release) {
 
 		/* There is an x-latch request on the adaptive hash index:
 		release the s-latch to reduce starvation and wait for
 		BTR_SEA_TIMEOUT rounds before trying to keep it again over
 		calls from MySQL */
 
-		rw_lock_s_unlock(&btr_search_latch);
-		trx->has_search_latch = FALSE;
+		for (i = 0; i < btr_search_index_num; i++) {
+			/* we should release all s-latches (fix Bug#791030) */
+			if (trx->has_search_latch & ((ulint)1 << i)) {
+				rw_lock_s_unlock(btr_search_latch_part[i]);
+				trx->has_search_latch &= (~((ulint)1 << i));
+			}
+		}
 
+		if (!trx->has_search_latch) {
 		trx->search_latch_timeout = BTR_SEA_TIMEOUT;
+		}
 	}
 
 	/* Reset the new record lock info if srv_locks_unsafe_for_binlog
@@ -3667,9 +3684,28 @@
 			hash index semaphore! */
 
 #ifndef UNIV_SEARCH_DEBUG
-			if (!trx->has_search_latch) {
-				rw_lock_s_lock(&btr_search_latch);
-				trx->has_search_latch = TRUE;
+			if (!(trx->has_search_latch
+			      & ((ulint)1 << (index->id % btr_search_index_num)))) {
+				if (trx->has_search_latch
+				    < ((ulint)1 << (index->id % btr_search_index_num))) {
+					rw_lock_s_lock(btr_search_get_latch(index->id));
+					trx->has_search_latch |=
+						((ulint)1 << (index->id % btr_search_index_num));
+				} else {
+					/* should re-lock to obay latch-order */
+					for (i = 0; i < btr_search_index_num; i++) {
+						if (trx->has_search_latch & ((ulint)1 << i)) {
+							rw_lock_s_unlock(btr_search_latch_part[i]);
+						}
+					}
+					trx->has_search_latch |=
+						((ulint)1 << (index->id % btr_search_index_num));
+					for (i = 0; i < btr_search_index_num; i++) {
+						if (trx->has_search_latch & ((ulint)1 << i)) {
+							rw_lock_s_lock(btr_search_latch_part[i]);
+						}
+					}
+				}
 			}
 #endif
 			switch (row_sel_try_search_shortcut_for_mysql(
@@ -3730,7 +3766,11 @@
 
 					trx->search_latch_timeout--;
 
-					rw_lock_s_unlock(&btr_search_latch);
+					for (i = 0; i < btr_search_index_num; i++) {
+						if (trx->has_search_latch & ((ulint)1 << i)) {
+							rw_lock_s_unlock(btr_search_latch_part[i]);
+						}
+					}
 					trx->has_search_latch = FALSE;
 				}
 
@@ -3754,7 +3794,12 @@
 	/* PHASE 3: Open or restore index cursor position */
 
 	if (trx->has_search_latch) {
-		rw_lock_s_unlock(&btr_search_latch);
+
+		for (i = 0; i < btr_search_index_num; i++) {
+			if (trx->has_search_latch & ((ulint)1 << i)) {
+				rw_lock_s_unlock(btr_search_latch_part[i]);
+			}
+		}
 		trx->has_search_latch = FALSE;
 	}
 
--- a/storage/innobase/srv/srv0srv.c
+++ b/storage/innobase/srv/srv0srv.c
@@ -2051,7 +2051,9 @@
 	      "-------------------------------------\n", file);
 	ibuf_print(file);
 
-	ha_print_info(file, btr_search_sys->hash_index);
+	for (i = 0; i < btr_search_index_num; i++) {
+		ha_print_info(file, btr_search_get_hash_index((index_id_t)i));
+	}
 
 	fprintf(file,
 		"%.2f hash searches/s, %.2f non-hash searches/s\n",
@@ -2076,14 +2078,15 @@
 			ut_total_allocated_memory,
 			mem_pool_get_reserved(mem_comm_pool));
 	/* Calcurate reserved memories */
-	if (btr_search_sys && btr_search_sys->hash_index->heap) {
-		btr_search_sys_subtotal = mem_heap_get_size(btr_search_sys->hash_index->heap);
+	if (btr_search_sys && btr_search_sys->hash_index[0]->heap) {
+		btr_search_sys_subtotal = mem_heap_get_size(btr_search_sys->hash_index[0]->heap);
 	} else {
 		btr_search_sys_subtotal = 0;
-		for (i=0; i < btr_search_sys->hash_index->n_mutexes; i++) {
-			btr_search_sys_subtotal += mem_heap_get_size(btr_search_sys->hash_index->heaps[i]);
+		for (i=0; i < btr_search_sys->hash_index[0]->n_mutexes; i++) {
+			btr_search_sys_subtotal += mem_heap_get_size(btr_search_sys->hash_index[0]->heaps[i]);
 		}
 	}
+	btr_search_sys_subtotal *= btr_search_index_num;
 
 	lock_sys_subtotal = 0;
 	if (trx_sys) {
@@ -2109,10 +2112,10 @@
 			"    Recovery system     %lu \t(%lu + %lu)\n",
 
 			(ulong) (btr_search_sys
-				? (btr_search_sys->hash_index->n_cells * sizeof(hash_cell_t)) : 0)
+				? (btr_search_sys->hash_index[0]->n_cells * btr_search_index_num * sizeof(hash_cell_t)) : 0)
 			+ btr_search_sys_subtotal,
 			(ulong) (btr_search_sys
-				? (btr_search_sys->hash_index->n_cells * sizeof(hash_cell_t)) : 0),
+				? (btr_search_sys->hash_index[0]->n_cells * btr_search_index_num * sizeof(hash_cell_t)) : 0),
 			(ulong) btr_search_sys_subtotal,
 
 			(ulong) (buf_pool_from_array(0)->page_hash->n_cells * sizeof(hash_cell_t)),
--- a/storage/innobase/sync/sync0sync.c
+++ b/storage/innobase/sync/sync0sync.c
@@ -1222,7 +1222,6 @@
 	case SYNC_OUTER_ANY_LATCH:
 	case SYNC_FILE_FORMAT_TAG:
 	case SYNC_DOUBLEWRITE:
-	case SYNC_SEARCH_SYS:
 	case SYNC_SEARCH_SYS_CONF:
 	case SYNC_TRX_LOCK_HEAP:
 	case SYNC_KERNEL:
@@ -1244,6 +1243,7 @@
 			ut_error;
 		}
 		break;
+	case SYNC_SEARCH_SYS:
 	case SYNC_BUF_LRU_LIST:
 	case SYNC_BUF_FLUSH_LIST:
 	case SYNC_BUF_PAGE_HASH:
--- a/storage/innobase/trx/trx0trx.c
+++ b/storage/innobase/trx/trx0trx.c
@@ -265,8 +265,14 @@
 /*=================================*/
 	trx_t*	   trx) /*!< in: transaction */
 {
+	ulint	i;
+
 	if (trx->has_search_latch) {
-		rw_lock_s_unlock(&btr_search_latch);
+		for (i = 0; i < btr_search_index_num; i++) {
+			if (trx->has_search_latch & ((ulint)1 << i)) {
+				rw_lock_s_unlock(btr_search_latch_part[i]);
+			}
+		}
 
 		trx->has_search_latch = FALSE;
 	}
