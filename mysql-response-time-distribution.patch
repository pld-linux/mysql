# name       : response-time-distribution.patch
# introduced : 12
# maintainer : Oleg
#
#!!! notice !!!
# Any small change to this file in the main branch
# should be done or reviewed by the maintainer!
diff -ruN a/include/mysql_com.h b/include/mysql_com.h
--- a/include/mysql_com.h	2010-11-01 08:43:53.000000000 +0000
+++ b/include/mysql_com.h	2010-11-01 08:52:40.000000000 +0000
@@ -128,10 +128,11 @@
 #define REFRESH_FAST		32768	/* Intern flag */
 
 /* RESET (remove all queries) from query cache */
-#define REFRESH_QUERY_CACHE	65536
-#define REFRESH_QUERY_CACHE_FREE 0x20000L /* pack query cache */
-#define REFRESH_DES_KEY_FILE	0x40000L
-#define REFRESH_USER_RESOURCES	0x80000L
+#define REFRESH_QUERY_CACHE	     65536
+#define REFRESH_QUERY_CACHE_FREE    0x20000L /* pack query cache */
+#define REFRESH_DES_KEY_FILE	     0x40000L
+#define REFRESH_USER_RESOURCES	     0x80000L
+#define REFRESH_QUERY_RESPONSE_TIME 0x100000L /* response time distibution */
 
 #define CLIENT_LONG_PASSWORD	1	/* new more secure passwords */
 #define CLIENT_FOUND_ROWS	2	/* Found instead of affected rows */
diff -ruN a/patch_info/response-time-distribution.info b/patch_info/response-time-distribution.info
--- a/patch_info/response-time-distribution.info	1970-01-01 00:00:00.000000000 +0000
+++ b/patch_info/response-time-distribution.info	2010-11-01 08:52:40.000000000 +0000
@@ -0,0 +1,9 @@
+File=response-time-distribution.patch
+Name=Response time distribution
+Version=1.0
+Author=Percona <info@percona.com>
+License=GPL
+Comment=
+Changelog
+2010-07-02 first version avaliable
+2010-09-15 add column 'total'
diff -ruN a/sql/Makefile.am b/sql/Makefile.am
--- a/sql/Makefile.am	2010-11-01 08:43:52.000000000 +0000
+++ b/sql/Makefile.am	2010-11-01 08:52:40.000000000 +0000
@@ -66,7 +66,7 @@
 			sql_repl.h slave.h rpl_filter.h rpl_injector.h \
 			log_event.h rpl_record.h \
 			log_event_old.h rpl_record_old.h \
-			sql_sort.h sql_cache.h set_var.h \
+			sql_sort.h sql_cache.h set_var.h query_response_time.h \
 			spatial.h gstream.h client_settings.h tzfile.h \
 			tztime.h my_decimal.h\
 			sp_head.h sp_pcontext.h sp_rcontext.h sp.h sp_cache.h \
@@ -89,7 +89,7 @@
 			sql_string.cc sql_manager.cc sql_map.cc \
 			mysqld.cc password.c hash_filo.cc hostname.cc \
 			sql_connect.cc scheduler.cc sql_parse.cc \
-			set_var.cc sql_yacc.yy \
+			set_var.cc query_response_time.cc sql_yacc.yy \
 			sql_base.cc table.cc sql_select.cc sql_insert.cc \
 			sql_profile.cc \
 			sql_prepare.cc sql_error.cc sql_locale.cc \
diff -ruN a/sql/Makefile.in b/sql/Makefile.in
--- a/sql/Makefile.in	2010-11-01 08:43:52.000000000 +0000
+++ b/sql/Makefile.in	2010-11-01 08:52:40.000000000 +0000
@@ -122,7 +122,7 @@
 	sql_string.$(OBJEXT) sql_manager.$(OBJEXT) sql_map.$(OBJEXT) \
 	mysqld.$(OBJEXT) password.$(OBJEXT) hash_filo.$(OBJEXT) \
 	hostname.$(OBJEXT) sql_connect.$(OBJEXT) scheduler.$(OBJEXT) \
-	sql_parse.$(OBJEXT) set_var.$(OBJEXT) sql_yacc.$(OBJEXT) \
+	sql_parse.$(OBJEXT) set_var.$(OBJEXT) query_response_time.${OBJEXT} sql_yacc.$(OBJEXT) \
 	sql_base.$(OBJEXT) table.$(OBJEXT) sql_select.$(OBJEXT) \
 	sql_insert.$(OBJEXT) sql_profile.$(OBJEXT) \
 	sql_prepare.$(OBJEXT) sql_error.$(OBJEXT) sql_locale.$(OBJEXT) \
@@ -562,7 +562,7 @@
 			sql_repl.h slave.h rpl_filter.h rpl_injector.h \
 			log_event.h rpl_record.h \
 			log_event_old.h rpl_record_old.h \
-			sql_sort.h sql_cache.h set_var.h \
+			sql_sort.h sql_cache.h set_var.h query_response_time.h \
 			spatial.h gstream.h client_settings.h tzfile.h \
 			tztime.h my_decimal.h\
 			sp_head.h sp_pcontext.h sp_rcontext.h sp.h sp_cache.h \
@@ -585,7 +585,7 @@
 			sql_string.cc sql_manager.cc sql_map.cc \
 			mysqld.cc password.c hash_filo.cc hostname.cc \
 			sql_connect.cc scheduler.cc sql_parse.cc \
-			set_var.cc sql_yacc.yy \
+			set_var.cc query_response_time.cc sql_yacc.yy \
 			sql_base.cc table.cc sql_select.cc sql_insert.cc \
 			sql_profile.cc \
 			sql_prepare.cc sql_error.cc sql_locale.cc \
@@ -828,6 +828,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/password.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/procedure.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/protocol.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/query_response_time.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/records.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/repl_failsafe.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rpl_filter.Po@am__quote@
diff -ruN a/sql/lex.h b/sql/lex.h
--- a/sql/lex.h	2010-11-01 08:43:53.000000000 +0000
+++ b/sql/lex.h	2010-11-01 08:52:40.000000000 +0000
@@ -415,6 +415,7 @@
   { "PURGE",		SYM(PURGE)},
   { "QUARTER",          SYM(QUARTER_SYM)},
   { "QUERY",		SYM(QUERY_SYM)},
+  { "QUERY_RESPONSE_TIME", SYM(QUERY_RESPONSE_TIME_SYM)},
   { "QUICK",	        SYM(QUICK)},
   { "RANGE",            SYM(RANGE_SYM)},
   { "READ",		SYM(READ_SYM)},
diff -ruN a/sql/mysql_priv.h b/sql/mysql_priv.h
--- a/sql/mysql_priv.h	2010-11-01 08:43:57.000000000 +0000
+++ b/sql/mysql_priv.h	2010-11-01 08:52:40.000000000 +0000
@@ -2116,6 +2116,11 @@
 extern my_bool opt_query_cache_strip_comments;
 extern my_bool opt_use_global_long_query_time;
 extern my_bool opt_slow_query_log_microseconds_timestamp;
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+extern ulong   opt_query_response_time_range_base;
+extern my_bool opt_enable_query_response_time_stats;
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
+extern SHOW_COMP_OPTION have_response_time_distribution;
 extern my_bool sp_automatic_privileges, opt_noacl;
 extern my_bool opt_old_style_user_limits, trust_function_creators;
 extern uint opt_crash_binlog_innodb;
diff -ruN a/sql/mysqld.cc b/sql/mysqld.cc
--- a/sql/mysqld.cc	2010-11-01 08:43:57.000000000 +0000
+++ b/sql/mysqld.cc	2010-11-01 08:52:40.000000000 +0000
@@ -32,6 +32,7 @@
 
 #include "rpl_injector.h"
 
+#include "query_response_time.h"
 #ifdef HAVE_SYS_PRCTL_H
 #include <sys/prctl.h>
 #endif
@@ -528,6 +529,10 @@
 my_bool opt_query_cache_strip_comments = 0;
 my_bool opt_use_global_long_query_time= 0;
 my_bool opt_slow_query_log_microseconds_timestamp= 0;
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+ulong   opt_query_response_time_range_base  = QRT_DEFAULT_BASE;
+my_bool opt_enable_query_response_time_stats= 0;
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
 my_bool lower_case_file_system= 0;
 my_bool opt_large_pages= 0;
 my_bool opt_myisam_use_mmap= 0;
@@ -673,6 +678,7 @@
 MY_LOCALE *my_default_lc_time_names;
 
 SHOW_COMP_OPTION have_ssl, have_symlink, have_dlopen, have_query_cache;
+SHOW_COMP_OPTION have_response_time_distribution;
 SHOW_COMP_OPTION have_geometry, have_rtree_keys;
 SHOW_COMP_OPTION have_crypt, have_compress;
 SHOW_COMP_OPTION have_community_features;
@@ -1383,6 +1389,9 @@
   free_global_thread_stats();
   free_global_table_stats();
   free_global_index_stats();
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+  query_response_time_free();
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
 #ifdef HAVE_REPLICATION
   end_slave_list();
 #endif
@@ -4079,6 +4088,9 @@
 
   init_global_table_stats();
   init_global_index_stats();
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+  query_response_time_init();
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
 
   /* We have to initialize the storage engines before CSV logging */
   if (ha_init())
@@ -5892,6 +5904,10 @@
   OPT_USE_GLOBAL_LONG_QUERY_TIME,
   OPT_USE_GLOBAL_LOG_SLOW_CONTROL,
   OPT_SLOW_QUERY_LOG_MICROSECONDS_TIMESTAMP,
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+  OPT_QRT_RANGE_BASE,
+  OPT_ENABLE_QRT_STATS,
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
   OPT_IGNORE_BUILTIN_INNODB,
   OPT_BINLOG_DIRECT_NON_TRANS_UPDATE,
   OPT_DEFAULT_CHARACTER_SET_OLD
@@ -6962,6 +6978,23 @@
    "Use microsecond time's precision in slow query log",
    (uchar**) &opt_slow_query_log_microseconds_timestamp, (uchar**) &opt_slow_query_log_microseconds_timestamp,
    0, GET_BOOL, OPT_ARG, 0, 0, 1, 0, 1, 0},
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+  {"query_response_time_range_base", OPT_QRT_RANGE_BASE,
+     "Select base of log for query_response_time ranges. WARNING: variable change affect only after flush",
+   (uchar**) &opt_query_response_time_range_base, (uchar**) &opt_query_response_time_range_base,
+   0, GET_ULONG, REQUIRED_ARG, 
+   /* def_value */  QRT_DEFAULT_BASE,
+   /* min_value */  2,
+   /* max_value */  QRT_MAXIMUM_BASE, 
+   /* sub_size */   0,
+   /* block_size */ 1,
+   /* app_type */ 0
+  },
+  {"enable_query_response_time_stats", OPT_ENABLE_QRT_STATS,
+   "Enable or disable query response time statisics collecting",
+   (uchar**) &opt_enable_query_response_time_stats, (uchar**) &opt_enable_query_response_time_stats,
+   0, GET_BOOL, REQUIRED_ARG, 0, 0, 1, 0, 1, 0},
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
   {"lower_case_table_names", OPT_LOWER_CASE_TABLE_NAMES,
    "If set to 1, table names are stored in lowercase on disk and table names "
    "will be case-insensitive.  Should be set to 2 if you are using a case-"
@@ -8176,6 +8209,11 @@
 #else
   have_query_cache=SHOW_OPTION_NO;
 #endif
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+  have_response_time_distribution= SHOW_OPTION_YES;
+#else /* HAVE_RESPONSE_TIME_DISTRIBUTION */
+  have_response_time_distribution= SHOW_OPTION_NO;
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
 #ifdef HAVE_SPATIAL
   have_geometry=SHOW_OPTION_YES;
 #else
diff -ruN a/sql/query_response_time.cc b/sql/query_response_time.cc
--- a/sql/query_response_time.cc	1970-01-01 00:00:00.000000000 +0000
+++ b/sql/query_response_time.cc	2010-11-02 15:34:52.000000000 +0000
@@ -0,0 +1,369 @@
+#ifdef __FreeBSD__
+#include <sys/types.h>
+#include <machine/atomic.h>
+#endif // __FreeBSD__
+#include "my_global.h"
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+#include "mysql_priv.h"
+#include "mysql_com.h"
+#include "rpl_tblmap.h"
+#include "query_response_time.h"
+
+#define TIME_STRING_POSITIVE_POWER_LENGTH QRT_TIME_STRING_POSITIVE_POWER_LENGTH
+#define TIME_STRING_NEGATIVE_POWER_LENGTH 6
+#define TOTAL_STRING_POSITIVE_POWER_LENGTH QRT_TOTAL_STRING_POSITIVE_POWER_LENGTH
+#define TOTAL_STRING_NEGATIVE_POWER_LENGTH 6
+#define MINIMUM_BASE 2
+#define MAXIMUM_BASE QRT_MAXIMUM_BASE
+#define POSITIVE_POWER_FILLER QRT_POSITIVE_POWER_FILLER
+#define NEGATIVE_POWER_FILLER QRT_NEGATIVE_POWER_FILLER
+#define STRING_OVERFLOW QRT_STRING_OVERFLOW
+#define TIME_OVERFLOW   QRT_TIME_OVERFLOW
+#define DEFAULT_BASE    QRT_DEFAULT_BASE
+
+#define do_xstr(s) do_str(s)
+#define do_str(s) #s
+#define do_format(filler,width) "%" filler width "lld"
+/*
+  Format strings for snprintf. Generate from:
+  POSITIVE_POWER_FILLER and TIME_STRING_POSITIVE_POWER_LENGTH
+  NEFATIVE_POWER_FILLER and TIME_STRING_NEGATIVE_POWER_LENGTH
+*/
+#define TIME_STRING_POSITIVE_POWER_FORMAT do_format(POSITIVE_POWER_FILLER,do_xstr(TIME_STRING_POSITIVE_POWER_LENGTH))
+#define TIME_STRING_NEGATIVE_POWER_FORMAT do_format(NEGATIVE_POWER_FILLER,do_xstr(TIME_STRING_NEGATIVE_POWER_LENGTH))
+#define TIME_STRING_FORMAT		      TIME_STRING_POSITIVE_POWER_FORMAT "." TIME_STRING_NEGATIVE_POWER_FORMAT
+
+#define TOTAL_STRING_POSITIVE_POWER_FORMAT do_format(POSITIVE_POWER_FILLER,do_xstr(TOTAL_STRING_POSITIVE_POWER_LENGTH))
+#define TOTAL_STRING_NEGATIVE_POWER_FORMAT do_format(NEGATIVE_POWER_FILLER,do_xstr(TOTAL_STRING_NEGATIVE_POWER_LENGTH))
+#define TOTAL_STRING_FORMAT		      TOTAL_STRING_POSITIVE_POWER_FORMAT "." TOTAL_STRING_NEGATIVE_POWER_FORMAT
+
+#define TIME_STRING_LENGTH	QRT_TIME_STRING_LENGTH
+#define TIME_STRING_BUFFER_LENGTH	(TIME_STRING_LENGTH + 1 /* '\0' */)
+
+#define TOTAL_STRING_LENGTH	QRT_TOTAL_STRING_LENGTH
+#define TOTAL_STRING_BUFFER_LENGTH	(TOTAL_STRING_LENGTH + 1 /* '\0' */)
+
+/*
+  Calculate length of "log linear"
+  1)
+  (MINIMUM_BASE ^ result) <= (10 ^ STRING_POWER_LENGTH) < (MINIMUM_BASE ^ (result + 1))
+
+  2)
+  (MINIMUM_BASE ^ result) <= (10 ^ STRING_POWER_LENGTH)
+  and
+  (MINIMUM_BASE ^ (result + 1)) > (10 ^ STRING_POWER_LENGTH)
+
+  3)
+  result     <= LOG(MINIMUM_BASE, 10 ^ STRING_POWER_LENGTH)= STRING_POWER_LENGTH * LOG(MINIMUM_BASE,10)
+  result + 1 >  LOG(MINIMUM_BASE, 10 ^ STRING_POWER_LENGTH)= STRING_POWER_LENGTH * LOG(MINIMUM_BASE,10)
+
+  4) STRING_POWER_LENGTH * LOG(MINIMUM_BASE,10) - 1 < result <= STRING_POWER_LENGTH * LOG(MINIMUM_BASE,10)
+
+  MINIMUM_BASE= 2 always, LOG(MINIMUM_BASE,10)= 3.3219280948873626, result= (int)3.3219280948873626 * STRING_POWER_LENGTH
+
+  Last counter always use for time overflow
+*/
+#define POSITIVE_POWER_COUNT ((int)(3.32192809 * TIME_STRING_POSITIVE_POWER_LENGTH))
+#define NEGATIVE_POWER_COUNT ((int)(3.32192809 * TIME_STRING_NEGATIVE_POWER_LENGTH))
+#define OVERALL_POWER_COUNT (NEGATIVE_POWER_COUNT + 1 + POSITIVE_POWER_COUNT)
+
+#define MILLION ((unsigned long)1000 * 1000)
+
+namespace query_response_time
+{
+
+class utility
+{
+public:
+  utility() : m_base(0)
+  {
+    m_max_dec_value= MILLION;
+    for(int i= 0; TIME_STRING_POSITIVE_POWER_LENGTH > i; ++i)
+      m_max_dec_value *= 10;
+    setup(DEFAULT_BASE);
+  }
+public:
+  uint      base()            const { return m_base; }
+  uint      negative_count()  const { return m_negative_count; }
+  uint      positive_count()  const { return m_positive_count; }
+  uint      bound_count()     const { return m_bound_count; }
+  ulonglong max_dec_value()   const { return m_max_dec_value; }
+  ulonglong bound(uint index) const { return m_bound[ index ]; }
+public:
+  void setup(uint base)
+  {
+    if(base != m_base)
+    {
+      m_base= base;
+
+      const ulonglong million= 1000 * 1000;
+      ulonglong value= million;
+      m_negative_count= 0;
+      while(value > 0)
+      {
+	m_negative_count += 1;
+	value /= m_base;
+      }
+      m_negative_count -= 1;
+
+      value= million;
+      m_positive_count= 0;
+      while(value < m_max_dec_value)
+      {
+	m_positive_count += 1;
+	value *= m_base;
+      }
+      m_bound_count= m_negative_count + m_positive_count;
+
+      value= million;
+      for(uint i= 0; i < m_negative_count; ++i)
+      {
+	value /= m_base;
+	m_bound[m_negative_count - i - 1]= value;
+      }
+      value= million;
+      for(uint i= 0; i < m_positive_count;  ++i)
+      {
+	m_bound[m_negative_count + i]= value;
+	value *= m_base;
+      }
+    }
+  }
+private:
+  uint      m_base;
+  uint      m_negative_count;
+  uint      m_positive_count;
+  uint      m_bound_count;
+  ulonglong m_max_dec_value; /* for TIME_STRING_POSITIVE_POWER_LENGTH=7 is 10000000 */
+  ulonglong m_bound[OVERALL_POWER_COUNT];
+};
+
+void print_time(char* buffer, std::size_t buffer_size, std::size_t string_positive_power_length, const char* format, uint64 value)
+{
+  memset(buffer,'X',buffer_size);
+  buffer[string_positive_power_length]= '.';
+  ulonglong second=      (value / MILLION);
+  ulonglong microsecond= (value % MILLION);
+  int result_length= snprintf(buffer, buffer_size, format, second, microsecond);
+  if(result_length < 0)
+  {
+    assert(sizeof(STRING_OVERFLOW) <= buffer_size);
+    memcpy(buffer, STRING_OVERFLOW, sizeof(STRING_OVERFLOW));
+    return;
+  }
+  buffer[result_length]= 0;
+}
+#ifdef __x86_64__
+typedef uint64 TimeCounter;
+void add_time_atomic(TimeCounter* counter, uint64 time)
+{
+  __sync_fetch_and_add(counter,time);  
+}
+#endif // __x86_64__
+#ifdef __i386__
+inline uint32 get_high(uint64 value)
+{
+  return ((value >> 32) << 32);
+}
+inline uint32 get_low(uint64 value)
+{
+  return ((value << 32) >> 32);
+}
+#ifdef __FreeBSD__
+inline bool compare_and_swap(volatile uint32 *target, uint32 old, uint32 new_value)
+{
+  return atomic_cmpset_32(target,old,new_value);
+}
+#else // __FreeBSD__
+inline bool compare_and_swap(volatile uint32* target, uint32 old, uint32 new_value)
+{
+  return __sync_bool_compare_and_swap(target,old,new_value);
+}
+#endif // __FreeBSD__
+class TimeCounter
+{
+public:
+  TimeCounter& operator=(uint64 time)
+  {
+    this->m_high= get_high(time);
+    this->m_low=  get_low(time);
+    return *this;
+  }
+  operator uint64() const
+  {
+    return ((static_cast<uint64>(m_high) << 32) + static_cast<uint64>(m_low));
+  }
+  void add(uint64 time)
+  {
+    uint32 time_high = get_high(time);
+    uint32 time_low  = get_low(time);
+    uint64 time_low64= time_low;
+    while(true)
+    {
+      uint32 old_low= this->m_low;
+      uint64 old_low64= old_low;
+
+      uint64 new_low64= old_low64 + time_low64;
+      uint32 new_low= (get_low(new_low64));
+      bool add_high= (get_high(new_low64) != 0);
+
+      if(!compare_and_swap(&m_low,old_low,new_low))
+      {
+	continue;
+      }
+      if(add_high)
+      {
+	++time_high;
+      }
+      if(time_high > 0)
+      {
+        __sync_fetch_and_add(&m_high,time_high);
+      }
+      break;
+    }
+  }
+private:
+  uint32 m_low;
+  uint32 m_high;
+};
+void add_time_atomic(TimeCounter* counter, uint64 time)
+{
+  counter->add(time);
+}
+#endif // __i386__
+
+class time_collector
+{
+public:
+  time_collector(utility& u) : m_utility(&u)
+  {
+  }
+  uint32 count(uint index) const { return m_count[index]; }
+  uint64 total(uint index) const { return m_total[index]; }
+public:
+  void flush()
+  {
+    memset(&m_count,0,sizeof(m_count));
+    memset((void*)&m_total,0,sizeof(m_total));
+  }
+  void collect(uint64 time)
+  {
+    bool no_collect= false;
+    DBUG_EXECUTE_IF("response_time_distribution_log_only_more_300_milliseconds", {   \
+        no_collect= time < 300 * 1000; \
+      });
+    if(no_collect) return;
+    int i= 0;
+    for(int count= m_utility->bound_count(); count > i; ++i)
+    {
+      if(m_utility->bound(i) > time)
+      {
+        __sync_fetch_and_add(&(m_count[i]),(uint32)1);
+	 add_time_atomic(&(m_total[i]),time);
+        break;
+      }
+    }
+  }
+private:
+  utility* m_utility;
+  uint32   m_count[OVERALL_POWER_COUNT + 1];
+  TimeCounter m_total[OVERALL_POWER_COUNT + 1];
+};
+
+class collector
+{
+public:
+  collector() : m_time(m_utility)
+  {
+    m_utility.setup(DEFAULT_BASE);
+    m_time.flush();
+  }
+public:
+  void flush()
+  {
+    m_utility.setup(opt_query_response_time_range_base);
+    m_time.flush();
+  }
+  int fill(THD* thd, TABLE_LIST *tables, COND *cond)
+  {
+    DBUG_ENTER("fill_schema_query_response_time");
+    TABLE        *table= static_cast<TABLE*>(tables->table);
+    Field        **fields= table->field;
+    for(uint i= 0, count= bound_count() + 1 /* with overflow */; count > i; ++i)
+    {
+      char time[TIME_STRING_BUFFER_LENGTH];
+      char total[TOTAL_STRING_BUFFER_LENGTH];
+      if(i == bound_count())
+      {        
+        assert(sizeof(TIME_OVERFLOW) <= TIME_STRING_BUFFER_LENGTH);
+        assert(sizeof(TIME_OVERFLOW) <= TOTAL_STRING_BUFFER_LENGTH);
+        memcpy(time,TIME_OVERFLOW,sizeof(TIME_OVERFLOW));
+        memcpy(total,TIME_OVERFLOW,sizeof(TIME_OVERFLOW));
+      }
+      else
+      {
+        print_time(time,sizeof(time),TIME_STRING_POSITIVE_POWER_LENGTH,TIME_STRING_FORMAT,this->bound(i));
+        print_time(total,sizeof(total),TOTAL_STRING_POSITIVE_POWER_LENGTH,TOTAL_STRING_FORMAT,this->total(i));
+      }
+      fields[0]->store(time,strlen(time),system_charset_info);
+      fields[1]->store(this->count(i));
+      fields[2]->store(total,strlen(total),system_charset_info);
+      if (schema_table_store_record(thd, table))
+      {
+	DBUG_RETURN(1);
+      }
+    }
+    DBUG_RETURN(0);
+  }
+  void collect(ulonglong time)
+  {
+    m_time.collect(time);
+  }
+  uint bound_count() const
+  {
+    return m_utility.bound_count();
+  }
+  ulonglong bound(uint index)
+  {
+    return m_utility.bound(index);
+  }
+  ulonglong count(uint index)
+  {
+    return m_time.count(index);
+  }
+  ulonglong total(uint index)
+  {
+    return m_time.total(index);
+  }
+private:
+  utility          m_utility;
+  time_collector   m_time;
+};
+
+static collector g_collector;
+
+} // namespace query_response_time
+
+void query_response_time_init()
+{
+}
+
+void query_response_time_free()
+{
+  query_response_time::g_collector.flush();
+}
+
+void query_response_time_flush()
+{
+  query_response_time::g_collector.flush();
+}
+void query_response_time_collect(ulonglong query_time)
+{
+  query_response_time::g_collector.collect(query_time);
+}
+
+int query_response_time_fill(THD* thd, TABLE_LIST *tables, COND *cond)
+{
+  return query_response_time::g_collector.fill(thd,tables,cond);
+}
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
diff -ruN a/sql/query_response_time.h b/sql/query_response_time.h
--- a/sql/query_response_time.h	1970-01-01 00:00:00.000000000 +0000
+++ b/sql/query_response_time.h	2010-11-01 08:52:40.000000000 +0000
@@ -0,0 +1,71 @@
+#ifndef QUERY_RESPONSE_TIME_H
+#define QUERY_RESPONSE_TIME_H
+
+/*
+  Settings for query response time
+*/
+
+/*
+  Maximum string length for (10 ^ (-1 * QRT_STRING_NEGATIVE_POWER_LENGTH)) in text representation.
+  Example: for 6 is 0.000001
+  Always 2
+
+  Maximum string length for (10 ^ (QRT_STRING_POSITIVE_POWER_LENGTH + 1) - 1) in text representation.
+  Example: for 7 is 9999999.0
+*/
+#define QRT_TIME_STRING_POSITIVE_POWER_LENGTH 7
+#define QRT_TOTAL_STRING_POSITIVE_POWER_LENGTH 7
+
+/*
+  Minimum base for log - ALWAYS 2
+  Maximum base for log:
+*/
+#define QRT_MAXIMUM_BASE 1000
+
+/*
+  Filler for whole number (positive power)
+  Example: for
+  QRT_POSITIVE_POWER_FILLER ' '
+  QRT_POSITIVE_POWER_LENGTH 7
+  and number 7234 result is:
+  '   7234'
+*/
+#define QRT_POSITIVE_POWER_FILLER " "
+/*
+  Filler for fractional number. Similiary to whole number
+*/
+#define QRT_NEGATIVE_POWER_FILLER "0"
+
+/*
+  Message if string overflow (string overflow - internal error, this string say about bug in QRT)
+*/
+#define QRT_STRING_OVERFLOW "TOO BIG STRING"
+
+/*
+  Message if time too big for statistic collecting (very long query)
+*/
+#define QRT_TIME_OVERFLOW "TOO LONG"
+
+#define QRT_DEFAULT_BASE 10
+
+#define QRT_TIME_STRING_LENGTH				\
+  max( (QRT_TIME_STRING_POSITIVE_POWER_LENGTH + 1 /* '.' */ + 6 /*QRT_TIME_STRING_NEGATIVE_POWER_LENGTH*/), \
+       max( (sizeof(QRT_TIME_OVERFLOW) - 1),		\
+	    (sizeof(QRT_STRING_OVERFLOW) - 1) ) )
+
+#define QRT_TOTAL_STRING_LENGTH				\
+  max( (QRT_TOTAL_STRING_POSITIVE_POWER_LENGTH + 1 /* '.' */ + 6 /*QRT_TOTAL_STRING_NEGATIVE_POWER_LENGTH*/), \
+       max( (sizeof(QRT_TIME_OVERFLOW) - 1),		\
+	    (sizeof(QRT_STRING_OVERFLOW) - 1) ) )
+
+extern ST_SCHEMA_TABLE query_response_time_table;
+
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+extern void query_response_time_init   ();
+extern void query_response_time_free   ();
+extern void query_response_time_flush  ();
+extern void query_response_time_collect(ulonglong query_time);
+extern int  query_response_time_fill   (THD* thd, TABLE_LIST *tables, COND *cond);
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
+
+#endif // QUERY_RESPONSE_TIME_H
diff -ruN a/sql/set_var.cc b/sql/set_var.cc
--- a/sql/set_var.cc	2010-11-01 08:43:57.000000000 +0000
+++ b/sql/set_var.cc	2010-11-01 08:52:40.000000000 +0000
@@ -1007,6 +1007,14 @@
 static sys_var_use_global_long_query_time sys_use_global_long_query_time;
 static sys_var_bool_ptr       sys_slow_query_log_microseconds_timestamp(&vars, "slow_query_log_microseconds_timestamp",
                                                        &opt_slow_query_log_microseconds_timestamp);
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+static sys_var_bool_ptr       sys_enable_query_response_time_stats(&vars, "enable_query_response_time_stats",
+                                                       &opt_enable_query_response_time_stats);
+static sys_var_long_ptr       sys_query_response_time_range_base(&vars, "query_response_time_range_base",
+					               &opt_query_response_time_range_base);
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
+static sys_var_have_variable sys_have_response_time_distribution(&vars, "have_response_time_distribution",
+                                                       &have_response_time_distribution);
 /* Synonym of "slow_query_log" for consistency with SHOW VARIABLES output */
 static sys_var_log_state sys_var_log_slow(&vars, "log_slow_queries",
                                           &opt_slow_log, QUERY_LOG_SLOW);
diff -ruN a/sql/sql_parse.cc b/sql/sql_parse.cc
--- a/sql/sql_parse.cc	2010-11-01 08:43:57.000000000 +0000
+++ b/sql/sql_parse.cc	2010-11-01 08:52:40.000000000 +0000
@@ -28,6 +28,7 @@
 #include "events.h"
 #include "sql_trigger.h"
 #include "debug_sync.h"
+#include "query_response_time.h"
 
 /**
   @defgroup Runtime_Environment Runtime Environment
@@ -1750,23 +1751,37 @@
     Do not log administrative statements unless the appropriate option is
     set.
   */
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+  if (opt_enable_query_response_time_stats || thd->enable_slow_log)
+#else /* HAVE_RESPONSE_TIME_DISTRIBUTION */
   if (thd->enable_slow_log)
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
   {
-    ulonglong end_utime_of_query= thd->current_utime();
-    thd_proc_info(thd, "logging slow query");
-
-    if (((end_utime_of_query - thd->utime_after_lock) >
-         thd->variables.long_query_time ||
-         ((thd->server_status &
-           (SERVER_QUERY_NO_INDEX_USED | SERVER_QUERY_NO_GOOD_INDEX_USED)) &&
-          opt_log_queries_not_using_indexes &&
-           !(sql_command_flags[thd->lex->sql_command] & CF_STATUS_COMMAND))) &&
-        thd->examined_row_count >= thd->variables.min_examined_row_limit)
+    ulonglong end_utime_of_query   = thd->current_utime();
+    ulonglong query_execution_time = end_utime_of_query - thd->utime_after_lock;
+    #ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+    if(opt_enable_query_response_time_stats)
+    {
+      query_response_time_collect(query_execution_time);
+    }
+    #endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
+    if (thd->enable_slow_log)
     {
       thd_proc_info(thd, "logging slow query");
-      thd->status_var.long_query_count++;
-      slow_log_print(thd, thd->query(), thd->query_length(), 
-                     end_utime_of_query);
+
+      if ((query_execution_time >
+           thd->variables.long_query_time ||
+           ((thd->server_status &
+             (SERVER_QUERY_NO_INDEX_USED | SERVER_QUERY_NO_GOOD_INDEX_USED)) &&
+            opt_log_queries_not_using_indexes &&
+             !(sql_command_flags[thd->lex->sql_command] & CF_STATUS_COMMAND))) &&
+          thd->examined_row_count >= thd->variables.min_examined_row_limit)
+      {
+        thd_proc_info(thd, "logging slow query");
+        thd->status_var.long_query_count++;
+        slow_log_print(thd, thd->query(), thd->query_length(), 
+                       end_utime_of_query);
+      }
     }
   }
   DBUG_VOID_RETURN;
@@ -1891,6 +1906,7 @@
   case SCH_CHARSETS:
   case SCH_ENGINES:
   case SCH_COLLATIONS:
+  case SCH_QUERY_RESPONSE_TIME:
   case SCH_COLLATION_CHARACTER_SET_APPLICABILITY:
   case SCH_USER_PRIVILEGES:
   case SCH_SCHEMA_PRIVILEGES:
@@ -7251,6 +7267,12 @@
     init_global_index_stats();
     pthread_mutex_unlock(&LOCK_global_index_stats);
   }
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+  if (options & REFRESH_QUERY_RESPONSE_TIME)
+  {
+    query_response_time_flush();
+  }
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
   if (options & (REFRESH_USER_STATS | REFRESH_CLIENT_STATS | REFRESH_THREAD_STATS))
   {
     pthread_mutex_lock(&LOCK_global_user_client_stats);
diff -ruN a/sql/sql_show.cc b/sql/sql_show.cc
--- a/sql/sql_show.cc	2010-11-01 08:43:53.000000000 +0000
+++ b/sql/sql_show.cc	2010-11-01 08:52:40.000000000 +0000
@@ -31,6 +31,7 @@
 #include "event_data_objects.h"
 #endif
 #include <my_dir.h>
+#include "query_response_time.h"
 #include "debug_sync.h"
 
 #define STR_OR_NIL(S) ((S) ? (S) : "<nil>")
@@ -7488,6 +7489,13 @@
 
 */
 
+ST_FIELD_INFO query_response_time_fields_info[] =
+  {
+    {"time",  QRT_TIME_STRING_LENGTH,      MYSQL_TYPE_STRING,  0, 0,            "", SKIP_OPEN_TABLE },
+    {"count", MY_INT32_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONG, 0, MY_I_S_UNSIGNED, "", SKIP_OPEN_TABLE },
+    {"total",  QRT_TIME_STRING_LENGTH,     MYSQL_TYPE_STRING,  0, 0,            "", SKIP_OPEN_TABLE },
+    {0,       0,                           MYSQL_TYPE_STRING,  0, 0,             0, SKIP_OPEN_TABLE }
+  };
 ST_SCHEMA_TABLE schema_tables[]=
 {
   {"CHARACTER_SETS", charsets_fields_info, create_schema_table, 
@@ -7542,6 +7550,13 @@
    1, 9, 0, OPEN_TABLE_ONLY},
   {"ROUTINES", proc_fields_info, create_schema_table, 
    fill_schema_proc, make_proc_old_format, 0, -1, -1, 0, 0},
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+  {"QUERY_RESPONSE_TIME", query_response_time_fields_info, create_schema_table, 
+   query_response_time_fill, make_old_format, 0, -1, -1, 0, 0},
+#else /* HAVE_RESPONSE_TIME_DISTRIBUTION */
+  {"QUERY_RESPONSE_TIME", query_response_time_fields_info, create_schema_table, 
+   0, make_old_format, 0, -1, -1, 0, 0},
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
   {"SCHEMATA", schema_fields_info, create_schema_table,
    fill_schema_schemata, make_schemata_old_format, 0, 1, -1, 0, 0},
   {"SCHEMA_PRIVILEGES", schema_privileges_fields_info, create_schema_table,
diff -ruN a/sql/sql_yacc.yy b/sql/sql_yacc.yy
--- a/sql/sql_yacc.yy	2010-11-01 08:43:53.000000000 +0000
+++ b/sql/sql_yacc.yy	2010-11-01 08:52:40.000000000 +0000
@@ -1079,6 +1079,7 @@
 %token  PURGE
 %token  QUARTER_SYM
 %token  QUERY_SYM
+%token  QUERY_RESPONSE_TIME_SYM
 %token  QUICK
 %token  RANGE_SYM                     /* SQL-2003-R */
 %token  READS_SYM                     /* SQL-2003-R */
@@ -10396,6 +10397,15 @@
            if (prepare_schema_table(YYTHD, lex, 0, SCH_INDEX_STATS))
              MYSQL_YYABORT;
           }
+        | QUERY_RESPONSE_TIME_SYM wild_and_where
+	  {
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+           LEX *lex= Lex;
+           lex->sql_command= SQLCOM_SELECT;
+           if (prepare_schema_table(YYTHD, lex, 0, SCH_QUERY_RESPONSE_TIME))
+             MYSQL_YYABORT;	  
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
+	  }
         | CREATE PROCEDURE sp_name
           {
             LEX *lex= Lex;
@@ -10616,6 +10626,12 @@
           { Lex->type|= REFRESH_TABLE_STATS; }
         | INDEX_STATS_SYM
           { Lex->type|= REFRESH_INDEX_STATS; }
+        | QUERY_RESPONSE_TIME_SYM
+          { 
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+            Lex->type|= REFRESH_QUERY_RESPONSE_TIME; 
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
+          }
         | MASTER_SYM
           { Lex->type|= REFRESH_MASTER; }
         | DES_KEY_FILE
@@ -11895,6 +11911,7 @@
         | PROFILES_SYM             {}
         | QUARTER_SYM              {}
         | QUERY_SYM                {}
+        | QUERY_RESPONSE_TIME_SYM  {}
         | QUICK                    {}
         | READ_ONLY_SYM            {}
         | REBUILD_SYM              {}
diff -ruN a/sql/table.h b/sql/table.h
--- a/sql/table.h	2010-11-01 08:43:53.000000000 +0000
+++ b/sql/table.h	2010-11-01 08:52:40.000000000 +0000
@@ -964,6 +964,7 @@
   SCH_PROFILES,
   SCH_REFERENTIAL_CONSTRAINTS,
   SCH_PROCEDURES,
+  SCH_QUERY_RESPONSE_TIME,
   SCH_SCHEMATA,
   SCH_SCHEMA_PRIVILEGES,
   SCH_SESSION_STATUS,
diff -ruN a/configure.in b/configure.in
--- a/configure.in	2010-12-07 19:19:42.000000000 +0300
+++ b/configure.in	2010-12-07 19:21:39.000000000 +0300
@@ -2678,7 +2678,16 @@
 AC_SUBST(readline_link)
 AC_SUBST(readline_h_ln_cmd)
 
+AC_ARG_WITH(response_time_distribution,
+    AC_HELP_STRING([--without-response_time_distribution],[Disable response_time_distribution feature.]),
+    [with_response_time_distribution=$withval],
+    [with_response_time_distribution=yes]
+)
 
+if test "$with_response_time_distribution" = "yes"
+then
+  AC_DEFINE([HAVE_RESPONSE_TIME_DISTRIBUTION], [1], [If we want to have response_time_distribution])
+fi
 
 # Include man pages, if desired, adapted to the configured parts.
 if test X"$with_man" = Xyes
