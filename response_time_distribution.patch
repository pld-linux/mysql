# name       : response-time-distribution.patch
# introduced : 12
# maintainer : Oleg
#
#!!! notice !!!
# Any small change to this file in the main branch
# should be done or reviewed by the maintainer!
--- a/include/mysql_com.h
+++ b/include/mysql_com.h
@@ -132,6 +132,7 @@
 #define REFRESH_QUERY_CACHE_FREE 0x20000L /* pack query cache */
 #define REFRESH_DES_KEY_FILE	0x40000L
 #define REFRESH_USER_RESOURCES	0x80000L
+#define REFRESH_QUERY_RESPONSE_TIME 0x100000L /* response time distibution */
 
 #define CLIENT_LONG_PASSWORD	1	/* new more secure passwords */
 #define CLIENT_FOUND_ROWS	2	/* Found instead of affected rows */
--- /dev/null
+++ b/mysql-test/include/have_response_time_distribution.inc
@@ -0,0 +1,4 @@
+-- require r/have_response_time_distribution.require
+disable_query_log;
+show variables like 'have_response_time_distribution';
+enable_query_log;
--- /dev/null
+++ b/mysql-test/r/have_response_time_distribution.require
@@ -0,0 +1,2 @@
+Variable_name	Value
+have_response_time_distribution	YES
--- /dev/null
+++ b/mysql-test/include/query_response_time.inc
@@ -0,0 +1,43 @@
+SET SESSION query_exec_time=0.1;
+
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+EVAL SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=$base;
+# Following two queries check works of FLUSH and 
+# respecting of "QUERY_RESPONSE_TIME_STATS" variable (see launchpad bug #855312)
+FLUSH QUERY_RESPONSE_TIME;
+SHOW QUERY_RESPONSE_TIME;
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=1;
+
+SET SESSION query_exec_time=0.31; SELECT 1;
+SET SESSION query_exec_time=0.32; SELECT 1;
+SET SESSION query_exec_time=0.33; SELECT 1;
+SET SESSION query_exec_time=0.34; SELECT 1;
+SET SESSION query_exec_time=0.35; SELECT 1;
+SET SESSION query_exec_time=0.36; SELECT 1;
+SET SESSION query_exec_time=0.37; SELECT 1;
+SET SESSION query_exec_time=0.38; SELECT 1;
+SET SESSION query_exec_time=0.39; SELECT 1;
+SET SESSION query_exec_time=0.4; SELECT 1;
+SET SESSION query_exec_time=1.1; SELECT 1;
+SET SESSION query_exec_time=1.2; SELECT 1;
+SET SESSION query_exec_time=1.3; SELECT 1;
+SET SESSION query_exec_time=1.5; SELECT 1;
+SET SESSION query_exec_time=1.4; SELECT 1;
+SET SESSION query_exec_time=0.5; SELECT 1;
+SET SESSION query_exec_time=2.1; SELECT 1;
+SET SESSION query_exec_time=2.3; SELECT 1;
+SET SESSION query_exec_time=2.5; SELECT 1;
+SET SESSION query_exec_time=3.1; SELECT 1;
+SET SESSION query_exec_time=4.1; SELECT 1;
+SET SESSION query_exec_time=5.1; SELECT 1;
+
+SET SESSION query_exec_time=0.1;
+
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+
+SHOW GLOBAL VARIABLES where Variable_name like 'QUERY_RESPONSE_TIME_RANGE_BASE';
+SHOW QUERY_RESPONSE_TIME;
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+
+SET SESSION query_exec_time=default;
--- /dev/null
+++ b/mysql-test/include/query_response_time-replication.inc
@@ -0,0 +1,58 @@
+connection master;
+
+CREATE TABLE t(id INT);
+sync_slave_with_master;
+
+connection slave;
+SET GLOBAL query_exec_time=0.1;
+--source include/restart_slave_sql.inc
+
+connection slave;
+
+SET SESSION query_exec_time=0.1;
+
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+--eval SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=$base
+FLUSH QUERY_RESPONSE_TIME;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=1;
+
+connection master;
+
+SET SESSION query_exec_time = 0.31; INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.32; INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.33; INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.34; INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.35; INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.36; INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.37; INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.38; INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.39; INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.4; INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.1; INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.2; INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.3; INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.5; INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.4; INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.5; INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 2.1; INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 2.3; INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 2.5; INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 3.1; INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 4.1; INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 5.1; INSERT INTO t VALUES(1);
+
+sync_slave_with_master;
+
+connection slave;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SHOW GLOBAL VARIABLES where Variable_name like 'QUERY_RESPONSE_TIME_RANGE_BASE';
+SHOW QUERY_RESPONSE_TIME;
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=default;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=default;
+
+connection master;
+DROP TABLE t;
+
+sync_slave_with_master;
--- /dev/null
+++ b/mysql-test/include/query_response_time-stored.inc
@@ -0,0 +1,37 @@
+SET SESSION query_exec_time=0.1;
+
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+EVAL SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=$base;
+FLUSH QUERY_RESPONSE_TIME;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=1;
+
+CALL test_f(0.31);
+CALL test_f(0.32);
+CALL test_f(0.33);
+CALL test_f(0.34);
+CALL test_f(0.35);
+CALL test_f(0.36);
+CALL test_f(0.37);
+CALL test_f(0.38);
+CALL test_f(0.39);
+CALL test_f(0.4);
+CALL test_f(1.1);
+CALL test_f(1.2);
+CALL test_f(1.3);
+CALL test_f(1.5);
+CALL test_f(1.4);
+CALL test_f(0.5);
+CALL test_f(2.1);
+CALL test_f(2.3);
+CALL test_f(2.5);
+CALL test_f(3.1);
+CALL test_f(4.1);
+CALL test_f(5.1);
+
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+
+SHOW GLOBAL VARIABLES where Variable_name like 'QUERY_RESPONSE_TIME_RANGE_BASE';
+SHOW QUERY_RESPONSE_TIME;
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+
+SET SESSION query_exec_time=default;
--- /dev/null
+++ b/mysql-test/r/percona_query_response_time-replication.result
@@ -0,0 +1,727 @@
+SET GLOBAL query_exec_time=0.1;
+include/master-slave.inc
+[connection master]
+CREATE TABLE t(id INT);
+SET GLOBAL query_exec_time=0.1;
+include/restart_slave.inc
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=1;
+Warnings:
+Warning	1292	Truncated incorrect query_response_time_range_base value: '1'
+FLUSH QUERY_RESPONSE_TIME;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=1;
+SET SESSION query_exec_time = 0.31;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.32;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.33;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.34;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.35;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.36;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.37;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.38;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.39;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.4;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.2;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.3;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.5;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.4;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.5;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 2.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 2.3;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 2.5;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 3.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 4.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 5.1;
+INSERT INTO t VALUES(1);
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SHOW GLOBAL VARIABLES where Variable_name like 'QUERY_RESPONSE_TIME_RANGE_BASE';
+Variable_name	Value
+query_response_time_range_base	2
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000001	1	      0.000000
+      0.000003	0	      0.000000
+      0.000007	0	      0.000000
+      0.000015	0	      0.000000
+      0.000030	0	      0.000000
+      0.000061	0	      0.000000
+      0.000122	0	      0.000000
+      0.000244	0	      0.000000
+      0.000488	0	      0.000000
+      0.000976	0	      0.000000
+      0.001953	0	      0.000000
+      0.003906	0	      0.000000
+      0.007812	0	      0.000000
+      0.015625	0	      0.000000
+      0.031250	0	      0.000000
+      0.062500	0	      0.000000
+      0.125000	1	      0.100000
+      0.250000	0	      0.000000
+      0.500000	10	      3.550000
+      1.000000	1	      0.500000
+      2.000000	5	      6.500000
+      4.000000	4	     10.000000
+      8.000000	2	      9.200000
+     16.000000	0	      0.000000
+     32.000000	0	      0.000000
+     64.000000	0	      0.000000
+    128.000000	0	      0.000000
+    256.000000	0	      0.000000
+    512.000000	0	      0.000000
+   1024.000000	0	      0.000000
+   2048.000000	0	      0.000000
+   4096.000000	0	      0.000000
+   8192.000000	0	      0.000000
+  16384.000000	0	      0.000000
+  32768.000000	0	      0.000000
+  65536.000000	0	      0.000000
+ 131072.000000	0	      0.000000
+ 262144.000000	0	      0.000000
+ 524288.000000	0	      0.000000
+ 1048576.00000	0	      0.000000
+ 2097152.00000	0	      0.000000
+ 4194304.00000	0	      0.000000
+ 8388608.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000001	1	      0.000000
+      0.000003	0	      0.000000
+      0.000007	0	      0.000000
+      0.000015	0	      0.000000
+      0.000030	0	      0.000000
+      0.000061	0	      0.000000
+      0.000122	0	      0.000000
+      0.000244	0	      0.000000
+      0.000488	0	      0.000000
+      0.000976	0	      0.000000
+      0.001953	0	      0.000000
+      0.003906	0	      0.000000
+      0.007812	0	      0.000000
+      0.015625	0	      0.000000
+      0.031250	0	      0.000000
+      0.062500	0	      0.000000
+      0.125000	1	      0.100000
+      0.250000	0	      0.000000
+      0.500000	10	      3.550000
+      1.000000	1	      0.500000
+      2.000000	5	      6.500000
+      4.000000	4	     10.000000
+      8.000000	2	      9.200000
+     16.000000	0	      0.000000
+     32.000000	0	      0.000000
+     64.000000	0	      0.000000
+    128.000000	0	      0.000000
+    256.000000	0	      0.000000
+    512.000000	0	      0.000000
+   1024.000000	0	      0.000000
+   2048.000000	0	      0.000000
+   4096.000000	0	      0.000000
+   8192.000000	0	      0.000000
+  16384.000000	0	      0.000000
+  32768.000000	0	      0.000000
+  65536.000000	0	      0.000000
+ 131072.000000	0	      0.000000
+ 262144.000000	0	      0.000000
+ 524288.000000	0	      0.000000
+ 1048576.00000	0	      0.000000
+ 2097152.00000	0	      0.000000
+ 4194304.00000	0	      0.000000
+ 8388608.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=default;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=default;
+DROP TABLE t;
+CREATE TABLE t(id INT);
+SET GLOBAL query_exec_time=0.1;
+include/restart_slave.inc
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=2;
+FLUSH QUERY_RESPONSE_TIME;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=1;
+SET SESSION query_exec_time = 0.31;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.32;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.33;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.34;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.35;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.36;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.37;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.38;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.39;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.4;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.2;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.3;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.5;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.4;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.5;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 2.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 2.3;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 2.5;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 3.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 4.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 5.1;
+INSERT INTO t VALUES(1);
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SHOW GLOBAL VARIABLES where Variable_name like 'QUERY_RESPONSE_TIME_RANGE_BASE';
+Variable_name	Value
+query_response_time_range_base	2
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000001	1	      0.000000
+      0.000003	0	      0.000000
+      0.000007	0	      0.000000
+      0.000015	0	      0.000000
+      0.000030	0	      0.000000
+      0.000061	0	      0.000000
+      0.000122	0	      0.000000
+      0.000244	0	      0.000000
+      0.000488	0	      0.000000
+      0.000976	0	      0.000000
+      0.001953	0	      0.000000
+      0.003906	0	      0.000000
+      0.007812	0	      0.000000
+      0.015625	0	      0.000000
+      0.031250	0	      0.000000
+      0.062500	0	      0.000000
+      0.125000	1	      0.100000
+      0.250000	0	      0.000000
+      0.500000	10	      3.550000
+      1.000000	1	      0.500000
+      2.000000	5	      6.500000
+      4.000000	4	     10.000000
+      8.000000	2	      9.200000
+     16.000000	0	      0.000000
+     32.000000	0	      0.000000
+     64.000000	0	      0.000000
+    128.000000	0	      0.000000
+    256.000000	0	      0.000000
+    512.000000	0	      0.000000
+   1024.000000	0	      0.000000
+   2048.000000	0	      0.000000
+   4096.000000	0	      0.000000
+   8192.000000	0	      0.000000
+  16384.000000	0	      0.000000
+  32768.000000	0	      0.000000
+  65536.000000	0	      0.000000
+ 131072.000000	0	      0.000000
+ 262144.000000	0	      0.000000
+ 524288.000000	0	      0.000000
+ 1048576.00000	0	      0.000000
+ 2097152.00000	0	      0.000000
+ 4194304.00000	0	      0.000000
+ 8388608.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000001	1	      0.000000
+      0.000003	0	      0.000000
+      0.000007	0	      0.000000
+      0.000015	0	      0.000000
+      0.000030	0	      0.000000
+      0.000061	0	      0.000000
+      0.000122	0	      0.000000
+      0.000244	0	      0.000000
+      0.000488	0	      0.000000
+      0.000976	0	      0.000000
+      0.001953	0	      0.000000
+      0.003906	0	      0.000000
+      0.007812	0	      0.000000
+      0.015625	0	      0.000000
+      0.031250	0	      0.000000
+      0.062500	0	      0.000000
+      0.125000	1	      0.100000
+      0.250000	0	      0.000000
+      0.500000	10	      3.550000
+      1.000000	1	      0.500000
+      2.000000	5	      6.500000
+      4.000000	4	     10.000000
+      8.000000	2	      9.200000
+     16.000000	0	      0.000000
+     32.000000	0	      0.000000
+     64.000000	0	      0.000000
+    128.000000	0	      0.000000
+    256.000000	0	      0.000000
+    512.000000	0	      0.000000
+   1024.000000	0	      0.000000
+   2048.000000	0	      0.000000
+   4096.000000	0	      0.000000
+   8192.000000	0	      0.000000
+  16384.000000	0	      0.000000
+  32768.000000	0	      0.000000
+  65536.000000	0	      0.000000
+ 131072.000000	0	      0.000000
+ 262144.000000	0	      0.000000
+ 524288.000000	0	      0.000000
+ 1048576.00000	0	      0.000000
+ 2097152.00000	0	      0.000000
+ 4194304.00000	0	      0.000000
+ 8388608.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=default;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=default;
+DROP TABLE t;
+CREATE TABLE t(id INT);
+SET GLOBAL query_exec_time=0.1;
+include/restart_slave.inc
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=10;
+FLUSH QUERY_RESPONSE_TIME;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=1;
+SET SESSION query_exec_time = 0.31;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.32;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.33;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.34;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.35;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.36;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.37;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.38;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.39;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.4;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.2;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.3;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.5;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.4;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.5;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 2.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 2.3;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 2.5;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 3.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 4.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 5.1;
+INSERT INTO t VALUES(1);
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SHOW GLOBAL VARIABLES where Variable_name like 'QUERY_RESPONSE_TIME_RANGE_BASE';
+Variable_name	Value
+query_response_time_range_base	10
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000001	1	      0.000000
+      0.000010	0	      0.000000
+      0.000100	0	      0.000000
+      0.001000	0	      0.000000
+      0.010000	0	      0.000000
+      0.100000	0	      0.000000
+      1.000000	12	      4.150000
+     10.000000	11	     25.700000
+    100.000000	0	      0.000000
+   1000.000000	0	      0.000000
+  10000.000000	0	      0.000000
+ 100000.000000	0	      0.000000
+ 1000000.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000001	1	      0.000000
+      0.000010	0	      0.000000
+      0.000100	0	      0.000000
+      0.001000	0	      0.000000
+      0.010000	0	      0.000000
+      0.100000	0	      0.000000
+      1.000000	12	      4.150000
+     10.000000	11	     25.700000
+    100.000000	0	      0.000000
+   1000.000000	0	      0.000000
+  10000.000000	0	      0.000000
+ 100000.000000	0	      0.000000
+ 1000000.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=default;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=default;
+DROP TABLE t;
+CREATE TABLE t(id INT);
+SET GLOBAL query_exec_time=0.1;
+include/restart_slave.inc
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=7;
+FLUSH QUERY_RESPONSE_TIME;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=1;
+SET SESSION query_exec_time = 0.31;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.32;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.33;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.34;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.35;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.36;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.37;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.38;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.39;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.4;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.2;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.3;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.5;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.4;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.5;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 2.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 2.3;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 2.5;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 3.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 4.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 5.1;
+INSERT INTO t VALUES(1);
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SHOW GLOBAL VARIABLES where Variable_name like 'QUERY_RESPONSE_TIME_RANGE_BASE';
+Variable_name	Value
+query_response_time_range_base	7
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000001	1	      0.000000
+      0.000008	0	      0.000000
+      0.000059	0	      0.000000
+      0.000416	0	      0.000000
+      0.002915	0	      0.000000
+      0.020408	0	      0.000000
+      0.142857	1	      0.100000
+      1.000000	11	      4.050000
+      7.000000	11	     25.700000
+     49.000000	0	      0.000000
+    343.000000	0	      0.000000
+   2401.000000	0	      0.000000
+  16807.000000	0	      0.000000
+ 117649.000000	0	      0.000000
+ 823543.000000	0	      0.000000
+ 5764801.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000001	1	      0.000000
+      0.000008	0	      0.000000
+      0.000059	0	      0.000000
+      0.000416	0	      0.000000
+      0.002915	0	      0.000000
+      0.020408	0	      0.000000
+      0.142857	1	      0.100000
+      1.000000	11	      4.050000
+      7.000000	11	     25.700000
+     49.000000	0	      0.000000
+    343.000000	0	      0.000000
+   2401.000000	0	      0.000000
+  16807.000000	0	      0.000000
+ 117649.000000	0	      0.000000
+ 823543.000000	0	      0.000000
+ 5764801.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=default;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=default;
+DROP TABLE t;
+CREATE TABLE t(id INT);
+SET GLOBAL query_exec_time=0.1;
+include/restart_slave.inc
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=156;
+FLUSH QUERY_RESPONSE_TIME;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=1;
+SET SESSION query_exec_time = 0.31;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.32;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.33;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.34;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.35;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.36;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.37;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.38;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.39;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.4;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.2;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.3;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.5;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.4;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.5;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 2.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 2.3;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 2.5;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 3.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 4.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 5.1;
+INSERT INTO t VALUES(1);
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SHOW GLOBAL VARIABLES where Variable_name like 'QUERY_RESPONSE_TIME_RANGE_BASE';
+Variable_name	Value
+query_response_time_range_base	156
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000041	1	      0.000000
+      0.006410	0	      0.000000
+      1.000000	12	      4.150000
+    156.000000	11	     25.700000
+  24336.000000	0	      0.000000
+ 3796416.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000041	1	      0.000000
+      0.006410	0	      0.000000
+      1.000000	12	      4.150000
+    156.000000	11	     25.700000
+  24336.000000	0	      0.000000
+ 3796416.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=default;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=default;
+DROP TABLE t;
+CREATE TABLE t(id INT);
+SET GLOBAL query_exec_time=0.1;
+include/restart_slave.inc
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=1000;
+FLUSH QUERY_RESPONSE_TIME;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=1;
+SET SESSION query_exec_time = 0.31;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.32;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.33;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.34;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.35;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.36;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.37;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.38;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.39;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.4;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.2;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.3;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.5;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.4;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.5;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 2.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 2.3;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 2.5;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 3.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 4.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 5.1;
+INSERT INTO t VALUES(1);
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SHOW GLOBAL VARIABLES where Variable_name like 'QUERY_RESPONSE_TIME_RANGE_BASE';
+Variable_name	Value
+query_response_time_range_base	1000
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000001	1	      0.000000
+      0.001000	0	      0.000000
+      1.000000	12	      4.150000
+   1000.000000	11	     25.700000
+ 1000000.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000001	1	      0.000000
+      0.001000	0	      0.000000
+      1.000000	12	      4.150000
+   1000.000000	11	     25.700000
+ 1000000.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=default;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=default;
+DROP TABLE t;
+CREATE TABLE t(id INT);
+SET GLOBAL query_exec_time=0.1;
+include/restart_slave.inc
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=1001;
+Warnings:
+Warning	1292	Truncated incorrect query_response_time_range_base value: '1001'
+FLUSH QUERY_RESPONSE_TIME;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=1;
+SET SESSION query_exec_time = 0.31;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.32;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.33;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.34;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.35;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.36;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.37;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.38;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.39;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.4;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.2;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.3;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.5;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 1.4;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 0.5;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 2.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 2.3;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 2.5;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 3.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 4.1;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time = 5.1;
+INSERT INTO t VALUES(1);
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SHOW GLOBAL VARIABLES where Variable_name like 'QUERY_RESPONSE_TIME_RANGE_BASE';
+Variable_name	Value
+query_response_time_range_base	1000
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000001	1	      0.000000
+      0.001000	0	      0.000000
+      1.000000	12	      4.150000
+   1000.000000	11	     25.700000
+ 1000000.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000001	1	      0.000000
+      0.001000	0	      0.000000
+      1.000000	12	      4.150000
+   1000.000000	11	     25.700000
+ 1000000.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=default;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=default;
+DROP TABLE t;
+include/rpl_end.inc
+SET GLOBAL query_exec_time=default;
+SET GLOBAL query_exec_time=default;
--- /dev/null
+++ b/mysql-test/r/percona_query_response_time.result
@@ -0,0 +1,1307 @@
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=1;
+Warnings:
+Warning	1292	Truncated incorrect query_response_time_range_base value: '1'
+FLUSH QUERY_RESPONSE_TIME;
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000001	0	      0.000000
+      0.000003	0	      0.000000
+      0.000007	0	      0.000000
+      0.000015	0	      0.000000
+      0.000030	0	      0.000000
+      0.000061	0	      0.000000
+      0.000122	0	      0.000000
+      0.000244	0	      0.000000
+      0.000488	0	      0.000000
+      0.000976	0	      0.000000
+      0.001953	0	      0.000000
+      0.003906	0	      0.000000
+      0.007812	0	      0.000000
+      0.015625	0	      0.000000
+      0.031250	0	      0.000000
+      0.062500	0	      0.000000
+      0.125000	0	      0.000000
+      0.250000	0	      0.000000
+      0.500000	0	      0.000000
+      1.000000	0	      0.000000
+      2.000000	0	      0.000000
+      4.000000	0	      0.000000
+      8.000000	0	      0.000000
+     16.000000	0	      0.000000
+     32.000000	0	      0.000000
+     64.000000	0	      0.000000
+    128.000000	0	      0.000000
+    256.000000	0	      0.000000
+    512.000000	0	      0.000000
+   1024.000000	0	      0.000000
+   2048.000000	0	      0.000000
+   4096.000000	0	      0.000000
+   8192.000000	0	      0.000000
+  16384.000000	0	      0.000000
+  32768.000000	0	      0.000000
+  65536.000000	0	      0.000000
+ 131072.000000	0	      0.000000
+ 262144.000000	0	      0.000000
+ 524288.000000	0	      0.000000
+ 1048576.00000	0	      0.000000
+ 2097152.00000	0	      0.000000
+ 4194304.00000	0	      0.000000
+ 8388608.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000001	0	      0.000000
+      0.000003	0	      0.000000
+      0.000007	0	      0.000000
+      0.000015	0	      0.000000
+      0.000030	0	      0.000000
+      0.000061	0	      0.000000
+      0.000122	0	      0.000000
+      0.000244	0	      0.000000
+      0.000488	0	      0.000000
+      0.000976	0	      0.000000
+      0.001953	0	      0.000000
+      0.003906	0	      0.000000
+      0.007812	0	      0.000000
+      0.015625	0	      0.000000
+      0.031250	0	      0.000000
+      0.062500	0	      0.000000
+      0.125000	0	      0.000000
+      0.250000	0	      0.000000
+      0.500000	0	      0.000000
+      1.000000	0	      0.000000
+      2.000000	0	      0.000000
+      4.000000	0	      0.000000
+      8.000000	0	      0.000000
+     16.000000	0	      0.000000
+     32.000000	0	      0.000000
+     64.000000	0	      0.000000
+    128.000000	0	      0.000000
+    256.000000	0	      0.000000
+    512.000000	0	      0.000000
+   1024.000000	0	      0.000000
+   2048.000000	0	      0.000000
+   4096.000000	0	      0.000000
+   8192.000000	0	      0.000000
+  16384.000000	0	      0.000000
+  32768.000000	0	      0.000000
+  65536.000000	0	      0.000000
+ 131072.000000	0	      0.000000
+ 262144.000000	0	      0.000000
+ 524288.000000	0	      0.000000
+ 1048576.00000	0	      0.000000
+ 2097152.00000	0	      0.000000
+ 4194304.00000	0	      0.000000
+ 8388608.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=1;
+SET SESSION query_exec_time=0.31;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.32;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.33;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.34;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.35;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.36;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.37;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.38;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.39;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.4;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.2;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.3;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.5;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.4;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.5;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=2.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=2.3;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=2.5;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=3.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=4.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=5.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SHOW GLOBAL VARIABLES where Variable_name like 'QUERY_RESPONSE_TIME_RANGE_BASE';
+Variable_name	Value
+query_response_time_range_base	2
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000001	24	      0.000000
+      0.000003	0	      0.000000
+      0.000007	0	      0.000000
+      0.000015	0	      0.000000
+      0.000030	0	      0.000000
+      0.000061	0	      0.000000
+      0.000122	0	      0.000000
+      0.000244	0	      0.000000
+      0.000488	0	      0.000000
+      0.000976	0	      0.000000
+      0.001953	0	      0.000000
+      0.003906	0	      0.000000
+      0.007812	0	      0.000000
+      0.015625	0	      0.000000
+      0.031250	0	      0.000000
+      0.062500	0	      0.000000
+      0.125000	0	      0.000000
+      0.250000	0	      0.000000
+      0.500000	10	      3.550000
+      1.000000	1	      0.500000
+      2.000000	5	      6.500000
+      4.000000	4	     10.000000
+      8.000000	2	      9.200000
+     16.000000	0	      0.000000
+     32.000000	0	      0.000000
+     64.000000	0	      0.000000
+    128.000000	0	      0.000000
+    256.000000	0	      0.000000
+    512.000000	0	      0.000000
+   1024.000000	0	      0.000000
+   2048.000000	0	      0.000000
+   4096.000000	0	      0.000000
+   8192.000000	0	      0.000000
+  16384.000000	0	      0.000000
+  32768.000000	0	      0.000000
+  65536.000000	0	      0.000000
+ 131072.000000	0	      0.000000
+ 262144.000000	0	      0.000000
+ 524288.000000	0	      0.000000
+ 1048576.00000	0	      0.000000
+ 2097152.00000	0	      0.000000
+ 4194304.00000	0	      0.000000
+ 8388608.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000001	24	      0.000000
+      0.000003	0	      0.000000
+      0.000007	0	      0.000000
+      0.000015	0	      0.000000
+      0.000030	0	      0.000000
+      0.000061	0	      0.000000
+      0.000122	0	      0.000000
+      0.000244	0	      0.000000
+      0.000488	0	      0.000000
+      0.000976	0	      0.000000
+      0.001953	0	      0.000000
+      0.003906	0	      0.000000
+      0.007812	0	      0.000000
+      0.015625	0	      0.000000
+      0.031250	0	      0.000000
+      0.062500	0	      0.000000
+      0.125000	0	      0.000000
+      0.250000	0	      0.000000
+      0.500000	10	      3.550000
+      1.000000	1	      0.500000
+      2.000000	5	      6.500000
+      4.000000	4	     10.000000
+      8.000000	2	      9.200000
+     16.000000	0	      0.000000
+     32.000000	0	      0.000000
+     64.000000	0	      0.000000
+    128.000000	0	      0.000000
+    256.000000	0	      0.000000
+    512.000000	0	      0.000000
+   1024.000000	0	      0.000000
+   2048.000000	0	      0.000000
+   4096.000000	0	      0.000000
+   8192.000000	0	      0.000000
+  16384.000000	0	      0.000000
+  32768.000000	0	      0.000000
+  65536.000000	0	      0.000000
+ 131072.000000	0	      0.000000
+ 262144.000000	0	      0.000000
+ 524288.000000	0	      0.000000
+ 1048576.00000	0	      0.000000
+ 2097152.00000	0	      0.000000
+ 4194304.00000	0	      0.000000
+ 8388608.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET SESSION query_exec_time=default;
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=2;
+FLUSH QUERY_RESPONSE_TIME;
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000001	0	      0.000000
+      0.000003	0	      0.000000
+      0.000007	0	      0.000000
+      0.000015	0	      0.000000
+      0.000030	0	      0.000000
+      0.000061	0	      0.000000
+      0.000122	0	      0.000000
+      0.000244	0	      0.000000
+      0.000488	0	      0.000000
+      0.000976	0	      0.000000
+      0.001953	0	      0.000000
+      0.003906	0	      0.000000
+      0.007812	0	      0.000000
+      0.015625	0	      0.000000
+      0.031250	0	      0.000000
+      0.062500	0	      0.000000
+      0.125000	0	      0.000000
+      0.250000	0	      0.000000
+      0.500000	0	      0.000000
+      1.000000	0	      0.000000
+      2.000000	0	      0.000000
+      4.000000	0	      0.000000
+      8.000000	0	      0.000000
+     16.000000	0	      0.000000
+     32.000000	0	      0.000000
+     64.000000	0	      0.000000
+    128.000000	0	      0.000000
+    256.000000	0	      0.000000
+    512.000000	0	      0.000000
+   1024.000000	0	      0.000000
+   2048.000000	0	      0.000000
+   4096.000000	0	      0.000000
+   8192.000000	0	      0.000000
+  16384.000000	0	      0.000000
+  32768.000000	0	      0.000000
+  65536.000000	0	      0.000000
+ 131072.000000	0	      0.000000
+ 262144.000000	0	      0.000000
+ 524288.000000	0	      0.000000
+ 1048576.00000	0	      0.000000
+ 2097152.00000	0	      0.000000
+ 4194304.00000	0	      0.000000
+ 8388608.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000001	0	      0.000000
+      0.000003	0	      0.000000
+      0.000007	0	      0.000000
+      0.000015	0	      0.000000
+      0.000030	0	      0.000000
+      0.000061	0	      0.000000
+      0.000122	0	      0.000000
+      0.000244	0	      0.000000
+      0.000488	0	      0.000000
+      0.000976	0	      0.000000
+      0.001953	0	      0.000000
+      0.003906	0	      0.000000
+      0.007812	0	      0.000000
+      0.015625	0	      0.000000
+      0.031250	0	      0.000000
+      0.062500	0	      0.000000
+      0.125000	0	      0.000000
+      0.250000	0	      0.000000
+      0.500000	0	      0.000000
+      1.000000	0	      0.000000
+      2.000000	0	      0.000000
+      4.000000	0	      0.000000
+      8.000000	0	      0.000000
+     16.000000	0	      0.000000
+     32.000000	0	      0.000000
+     64.000000	0	      0.000000
+    128.000000	0	      0.000000
+    256.000000	0	      0.000000
+    512.000000	0	      0.000000
+   1024.000000	0	      0.000000
+   2048.000000	0	      0.000000
+   4096.000000	0	      0.000000
+   8192.000000	0	      0.000000
+  16384.000000	0	      0.000000
+  32768.000000	0	      0.000000
+  65536.000000	0	      0.000000
+ 131072.000000	0	      0.000000
+ 262144.000000	0	      0.000000
+ 524288.000000	0	      0.000000
+ 1048576.00000	0	      0.000000
+ 2097152.00000	0	      0.000000
+ 4194304.00000	0	      0.000000
+ 8388608.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=1;
+SET SESSION query_exec_time=0.31;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.32;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.33;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.34;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.35;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.36;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.37;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.38;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.39;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.4;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.2;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.3;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.5;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.4;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.5;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=2.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=2.3;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=2.5;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=3.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=4.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=5.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SHOW GLOBAL VARIABLES where Variable_name like 'QUERY_RESPONSE_TIME_RANGE_BASE';
+Variable_name	Value
+query_response_time_range_base	2
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000001	24	      0.000000
+      0.000003	0	      0.000000
+      0.000007	0	      0.000000
+      0.000015	0	      0.000000
+      0.000030	0	      0.000000
+      0.000061	0	      0.000000
+      0.000122	0	      0.000000
+      0.000244	0	      0.000000
+      0.000488	0	      0.000000
+      0.000976	0	      0.000000
+      0.001953	0	      0.000000
+      0.003906	0	      0.000000
+      0.007812	0	      0.000000
+      0.015625	0	      0.000000
+      0.031250	0	      0.000000
+      0.062500	0	      0.000000
+      0.125000	0	      0.000000
+      0.250000	0	      0.000000
+      0.500000	10	      3.550000
+      1.000000	1	      0.500000
+      2.000000	5	      6.500000
+      4.000000	4	     10.000000
+      8.000000	2	      9.200000
+     16.000000	0	      0.000000
+     32.000000	0	      0.000000
+     64.000000	0	      0.000000
+    128.000000	0	      0.000000
+    256.000000	0	      0.000000
+    512.000000	0	      0.000000
+   1024.000000	0	      0.000000
+   2048.000000	0	      0.000000
+   4096.000000	0	      0.000000
+   8192.000000	0	      0.000000
+  16384.000000	0	      0.000000
+  32768.000000	0	      0.000000
+  65536.000000	0	      0.000000
+ 131072.000000	0	      0.000000
+ 262144.000000	0	      0.000000
+ 524288.000000	0	      0.000000
+ 1048576.00000	0	      0.000000
+ 2097152.00000	0	      0.000000
+ 4194304.00000	0	      0.000000
+ 8388608.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000001	24	      0.000000
+      0.000003	0	      0.000000
+      0.000007	0	      0.000000
+      0.000015	0	      0.000000
+      0.000030	0	      0.000000
+      0.000061	0	      0.000000
+      0.000122	0	      0.000000
+      0.000244	0	      0.000000
+      0.000488	0	      0.000000
+      0.000976	0	      0.000000
+      0.001953	0	      0.000000
+      0.003906	0	      0.000000
+      0.007812	0	      0.000000
+      0.015625	0	      0.000000
+      0.031250	0	      0.000000
+      0.062500	0	      0.000000
+      0.125000	0	      0.000000
+      0.250000	0	      0.000000
+      0.500000	10	      3.550000
+      1.000000	1	      0.500000
+      2.000000	5	      6.500000
+      4.000000	4	     10.000000
+      8.000000	2	      9.200000
+     16.000000	0	      0.000000
+     32.000000	0	      0.000000
+     64.000000	0	      0.000000
+    128.000000	0	      0.000000
+    256.000000	0	      0.000000
+    512.000000	0	      0.000000
+   1024.000000	0	      0.000000
+   2048.000000	0	      0.000000
+   4096.000000	0	      0.000000
+   8192.000000	0	      0.000000
+  16384.000000	0	      0.000000
+  32768.000000	0	      0.000000
+  65536.000000	0	      0.000000
+ 131072.000000	0	      0.000000
+ 262144.000000	0	      0.000000
+ 524288.000000	0	      0.000000
+ 1048576.00000	0	      0.000000
+ 2097152.00000	0	      0.000000
+ 4194304.00000	0	      0.000000
+ 8388608.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET SESSION query_exec_time=default;
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=10;
+FLUSH QUERY_RESPONSE_TIME;
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000001	0	      0.000000
+      0.000010	0	      0.000000
+      0.000100	0	      0.000000
+      0.001000	0	      0.000000
+      0.010000	0	      0.000000
+      0.100000	0	      0.000000
+      1.000000	0	      0.000000
+     10.000000	0	      0.000000
+    100.000000	0	      0.000000
+   1000.000000	0	      0.000000
+  10000.000000	0	      0.000000
+ 100000.000000	0	      0.000000
+ 1000000.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000001	0	      0.000000
+      0.000010	0	      0.000000
+      0.000100	0	      0.000000
+      0.001000	0	      0.000000
+      0.010000	0	      0.000000
+      0.100000	0	      0.000000
+      1.000000	0	      0.000000
+     10.000000	0	      0.000000
+    100.000000	0	      0.000000
+   1000.000000	0	      0.000000
+  10000.000000	0	      0.000000
+ 100000.000000	0	      0.000000
+ 1000000.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=1;
+SET SESSION query_exec_time=0.31;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.32;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.33;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.34;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.35;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.36;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.37;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.38;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.39;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.4;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.2;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.3;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.5;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.4;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.5;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=2.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=2.3;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=2.5;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=3.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=4.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=5.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SHOW GLOBAL VARIABLES where Variable_name like 'QUERY_RESPONSE_TIME_RANGE_BASE';
+Variable_name	Value
+query_response_time_range_base	10
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000001	24	      0.000000
+      0.000010	0	      0.000000
+      0.000100	0	      0.000000
+      0.001000	0	      0.000000
+      0.010000	0	      0.000000
+      0.100000	0	      0.000000
+      1.000000	11	      4.050000
+     10.000000	11	     25.700000
+    100.000000	0	      0.000000
+   1000.000000	0	      0.000000
+  10000.000000	0	      0.000000
+ 100000.000000	0	      0.000000
+ 1000000.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000001	24	      0.000000
+      0.000010	0	      0.000000
+      0.000100	0	      0.000000
+      0.001000	0	      0.000000
+      0.010000	0	      0.000000
+      0.100000	0	      0.000000
+      1.000000	11	      4.050000
+     10.000000	11	     25.700000
+    100.000000	0	      0.000000
+   1000.000000	0	      0.000000
+  10000.000000	0	      0.000000
+ 100000.000000	0	      0.000000
+ 1000000.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET SESSION query_exec_time=default;
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=7;
+FLUSH QUERY_RESPONSE_TIME;
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000001	0	      0.000000
+      0.000008	0	      0.000000
+      0.000059	0	      0.000000
+      0.000416	0	      0.000000
+      0.002915	0	      0.000000
+      0.020408	0	      0.000000
+      0.142857	0	      0.000000
+      1.000000	0	      0.000000
+      7.000000	0	      0.000000
+     49.000000	0	      0.000000
+    343.000000	0	      0.000000
+   2401.000000	0	      0.000000
+  16807.000000	0	      0.000000
+ 117649.000000	0	      0.000000
+ 823543.000000	0	      0.000000
+ 5764801.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000001	0	      0.000000
+      0.000008	0	      0.000000
+      0.000059	0	      0.000000
+      0.000416	0	      0.000000
+      0.002915	0	      0.000000
+      0.020408	0	      0.000000
+      0.142857	0	      0.000000
+      1.000000	0	      0.000000
+      7.000000	0	      0.000000
+     49.000000	0	      0.000000
+    343.000000	0	      0.000000
+   2401.000000	0	      0.000000
+  16807.000000	0	      0.000000
+ 117649.000000	0	      0.000000
+ 823543.000000	0	      0.000000
+ 5764801.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=1;
+SET SESSION query_exec_time=0.31;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.32;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.33;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.34;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.35;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.36;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.37;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.38;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.39;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.4;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.2;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.3;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.5;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.4;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.5;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=2.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=2.3;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=2.5;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=3.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=4.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=5.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SHOW GLOBAL VARIABLES where Variable_name like 'QUERY_RESPONSE_TIME_RANGE_BASE';
+Variable_name	Value
+query_response_time_range_base	7
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000001	24	      0.000000
+      0.000008	0	      0.000000
+      0.000059	0	      0.000000
+      0.000416	0	      0.000000
+      0.002915	0	      0.000000
+      0.020408	0	      0.000000
+      0.142857	0	      0.000000
+      1.000000	11	      4.050000
+      7.000000	11	     25.700000
+     49.000000	0	      0.000000
+    343.000000	0	      0.000000
+   2401.000000	0	      0.000000
+  16807.000000	0	      0.000000
+ 117649.000000	0	      0.000000
+ 823543.000000	0	      0.000000
+ 5764801.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000001	24	      0.000000
+      0.000008	0	      0.000000
+      0.000059	0	      0.000000
+      0.000416	0	      0.000000
+      0.002915	0	      0.000000
+      0.020408	0	      0.000000
+      0.142857	0	      0.000000
+      1.000000	11	      4.050000
+      7.000000	11	     25.700000
+     49.000000	0	      0.000000
+    343.000000	0	      0.000000
+   2401.000000	0	      0.000000
+  16807.000000	0	      0.000000
+ 117649.000000	0	      0.000000
+ 823543.000000	0	      0.000000
+ 5764801.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET SESSION query_exec_time=default;
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=156;
+FLUSH QUERY_RESPONSE_TIME;
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000041	0	      0.000000
+      0.006410	0	      0.000000
+      1.000000	0	      0.000000
+    156.000000	0	      0.000000
+  24336.000000	0	      0.000000
+ 3796416.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000041	0	      0.000000
+      0.006410	0	      0.000000
+      1.000000	0	      0.000000
+    156.000000	0	      0.000000
+  24336.000000	0	      0.000000
+ 3796416.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=1;
+SET SESSION query_exec_time=0.31;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.32;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.33;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.34;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.35;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.36;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.37;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.38;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.39;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.4;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.2;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.3;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.5;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.4;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.5;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=2.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=2.3;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=2.5;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=3.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=4.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=5.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SHOW GLOBAL VARIABLES where Variable_name like 'QUERY_RESPONSE_TIME_RANGE_BASE';
+Variable_name	Value
+query_response_time_range_base	156
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000041	24	      0.000000
+      0.006410	0	      0.000000
+      1.000000	11	      4.050000
+    156.000000	11	     25.700000
+  24336.000000	0	      0.000000
+ 3796416.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000041	24	      0.000000
+      0.006410	0	      0.000000
+      1.000000	11	      4.050000
+    156.000000	11	     25.700000
+  24336.000000	0	      0.000000
+ 3796416.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET SESSION query_exec_time=default;
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=1000;
+FLUSH QUERY_RESPONSE_TIME;
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000001	0	      0.000000
+      0.001000	0	      0.000000
+      1.000000	0	      0.000000
+   1000.000000	0	      0.000000
+ 1000000.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000001	0	      0.000000
+      0.001000	0	      0.000000
+      1.000000	0	      0.000000
+   1000.000000	0	      0.000000
+ 1000000.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=1;
+SET SESSION query_exec_time=0.31;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.32;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.33;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.34;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.35;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.36;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.37;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.38;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.39;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.4;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.2;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.3;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.5;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.4;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.5;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=2.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=2.3;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=2.5;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=3.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=4.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=5.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SHOW GLOBAL VARIABLES where Variable_name like 'QUERY_RESPONSE_TIME_RANGE_BASE';
+Variable_name	Value
+query_response_time_range_base	1000
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000001	24	      0.000000
+      0.001000	0	      0.000000
+      1.000000	11	      4.050000
+   1000.000000	11	     25.700000
+ 1000000.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000001	24	      0.000000
+      0.001000	0	      0.000000
+      1.000000	11	      4.050000
+   1000.000000	11	     25.700000
+ 1000000.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET SESSION query_exec_time=default;
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=1001;
+Warnings:
+Warning	1292	Truncated incorrect query_response_time_range_base value: '1001'
+FLUSH QUERY_RESPONSE_TIME;
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000001	0	      0.000000
+      0.001000	0	      0.000000
+      1.000000	0	      0.000000
+   1000.000000	0	      0.000000
+ 1000000.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000001	0	      0.000000
+      0.001000	0	      0.000000
+      1.000000	0	      0.000000
+   1000.000000	0	      0.000000
+ 1000000.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=1;
+SET SESSION query_exec_time=0.31;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.32;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.33;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.34;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.35;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.36;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.37;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.38;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.39;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.4;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.2;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.3;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.5;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=1.4;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.5;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=2.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=2.3;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=2.5;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=3.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=4.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=5.1;
+SELECT 1;
+1
+1
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SHOW GLOBAL VARIABLES where Variable_name like 'QUERY_RESPONSE_TIME_RANGE_BASE';
+Variable_name	Value
+query_response_time_range_base	1000
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000001	24	      0.000000
+      0.001000	0	      0.000000
+      1.000000	11	      4.050000
+   1000.000000	11	     25.700000
+ 1000000.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000001	24	      0.000000
+      0.001000	0	      0.000000
+      1.000000	11	      4.050000
+   1000.000000	11	     25.700000
+ 1000000.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET SESSION query_exec_time=default;
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=default;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=default;
--- /dev/null
+++ b/mysql-test/r/percona_query_response_time-stored.result
@@ -0,0 +1,544 @@
+CREATE TABLE t(a INT);
+CREATE PROCEDURE test_f(t DECIMAL(3,2))
+BEGIN
+SET SESSION query_exec_time=t;
+INSERT INTO t VALUES(1);
+SET SESSION query_exec_time=0.1;
+DELETE FROM t;
+END^
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=1;
+Warnings:
+Warning	1292	Truncated incorrect query_response_time_range_base value: '1'
+FLUSH QUERY_RESPONSE_TIME;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=1;
+CALL test_f(0.31);
+CALL test_f(0.32);
+CALL test_f(0.33);
+CALL test_f(0.34);
+CALL test_f(0.35);
+CALL test_f(0.36);
+CALL test_f(0.37);
+CALL test_f(0.38);
+CALL test_f(0.39);
+CALL test_f(0.4);
+CALL test_f(1.1);
+CALL test_f(1.2);
+CALL test_f(1.3);
+CALL test_f(1.5);
+CALL test_f(1.4);
+CALL test_f(0.5);
+CALL test_f(2.1);
+CALL test_f(2.3);
+CALL test_f(2.5);
+CALL test_f(3.1);
+CALL test_f(4.1);
+CALL test_f(5.1);
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SHOW GLOBAL VARIABLES where Variable_name like 'QUERY_RESPONSE_TIME_RANGE_BASE';
+Variable_name	Value
+query_response_time_range_base	2
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000001	45	      0.000000
+      0.000003	0	      0.000000
+      0.000007	0	      0.000000
+      0.000015	0	      0.000000
+      0.000030	0	      0.000000
+      0.000061	0	      0.000000
+      0.000122	0	      0.000000
+      0.000244	0	      0.000000
+      0.000488	0	      0.000000
+      0.000976	0	      0.000000
+      0.001953	0	      0.000000
+      0.003906	0	      0.000000
+      0.007812	0	      0.000000
+      0.015625	0	      0.000000
+      0.031250	0	      0.000000
+      0.062500	0	      0.000000
+      0.125000	44	      4.400000
+      0.250000	0	      0.000000
+      0.500000	10	      3.550000
+      1.000000	1	      0.500000
+      2.000000	5	      6.500000
+      4.000000	4	     10.000000
+      8.000000	2	      9.200000
+     16.000000	0	      0.000000
+     32.000000	0	      0.000000
+     64.000000	0	      0.000000
+    128.000000	0	      0.000000
+    256.000000	0	      0.000000
+    512.000000	0	      0.000000
+   1024.000000	0	      0.000000
+   2048.000000	0	      0.000000
+   4096.000000	0	      0.000000
+   8192.000000	0	      0.000000
+  16384.000000	0	      0.000000
+  32768.000000	0	      0.000000
+  65536.000000	0	      0.000000
+ 131072.000000	0	      0.000000
+ 262144.000000	0	      0.000000
+ 524288.000000	0	      0.000000
+ 1048576.00000	0	      0.000000
+ 2097152.00000	0	      0.000000
+ 4194304.00000	0	      0.000000
+ 8388608.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000001	45	      0.000000
+      0.000003	0	      0.000000
+      0.000007	0	      0.000000
+      0.000015	0	      0.000000
+      0.000030	0	      0.000000
+      0.000061	0	      0.000000
+      0.000122	0	      0.000000
+      0.000244	0	      0.000000
+      0.000488	0	      0.000000
+      0.000976	0	      0.000000
+      0.001953	0	      0.000000
+      0.003906	0	      0.000000
+      0.007812	0	      0.000000
+      0.015625	0	      0.000000
+      0.031250	0	      0.000000
+      0.062500	0	      0.000000
+      0.125000	44	      4.400000
+      0.250000	0	      0.000000
+      0.500000	10	      3.550000
+      1.000000	1	      0.500000
+      2.000000	5	      6.500000
+      4.000000	4	     10.000000
+      8.000000	2	      9.200000
+     16.000000	0	      0.000000
+     32.000000	0	      0.000000
+     64.000000	0	      0.000000
+    128.000000	0	      0.000000
+    256.000000	0	      0.000000
+    512.000000	0	      0.000000
+   1024.000000	0	      0.000000
+   2048.000000	0	      0.000000
+   4096.000000	0	      0.000000
+   8192.000000	0	      0.000000
+  16384.000000	0	      0.000000
+  32768.000000	0	      0.000000
+  65536.000000	0	      0.000000
+ 131072.000000	0	      0.000000
+ 262144.000000	0	      0.000000
+ 524288.000000	0	      0.000000
+ 1048576.00000	0	      0.000000
+ 2097152.00000	0	      0.000000
+ 4194304.00000	0	      0.000000
+ 8388608.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET SESSION query_exec_time=default;
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=2;
+FLUSH QUERY_RESPONSE_TIME;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=1;
+CALL test_f(0.31);
+CALL test_f(0.32);
+CALL test_f(0.33);
+CALL test_f(0.34);
+CALL test_f(0.35);
+CALL test_f(0.36);
+CALL test_f(0.37);
+CALL test_f(0.38);
+CALL test_f(0.39);
+CALL test_f(0.4);
+CALL test_f(1.1);
+CALL test_f(1.2);
+CALL test_f(1.3);
+CALL test_f(1.5);
+CALL test_f(1.4);
+CALL test_f(0.5);
+CALL test_f(2.1);
+CALL test_f(2.3);
+CALL test_f(2.5);
+CALL test_f(3.1);
+CALL test_f(4.1);
+CALL test_f(5.1);
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SHOW GLOBAL VARIABLES where Variable_name like 'QUERY_RESPONSE_TIME_RANGE_BASE';
+Variable_name	Value
+query_response_time_range_base	2
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000001	45	      0.000000
+      0.000003	0	      0.000000
+      0.000007	0	      0.000000
+      0.000015	0	      0.000000
+      0.000030	0	      0.000000
+      0.000061	0	      0.000000
+      0.000122	0	      0.000000
+      0.000244	0	      0.000000
+      0.000488	0	      0.000000
+      0.000976	0	      0.000000
+      0.001953	0	      0.000000
+      0.003906	0	      0.000000
+      0.007812	0	      0.000000
+      0.015625	0	      0.000000
+      0.031250	0	      0.000000
+      0.062500	0	      0.000000
+      0.125000	44	      4.400000
+      0.250000	0	      0.000000
+      0.500000	10	      3.550000
+      1.000000	1	      0.500000
+      2.000000	5	      6.500000
+      4.000000	4	     10.000000
+      8.000000	2	      9.200000
+     16.000000	0	      0.000000
+     32.000000	0	      0.000000
+     64.000000	0	      0.000000
+    128.000000	0	      0.000000
+    256.000000	0	      0.000000
+    512.000000	0	      0.000000
+   1024.000000	0	      0.000000
+   2048.000000	0	      0.000000
+   4096.000000	0	      0.000000
+   8192.000000	0	      0.000000
+  16384.000000	0	      0.000000
+  32768.000000	0	      0.000000
+  65536.000000	0	      0.000000
+ 131072.000000	0	      0.000000
+ 262144.000000	0	      0.000000
+ 524288.000000	0	      0.000000
+ 1048576.00000	0	      0.000000
+ 2097152.00000	0	      0.000000
+ 4194304.00000	0	      0.000000
+ 8388608.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000001	45	      0.000000
+      0.000003	0	      0.000000
+      0.000007	0	      0.000000
+      0.000015	0	      0.000000
+      0.000030	0	      0.000000
+      0.000061	0	      0.000000
+      0.000122	0	      0.000000
+      0.000244	0	      0.000000
+      0.000488	0	      0.000000
+      0.000976	0	      0.000000
+      0.001953	0	      0.000000
+      0.003906	0	      0.000000
+      0.007812	0	      0.000000
+      0.015625	0	      0.000000
+      0.031250	0	      0.000000
+      0.062500	0	      0.000000
+      0.125000	44	      4.400000
+      0.250000	0	      0.000000
+      0.500000	10	      3.550000
+      1.000000	1	      0.500000
+      2.000000	5	      6.500000
+      4.000000	4	     10.000000
+      8.000000	2	      9.200000
+     16.000000	0	      0.000000
+     32.000000	0	      0.000000
+     64.000000	0	      0.000000
+    128.000000	0	      0.000000
+    256.000000	0	      0.000000
+    512.000000	0	      0.000000
+   1024.000000	0	      0.000000
+   2048.000000	0	      0.000000
+   4096.000000	0	      0.000000
+   8192.000000	0	      0.000000
+  16384.000000	0	      0.000000
+  32768.000000	0	      0.000000
+  65536.000000	0	      0.000000
+ 131072.000000	0	      0.000000
+ 262144.000000	0	      0.000000
+ 524288.000000	0	      0.000000
+ 1048576.00000	0	      0.000000
+ 2097152.00000	0	      0.000000
+ 4194304.00000	0	      0.000000
+ 8388608.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET SESSION query_exec_time=default;
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=10;
+FLUSH QUERY_RESPONSE_TIME;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=1;
+CALL test_f(0.31);
+CALL test_f(0.32);
+CALL test_f(0.33);
+CALL test_f(0.34);
+CALL test_f(0.35);
+CALL test_f(0.36);
+CALL test_f(0.37);
+CALL test_f(0.38);
+CALL test_f(0.39);
+CALL test_f(0.4);
+CALL test_f(1.1);
+CALL test_f(1.2);
+CALL test_f(1.3);
+CALL test_f(1.5);
+CALL test_f(1.4);
+CALL test_f(0.5);
+CALL test_f(2.1);
+CALL test_f(2.3);
+CALL test_f(2.5);
+CALL test_f(3.1);
+CALL test_f(4.1);
+CALL test_f(5.1);
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SHOW GLOBAL VARIABLES where Variable_name like 'QUERY_RESPONSE_TIME_RANGE_BASE';
+Variable_name	Value
+query_response_time_range_base	10
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000001	45	      0.000000
+      0.000010	0	      0.000000
+      0.000100	0	      0.000000
+      0.001000	0	      0.000000
+      0.010000	0	      0.000000
+      0.100000	0	      0.000000
+      1.000000	55	      8.450000
+     10.000000	11	     25.700000
+    100.000000	0	      0.000000
+   1000.000000	0	      0.000000
+  10000.000000	0	      0.000000
+ 100000.000000	0	      0.000000
+ 1000000.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000001	45	      0.000000
+      0.000010	0	      0.000000
+      0.000100	0	      0.000000
+      0.001000	0	      0.000000
+      0.010000	0	      0.000000
+      0.100000	0	      0.000000
+      1.000000	55	      8.450000
+     10.000000	11	     25.700000
+    100.000000	0	      0.000000
+   1000.000000	0	      0.000000
+  10000.000000	0	      0.000000
+ 100000.000000	0	      0.000000
+ 1000000.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET SESSION query_exec_time=default;
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=7;
+FLUSH QUERY_RESPONSE_TIME;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=1;
+CALL test_f(0.31);
+CALL test_f(0.32);
+CALL test_f(0.33);
+CALL test_f(0.34);
+CALL test_f(0.35);
+CALL test_f(0.36);
+CALL test_f(0.37);
+CALL test_f(0.38);
+CALL test_f(0.39);
+CALL test_f(0.4);
+CALL test_f(1.1);
+CALL test_f(1.2);
+CALL test_f(1.3);
+CALL test_f(1.5);
+CALL test_f(1.4);
+CALL test_f(0.5);
+CALL test_f(2.1);
+CALL test_f(2.3);
+CALL test_f(2.5);
+CALL test_f(3.1);
+CALL test_f(4.1);
+CALL test_f(5.1);
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SHOW GLOBAL VARIABLES where Variable_name like 'QUERY_RESPONSE_TIME_RANGE_BASE';
+Variable_name	Value
+query_response_time_range_base	7
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000001	45	      0.000000
+      0.000008	0	      0.000000
+      0.000059	0	      0.000000
+      0.000416	0	      0.000000
+      0.002915	0	      0.000000
+      0.020408	0	      0.000000
+      0.142857	44	      4.400000
+      1.000000	11	      4.050000
+      7.000000	11	     25.700000
+     49.000000	0	      0.000000
+    343.000000	0	      0.000000
+   2401.000000	0	      0.000000
+  16807.000000	0	      0.000000
+ 117649.000000	0	      0.000000
+ 823543.000000	0	      0.000000
+ 5764801.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000001	45	      0.000000
+      0.000008	0	      0.000000
+      0.000059	0	      0.000000
+      0.000416	0	      0.000000
+      0.002915	0	      0.000000
+      0.020408	0	      0.000000
+      0.142857	44	      4.400000
+      1.000000	11	      4.050000
+      7.000000	11	     25.700000
+     49.000000	0	      0.000000
+    343.000000	0	      0.000000
+   2401.000000	0	      0.000000
+  16807.000000	0	      0.000000
+ 117649.000000	0	      0.000000
+ 823543.000000	0	      0.000000
+ 5764801.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET SESSION query_exec_time=default;
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=156;
+FLUSH QUERY_RESPONSE_TIME;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=1;
+CALL test_f(0.31);
+CALL test_f(0.32);
+CALL test_f(0.33);
+CALL test_f(0.34);
+CALL test_f(0.35);
+CALL test_f(0.36);
+CALL test_f(0.37);
+CALL test_f(0.38);
+CALL test_f(0.39);
+CALL test_f(0.4);
+CALL test_f(1.1);
+CALL test_f(1.2);
+CALL test_f(1.3);
+CALL test_f(1.5);
+CALL test_f(1.4);
+CALL test_f(0.5);
+CALL test_f(2.1);
+CALL test_f(2.3);
+CALL test_f(2.5);
+CALL test_f(3.1);
+CALL test_f(4.1);
+CALL test_f(5.1);
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SHOW GLOBAL VARIABLES where Variable_name like 'QUERY_RESPONSE_TIME_RANGE_BASE';
+Variable_name	Value
+query_response_time_range_base	156
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000041	45	      0.000000
+      0.006410	0	      0.000000
+      1.000000	55	      8.450000
+    156.000000	11	     25.700000
+  24336.000000	0	      0.000000
+ 3796416.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000041	45	      0.000000
+      0.006410	0	      0.000000
+      1.000000	55	      8.450000
+    156.000000	11	     25.700000
+  24336.000000	0	      0.000000
+ 3796416.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET SESSION query_exec_time=default;
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=1000;
+FLUSH QUERY_RESPONSE_TIME;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=1;
+CALL test_f(0.31);
+CALL test_f(0.32);
+CALL test_f(0.33);
+CALL test_f(0.34);
+CALL test_f(0.35);
+CALL test_f(0.36);
+CALL test_f(0.37);
+CALL test_f(0.38);
+CALL test_f(0.39);
+CALL test_f(0.4);
+CALL test_f(1.1);
+CALL test_f(1.2);
+CALL test_f(1.3);
+CALL test_f(1.5);
+CALL test_f(1.4);
+CALL test_f(0.5);
+CALL test_f(2.1);
+CALL test_f(2.3);
+CALL test_f(2.5);
+CALL test_f(3.1);
+CALL test_f(4.1);
+CALL test_f(5.1);
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SHOW GLOBAL VARIABLES where Variable_name like 'QUERY_RESPONSE_TIME_RANGE_BASE';
+Variable_name	Value
+query_response_time_range_base	1000
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000001	45	      0.000000
+      0.001000	0	      0.000000
+      1.000000	55	      8.450000
+   1000.000000	11	     25.700000
+ 1000000.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000001	45	      0.000000
+      0.001000	0	      0.000000
+      1.000000	55	      8.450000
+   1000.000000	11	     25.700000
+ 1000000.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET SESSION query_exec_time=default;
+SET SESSION query_exec_time=0.1;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=1001;
+Warnings:
+Warning	1292	Truncated incorrect query_response_time_range_base value: '1001'
+FLUSH QUERY_RESPONSE_TIME;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=1;
+CALL test_f(0.31);
+CALL test_f(0.32);
+CALL test_f(0.33);
+CALL test_f(0.34);
+CALL test_f(0.35);
+CALL test_f(0.36);
+CALL test_f(0.37);
+CALL test_f(0.38);
+CALL test_f(0.39);
+CALL test_f(0.4);
+CALL test_f(1.1);
+CALL test_f(1.2);
+CALL test_f(1.3);
+CALL test_f(1.5);
+CALL test_f(1.4);
+CALL test_f(0.5);
+CALL test_f(2.1);
+CALL test_f(2.3);
+CALL test_f(2.5);
+CALL test_f(3.1);
+CALL test_f(4.1);
+CALL test_f(5.1);
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=0;
+SHOW GLOBAL VARIABLES where Variable_name like 'QUERY_RESPONSE_TIME_RANGE_BASE';
+Variable_name	Value
+query_response_time_range_base	1000
+SHOW QUERY_RESPONSE_TIME;
+		
+      0.000001	45	      0.000000
+      0.001000	0	      0.000000
+      1.000000	55	      8.450000
+   1000.000000	11	     25.700000
+ 1000000.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SELECT * FROM INFORMATION_SCHEMA.QUERY_RESPONSE_TIME;
+time	count	total
+      0.000001	45	      0.000000
+      0.001000	0	      0.000000
+      1.000000	55	      8.450000
+   1000.000000	11	     25.700000
+ 1000000.00000	0	      0.000000
+TOO LONG	0	TOO LONG
+SET SESSION query_exec_time=default;
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=default;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=default;
+DROP PROCEDURE test_f;
+DROP TABLE t;
--- /dev/null
+++ b/mysql-test/t/percona_query_response_time-replication.test
@@ -0,0 +1,28 @@
+SET GLOBAL query_exec_time=0.1;
+
+--source include/have_response_time_distribution.inc
+--source include/have_debug.inc
+--source include/have_binlog_format_statement.inc
+--source include/master-slave.inc
+
+--let base=1
+--source include/query_response_time-replication.inc
+--let base=2
+--source include/query_response_time-replication.inc
+--let base=10
+--source include/query_response_time-replication.inc
+--let base=7
+--source include/query_response_time-replication.inc
+--let base=156
+--source include/query_response_time-replication.inc
+--let base=1000
+--source include/query_response_time-replication.inc
+--let base=1001
+--source include/query_response_time-replication.inc
+
+--source include/rpl_end.inc
+
+SET GLOBAL query_exec_time=default;
+
+connection slave;
+SET GLOBAL query_exec_time=default;
--- /dev/null
+++ b/mysql-test/t/percona_query_response_time-stored.test
@@ -0,0 +1,36 @@
+--source include/have_response_time_distribution.inc
+--source include/have_debug.inc
+
+CREATE TABLE t(a INT);
+
+delimiter ^;
+CREATE PROCEDURE test_f(t DECIMAL(3,2))
+BEGIN
+  SET SESSION query_exec_time=t;
+  INSERT INTO t VALUES(1);
+  SET SESSION query_exec_time=0.1;
+  DELETE FROM t;
+END^
+delimiter ;^
+
+--let base=1
+--source include/query_response_time-stored.inc
+--let base=2
+--source include/query_response_time-stored.inc
+--let base=10
+--source include/query_response_time-stored.inc
+--let base=7
+--source include/query_response_time-stored.inc
+--let base=156
+--source include/query_response_time-stored.inc
+--let base=1000
+--source include/query_response_time-stored.inc
+--let base=1001
+--source include/query_response_time-stored.inc
+
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=default;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=default;
+
+DROP PROCEDURE test_f;
+
+DROP TABLE t;
--- /dev/null
+++ b/mysql-test/t/percona_query_response_time.test
@@ -0,0 +1,20 @@
+--source include/have_response_time_distribution.inc
+--source include/have_debug.inc
+
+--let base=1
+--source include/query_response_time.inc
+--let base=2
+--source include/query_response_time.inc
+--let base=10
+--source include/query_response_time.inc
+--let base=7
+--source include/query_response_time.inc
+--let base=156
+--source include/query_response_time.inc
+--let base=1000
+--source include/query_response_time.inc
+--let base=1001
+--source include/query_response_time.inc
+
+SET GLOBAL QUERY_RESPONSE_TIME_RANGE_BASE=default;
+SET GLOBAL ENABLE_QUERY_RESPONSE_TIME_STATS=default;
--- /dev/null
+++ b/patch_info/response-time-distribution.info
@@ -0,0 +1,9 @@
+File=response-time-distribution.patch
+Name=Response time distribution
+Version=1.0
+Author=Percona <info@percona.com>
+License=GPL
+Comment=
+Changelog
+2010-07-02 first version avaliable
+2010-09-15 add column 'total'
--- a/sql/lex.h
+++ b/sql/lex.h
@@ -418,6 +418,7 @@
   { "PURGE",		SYM(PURGE)},
   { "QUARTER",          SYM(QUARTER_SYM)},
   { "QUERY",		SYM(QUERY_SYM)},
+  { "QUERY_RESPONSE_TIME", SYM(QUERY_RESPONSE_TIME_SYM)},
   { "QUICK",	        SYM(QUICK)},
   { "RANGE",            SYM(RANGE_SYM)},
   { "READ",		SYM(READ_SYM)},
--- a/sql/Makefile.am
+++ b/sql/Makefile.am
@@ -66,7 +66,7 @@
 			sql_repl.h slave.h rpl_filter.h rpl_injector.h \
 			log_event.h rpl_record.h \
 			log_event_old.h rpl_record_old.h \
-			sql_sort.h sql_cache.h set_var.h \
+			sql_sort.h sql_cache.h set_var.h query_response_time.h \
 			spatial.h gstream.h client_settings.h tzfile.h \
 			tztime.h my_decimal.h\
 			sp_head.h sp_pcontext.h sp_rcontext.h sp.h sp_cache.h \
@@ -89,7 +89,7 @@
 			sql_string.cc sql_manager.cc sql_map.cc \
 			mysqld.cc password.c hash_filo.cc hostname.cc \
 			sql_connect.cc scheduler.cc sql_parse.cc \
-			set_var.cc sql_yacc.yy \
+			set_var.cc query_response_time.cc sql_yacc.yy \
 			sql_base.cc table.cc sql_select.cc sql_insert.cc \
 			sql_profile.cc \
 			sql_prepare.cc sql_error.cc sql_locale.cc \
--- a/sql/mysqld.cc
+++ b/sql/mysqld.cc
@@ -33,6 +33,7 @@
 
 #include "rpl_injector.h"
 
+#include "query_response_time.h"
 #ifdef HAVE_SYS_PRCTL_H
 #include <sys/prctl.h>
 #endif
@@ -538,6 +539,10 @@
 my_bool opt_query_cache_strip_comments = 0;
 my_bool opt_use_global_long_query_time= 0;
 my_bool opt_slow_query_log_microseconds_timestamp= 0;
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+ulong   opt_query_response_time_range_base  = QRT_DEFAULT_BASE;
+my_bool opt_enable_query_response_time_stats= 0;
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
 my_bool lower_case_file_system= 0;
 my_bool opt_large_pages= 0;
 my_bool opt_myisam_use_mmap= 0;
@@ -688,6 +693,7 @@
 MY_LOCALE *my_default_lc_time_names;
 
 SHOW_COMP_OPTION have_ssl, have_symlink, have_dlopen, have_query_cache;
+SHOW_COMP_OPTION have_response_time_distribution;
 SHOW_COMP_OPTION have_geometry, have_rtree_keys;
 SHOW_COMP_OPTION have_crypt, have_compress;
 SHOW_COMP_OPTION have_community_features;
@@ -1398,6 +1404,9 @@
   free_global_thread_stats();
   free_global_table_stats();
   free_global_index_stats();
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+  query_response_time_free();
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
 #ifdef HAVE_REPLICATION
   end_slave_list();
 #endif
@@ -4118,6 +4127,9 @@
 
   init_global_table_stats();
   init_global_index_stats();
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+  query_response_time_init();
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
 
   /* We have to initialize the storage engines before CSV logging */
   if (ha_init())
@@ -5932,6 +5944,10 @@
   OPT_USE_GLOBAL_LONG_QUERY_TIME,
   OPT_USE_GLOBAL_LOG_SLOW_CONTROL,
   OPT_SLOW_QUERY_LOG_MICROSECONDS_TIMESTAMP,
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+  OPT_QRT_RANGE_BASE,
+  OPT_ENABLE_QRT_STATS,
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
   OPT_IGNORE_BUILTIN_INNODB,
   OPT_BINLOG_DIRECT_NON_TRANS_UPDATE,
   OPT_DEFAULT_CHARACTER_SET_OLD,
@@ -7003,6 +7019,23 @@
    "Use microsecond time's precision in slow query log",
    (uchar**) &opt_slow_query_log_microseconds_timestamp, (uchar**) &opt_slow_query_log_microseconds_timestamp,
    0, GET_BOOL, OPT_ARG, 0, 0, 1, 0, 1, 0},
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+  {"query_response_time_range_base", OPT_QRT_RANGE_BASE,
+     "Select base of log for query_response_time ranges. WARNING: variable change affect only after flush",
+   (uchar**) &opt_query_response_time_range_base, (uchar**) &opt_query_response_time_range_base,
+   0, GET_ULONG, REQUIRED_ARG, 
+   /* def_value */  QRT_DEFAULT_BASE,
+   /* min_value */  2,
+   /* max_value */  QRT_MAXIMUM_BASE, 
+   /* sub_size */   0,
+   /* block_size */ 1,
+   /* app_type */ 0
+  },
+  {"enable_query_response_time_stats", OPT_ENABLE_QRT_STATS,
+   "Enable or disable query response time statisics collecting",
+   (uchar**) &opt_enable_query_response_time_stats, (uchar**) &opt_enable_query_response_time_stats,
+   0, GET_BOOL, REQUIRED_ARG, 0, 0, 1, 0, 1, 0},
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
   {"lower_case_table_names", OPT_LOWER_CASE_TABLE_NAMES,
    "If set to 1, table names are stored in lowercase on disk and table names "
    "will be case-insensitive.  Should be set to 2 if you are using a case-"
@@ -8226,6 +8259,11 @@
 #else
   have_query_cache=SHOW_OPTION_NO;
 #endif
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+  have_response_time_distribution= SHOW_OPTION_YES;
+#else /* HAVE_RESPONSE_TIME_DISTRIBUTION */
+  have_response_time_distribution= SHOW_OPTION_NO;
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
 #ifdef HAVE_SPATIAL
   have_geometry=SHOW_OPTION_YES;
 #else
--- a/sql/mysql_priv.h
+++ b/sql/mysql_priv.h
@@ -2120,6 +2120,11 @@
 extern my_bool opt_query_cache_strip_comments;
 extern my_bool opt_use_global_long_query_time;
 extern my_bool opt_slow_query_log_microseconds_timestamp;
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+extern ulong   opt_query_response_time_range_base;
+extern my_bool opt_enable_query_response_time_stats;
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
+extern SHOW_COMP_OPTION have_response_time_distribution;
 extern my_bool sp_automatic_privileges, opt_noacl;
 extern my_bool opt_old_style_user_limits, trust_function_creators;
 extern uint opt_crash_binlog_innodb;
--- /dev/null
+++ b/sql/query_response_time.cc
@@ -0,0 +1,313 @@
+#include "my_global.h"
+#include "my_atomic.h"
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+#include "mysql_priv.h"
+#include "mysql_com.h"
+#include "rpl_tblmap.h"
+#include "query_response_time.h"
+
+#define TIME_STRING_POSITIVE_POWER_LENGTH QRT_TIME_STRING_POSITIVE_POWER_LENGTH
+#define TIME_STRING_NEGATIVE_POWER_LENGTH 6
+#define TOTAL_STRING_POSITIVE_POWER_LENGTH QRT_TOTAL_STRING_POSITIVE_POWER_LENGTH
+#define TOTAL_STRING_NEGATIVE_POWER_LENGTH 6
+#define MINIMUM_BASE 2
+#define MAXIMUM_BASE QRT_MAXIMUM_BASE
+#define POSITIVE_POWER_FILLER QRT_POSITIVE_POWER_FILLER
+#define NEGATIVE_POWER_FILLER QRT_NEGATIVE_POWER_FILLER
+#define STRING_OVERFLOW QRT_STRING_OVERFLOW
+#define TIME_OVERFLOW   QRT_TIME_OVERFLOW
+#define DEFAULT_BASE    QRT_DEFAULT_BASE
+
+#define do_xstr(s) do_str(s)
+#define do_str(s) #s
+#define do_format(filler,width) "%" filler width "lld"
+/*
+  Format strings for snprintf. Generate from:
+  POSITIVE_POWER_FILLER and TIME_STRING_POSITIVE_POWER_LENGTH
+  NEFATIVE_POWER_FILLER and TIME_STRING_NEGATIVE_POWER_LENGTH
+*/
+#define TIME_STRING_POSITIVE_POWER_FORMAT do_format(POSITIVE_POWER_FILLER,do_xstr(TIME_STRING_POSITIVE_POWER_LENGTH))
+#define TIME_STRING_NEGATIVE_POWER_FORMAT do_format(NEGATIVE_POWER_FILLER,do_xstr(TIME_STRING_NEGATIVE_POWER_LENGTH))
+#define TIME_STRING_FORMAT		      TIME_STRING_POSITIVE_POWER_FORMAT "." TIME_STRING_NEGATIVE_POWER_FORMAT
+
+#define TOTAL_STRING_POSITIVE_POWER_FORMAT do_format(POSITIVE_POWER_FILLER,do_xstr(TOTAL_STRING_POSITIVE_POWER_LENGTH))
+#define TOTAL_STRING_NEGATIVE_POWER_FORMAT do_format(NEGATIVE_POWER_FILLER,do_xstr(TOTAL_STRING_NEGATIVE_POWER_LENGTH))
+#define TOTAL_STRING_FORMAT		      TOTAL_STRING_POSITIVE_POWER_FORMAT "." TOTAL_STRING_NEGATIVE_POWER_FORMAT
+
+#define TIME_STRING_LENGTH	QRT_TIME_STRING_LENGTH
+#define TIME_STRING_BUFFER_LENGTH	(TIME_STRING_LENGTH + 1 /* '\0' */)
+
+#define TOTAL_STRING_LENGTH	QRT_TOTAL_STRING_LENGTH
+#define TOTAL_STRING_BUFFER_LENGTH	(TOTAL_STRING_LENGTH + 1 /* '\0' */)
+
+/*
+  Calculate length of "log linear"
+  1)
+  (MINIMUM_BASE ^ result) <= (10 ^ STRING_POWER_LENGTH) < (MINIMUM_BASE ^ (result + 1))
+
+  2)
+  (MINIMUM_BASE ^ result) <= (10 ^ STRING_POWER_LENGTH)
+  and
+  (MINIMUM_BASE ^ (result + 1)) > (10 ^ STRING_POWER_LENGTH)
+
+  3)
+  result     <= LOG(MINIMUM_BASE, 10 ^ STRING_POWER_LENGTH)= STRING_POWER_LENGTH * LOG(MINIMUM_BASE,10)
+  result + 1 >  LOG(MINIMUM_BASE, 10 ^ STRING_POWER_LENGTH)= STRING_POWER_LENGTH * LOG(MINIMUM_BASE,10)
+
+  4) STRING_POWER_LENGTH * LOG(MINIMUM_BASE,10) - 1 < result <= STRING_POWER_LENGTH * LOG(MINIMUM_BASE,10)
+
+  MINIMUM_BASE= 2 always, LOG(MINIMUM_BASE,10)= 3.3219280948873626, result= (int)3.3219280948873626 * STRING_POWER_LENGTH
+
+  Last counter always use for time overflow
+*/
+#define POSITIVE_POWER_COUNT ((int)(3.32192809 * TIME_STRING_POSITIVE_POWER_LENGTH))
+#define NEGATIVE_POWER_COUNT ((int)(3.32192809 * TIME_STRING_NEGATIVE_POWER_LENGTH))
+#define OVERALL_POWER_COUNT (NEGATIVE_POWER_COUNT + 1 + POSITIVE_POWER_COUNT)
+
+#define MILLION ((unsigned long)1000 * 1000)
+
+namespace query_response_time
+{
+
+class utility
+{
+public:
+  utility() : m_base(0)
+  {
+    m_max_dec_value= MILLION;
+    for(int i= 0; TIME_STRING_POSITIVE_POWER_LENGTH > i; ++i)
+      m_max_dec_value *= 10;
+    setup(DEFAULT_BASE);
+  }
+public:
+  uint      base()            const { return m_base; }
+  uint      negative_count()  const { return m_negative_count; }
+  uint      positive_count()  const { return m_positive_count; }
+  uint      bound_count()     const { return m_bound_count; }
+  ulonglong max_dec_value()   const { return m_max_dec_value; }
+  ulonglong bound(uint index) const { return m_bound[ index ]; }
+public:
+  void setup(uint base)
+  {
+    if(base != m_base)
+    {
+      m_base= base;
+
+      const ulonglong million= 1000 * 1000;
+      ulonglong value= million;
+      m_negative_count= 0;
+      while(value > 0)
+      {
+	m_negative_count += 1;
+	value /= m_base;
+      }
+      m_negative_count -= 1;
+
+      value= million;
+      m_positive_count= 0;
+      while(value < m_max_dec_value)
+      {
+	m_positive_count += 1;
+	value *= m_base;
+      }
+      m_bound_count= m_negative_count + m_positive_count;
+
+      value= million;
+      for(uint i= 0; i < m_negative_count; ++i)
+      {
+	value /= m_base;
+	m_bound[m_negative_count - i - 1]= value;
+      }
+      value= million;
+      for(uint i= 0; i < m_positive_count;  ++i)
+      {
+	m_bound[m_negative_count + i]= value;
+	value *= m_base;
+      }
+    }
+  }
+private:
+  uint      m_base;
+  uint      m_negative_count;
+  uint      m_positive_count;
+  uint      m_bound_count;
+  ulonglong m_max_dec_value; /* for TIME_STRING_POSITIVE_POWER_LENGTH=7 is 10000000 */
+  ulonglong m_bound[OVERALL_POWER_COUNT];
+};
+
+void print_time(char* buffer, std::size_t buffer_size, std::size_t string_positive_power_length, const char* format, uint64 value)
+{
+  memset(buffer,'X',buffer_size);
+  buffer[string_positive_power_length]= '.';
+  ulonglong second=      (value / MILLION);
+  ulonglong microsecond= (value % MILLION);
+  int result_length= snprintf(buffer, buffer_size, format, second, microsecond);
+  if(result_length < 0)
+  {
+    assert(sizeof(STRING_OVERFLOW) <= buffer_size);
+    memcpy(buffer, STRING_OVERFLOW, sizeof(STRING_OVERFLOW));
+    return;
+  }
+  buffer[result_length]= 0;
+}
+
+class time_collector
+{
+public:
+  time_collector(utility& u) : m_utility(&u)
+  {
+    my_atomic_rwlock_init(&time_collector_lock);
+  }
+  ~time_collector()
+  {
+    my_atomic_rwlock_destroy(&time_collector_lock);
+  }
+  uint32 count(uint index) const
+  {
+    my_atomic_rwlock_rdlock(&time_collector_lock);
+    uint32 result = my_atomic_load32((int32*)&m_count[index]);
+    my_atomic_rwlock_rdunlock(&time_collector_lock);
+    return result;
+  }
+  uint64 total(uint index) const
+  {
+    my_atomic_rwlock_rdlock(&time_collector_lock);
+    uint64 result= my_atomic_load64((int64*)&m_total[index]);
+    my_atomic_rwlock_rdunlock(&time_collector_lock);
+    return result;
+  }
+public:
+  void flush()
+  {
+    my_atomic_rwlock_wrlock(&time_collector_lock);
+    memset((void*)&m_count,0,sizeof(m_count));
+    memset((void*)&m_total,0,sizeof(m_total));
+    my_atomic_rwlock_wrunlock(&time_collector_lock);
+  }
+  void collect(uint64 time)
+  {
+    bool no_collect= false;
+    DBUG_EXECUTE_IF("response_time_distribution_log_only_more_300_milliseconds", {   \
+        no_collect= time < 300 * 1000;                                  \
+      });
+    if(no_collect) return;
+    int i= 0;
+    for(int count= m_utility->bound_count(); count > i; ++i)
+    {
+      if(m_utility->bound(i) > time)
+      {
+        my_atomic_rwlock_wrlock(&time_collector_lock);
+        my_atomic_add32((int32*)(&m_count[i]), 1);
+        my_atomic_add64((int64*)(&m_total[i]), time);
+        my_atomic_rwlock_wrunlock(&time_collector_lock);
+        break;
+      }
+    }
+  }
+private:
+  utility* m_utility;
+  /* The lock for atomic operations on m_count and m_total.  Only actually
+     used on architectures that do not have atomic implementation of atomic
+     operations. */
+  my_atomic_rwlock_t time_collector_lock;
+  uint32   m_count[OVERALL_POWER_COUNT + 1];
+  uint64   m_total[OVERALL_POWER_COUNT + 1];
+};
+
+class collector
+{
+public:
+  collector() : m_time(m_utility)
+  {
+    m_utility.setup(DEFAULT_BASE);
+    m_time.flush();
+  }
+public:
+  void flush()
+  {
+    m_utility.setup(opt_query_response_time_range_base);
+    m_time.flush();
+  }
+  int fill(THD* thd, TABLE_LIST *tables, COND *cond)
+  {
+    DBUG_ENTER("fill_schema_query_response_time");
+    TABLE        *table= static_cast<TABLE*>(tables->table);
+    Field        **fields= table->field;
+    for(uint i= 0, count= bound_count() + 1 /* with overflow */; count > i; ++i)
+    {
+      char time[TIME_STRING_BUFFER_LENGTH];
+      char total[TOTAL_STRING_BUFFER_LENGTH];
+      if(i == bound_count())
+      {        
+        assert(sizeof(TIME_OVERFLOW) <= TIME_STRING_BUFFER_LENGTH);
+        assert(sizeof(TIME_OVERFLOW) <= TOTAL_STRING_BUFFER_LENGTH);
+        memcpy(time,TIME_OVERFLOW,sizeof(TIME_OVERFLOW));
+        memcpy(total,TIME_OVERFLOW,sizeof(TIME_OVERFLOW));
+      }
+      else
+      {
+        print_time(time,sizeof(time),TIME_STRING_POSITIVE_POWER_LENGTH,TIME_STRING_FORMAT,this->bound(i));
+        print_time(total,sizeof(total),TOTAL_STRING_POSITIVE_POWER_LENGTH,TOTAL_STRING_FORMAT,this->total(i));
+      }
+      fields[0]->store(time,strlen(time),system_charset_info);
+      fields[1]->store(this->count(i));
+      fields[2]->store(total,strlen(total),system_charset_info);
+      if (schema_table_store_record(thd, table))
+      {
+	DBUG_RETURN(1);
+      }
+    }
+    DBUG_RETURN(0);
+  }
+  void collect(ulonglong time)
+  {
+    m_time.collect(time);
+  }
+  uint bound_count() const
+  {
+    return m_utility.bound_count();
+  }
+  ulonglong bound(uint index)
+  {
+    return m_utility.bound(index);
+  }
+  ulonglong count(uint index)
+  {
+    return m_time.count(index);
+  }
+  ulonglong total(uint index)
+  {
+    return m_time.total(index);
+  }
+private:
+  utility          m_utility;
+  time_collector   m_time;
+};
+
+static collector g_collector;
+
+} // namespace query_response_time
+
+void query_response_time_init()
+{
+}
+
+void query_response_time_free()
+{
+  query_response_time::g_collector.flush();
+}
+
+void query_response_time_flush()
+{
+  query_response_time::g_collector.flush();
+}
+void query_response_time_collect(ulonglong query_time)
+{
+  query_response_time::g_collector.collect(query_time);
+}
+
+int query_response_time_fill(THD* thd, TABLE_LIST *tables, COND *cond)
+{
+  return query_response_time::g_collector.fill(thd,tables,cond);
+}
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
--- /dev/null
+++ b/sql/query_response_time.h
@@ -0,0 +1,71 @@
+#ifndef QUERY_RESPONSE_TIME_H
+#define QUERY_RESPONSE_TIME_H
+
+/*
+  Settings for query response time
+*/
+
+/*
+  Maximum string length for (10 ^ (-1 * QRT_STRING_NEGATIVE_POWER_LENGTH)) in text representation.
+  Example: for 6 is 0.000001
+  Always 2
+
+  Maximum string length for (10 ^ (QRT_STRING_POSITIVE_POWER_LENGTH + 1) - 1) in text representation.
+  Example: for 7 is 9999999.0
+*/
+#define QRT_TIME_STRING_POSITIVE_POWER_LENGTH 7
+#define QRT_TOTAL_STRING_POSITIVE_POWER_LENGTH 7
+
+/*
+  Minimum base for log - ALWAYS 2
+  Maximum base for log:
+*/
+#define QRT_MAXIMUM_BASE 1000
+
+/*
+  Filler for whole number (positive power)
+  Example: for
+  QRT_POSITIVE_POWER_FILLER ' '
+  QRT_POSITIVE_POWER_LENGTH 7
+  and number 7234 result is:
+  '   7234'
+*/
+#define QRT_POSITIVE_POWER_FILLER " "
+/*
+  Filler for fractional number. Similiary to whole number
+*/
+#define QRT_NEGATIVE_POWER_FILLER "0"
+
+/*
+  Message if string overflow (string overflow - internal error, this string say about bug in QRT)
+*/
+#define QRT_STRING_OVERFLOW "TOO BIG STRING"
+
+/*
+  Message if time too big for statistic collecting (very long query)
+*/
+#define QRT_TIME_OVERFLOW "TOO LONG"
+
+#define QRT_DEFAULT_BASE 10
+
+#define QRT_TIME_STRING_LENGTH				\
+  max( (QRT_TIME_STRING_POSITIVE_POWER_LENGTH + 1 /* '.' */ + 6 /*QRT_TIME_STRING_NEGATIVE_POWER_LENGTH*/), \
+       max( (sizeof(QRT_TIME_OVERFLOW) - 1),		\
+	    (sizeof(QRT_STRING_OVERFLOW) - 1) ) )
+
+#define QRT_TOTAL_STRING_LENGTH				\
+  max( (QRT_TOTAL_STRING_POSITIVE_POWER_LENGTH + 1 /* '.' */ + 6 /*QRT_TOTAL_STRING_NEGATIVE_POWER_LENGTH*/), \
+       max( (sizeof(QRT_TIME_OVERFLOW) - 1),		\
+	    (sizeof(QRT_STRING_OVERFLOW) - 1) ) )
+
+extern ST_SCHEMA_TABLE query_response_time_table;
+
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+extern void query_response_time_init   ();
+extern void query_response_time_free   ();
+extern void query_response_time_flush  ();
+extern void query_response_time_collect(ulonglong query_time);
+extern int  query_response_time_fill   (THD* thd, TABLE_LIST *tables, COND *cond);
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
+
+#endif // QUERY_RESPONSE_TIME_H
--- a/sql/set_var.cc
+++ b/sql/set_var.cc
@@ -1026,6 +1026,18 @@
                                                     &SV::query_exec_time,
                                                     sys_var::SESSION_VARIABLE_IN_BINLOG);
 #endif
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+static sys_var_bool_ptr
+sys_enable_query_response_time_stats(&vars,
+                                     "enable_query_response_time_stats",
+                                     &opt_enable_query_response_time_stats);
+static sys_var_long_ptr
+sys_query_response_time_range_base(&vars,
+                                   "query_response_time_range_base",
+                                   &opt_query_response_time_range_base);
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
+static sys_var_have_variable sys_have_response_time_distribution(&vars, "have_response_time_distribution",
++                                                        &have_response_time_distribution);
 /* Synonym of "slow_query_log" for consistency with SHOW VARIABLES output */
 static sys_var_log_state sys_var_log_slow(&vars, "log_slow_queries",
                                           &opt_slow_log, QUERY_LOG_SLOW);
--- a/sql/sql_parse.cc
+++ b/sql/sql_parse.cc
@@ -30,6 +30,7 @@
 #include "events.h"
 #include "sql_trigger.h"
 #include "debug_sync.h"
+#include "query_response_time.h"
 
 /**
   @defgroup Runtime_Environment Runtime Environment
@@ -1779,6 +1780,12 @@
 
   ulonglong end_utime_of_query= thd->current_utime();
   ulonglong query_exec_time= get_query_exec_time(thd, end_utime_of_query);
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+  if (opt_enable_query_response_time_stats)
+  {
+    query_response_time_collect(query_exec_time);
+  }
+#endif
 
   /*
     Low long_query_time value most likely means user is debugging stuff and even
@@ -1949,6 +1956,7 @@
   case SCH_CHARSETS:
   case SCH_ENGINES:
   case SCH_COLLATIONS:
+  case SCH_QUERY_RESPONSE_TIME:
   case SCH_COLLATION_CHARACTER_SET_APPLICABILITY:
   case SCH_USER_PRIVILEGES:
   case SCH_SCHEMA_PRIVILEGES:
@@ -7308,6 +7316,12 @@
     init_global_index_stats();
     pthread_mutex_unlock(&LOCK_global_index_stats);
   }
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+  if (options & REFRESH_QUERY_RESPONSE_TIME)
+  {
+    query_response_time_flush();
+  }
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
   if (options & (REFRESH_USER_STATS | REFRESH_CLIENT_STATS | REFRESH_THREAD_STATS))
   {
     pthread_mutex_lock(&LOCK_global_user_client_stats);
--- a/sql/sql_show.cc
+++ b/sql/sql_show.cc
@@ -31,6 +31,7 @@
 #include "event_data_objects.h"
 #endif
 #include <my_dir.h>
+#include "query_response_time.h"
 #include "debug_sync.h"
 
 #define STR_OR_NIL(S) ((S) ? (S) : "<nil>")
@@ -7533,6 +7534,13 @@
 
 */
 
+ST_FIELD_INFO query_response_time_fields_info[] =
+  {
+    {"time",  QRT_TIME_STRING_LENGTH,      MYSQL_TYPE_STRING,  0, 0,            "", SKIP_OPEN_TABLE },
+    {"count", MY_INT32_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONG, 0, MY_I_S_UNSIGNED, "", SKIP_OPEN_TABLE },
+    {"total",  QRT_TIME_STRING_LENGTH,     MYSQL_TYPE_STRING,  0, 0,            "", SKIP_OPEN_TABLE },
+    {0,       0,                           MYSQL_TYPE_STRING,  0, 0,             0, SKIP_OPEN_TABLE }
+  };
 ST_SCHEMA_TABLE schema_tables[]=
 {
   {"CHARACTER_SETS", charsets_fields_info, create_schema_table, 
@@ -7587,6 +7595,13 @@
    1, 9, 0, OPEN_TABLE_ONLY},
   {"ROUTINES", proc_fields_info, create_schema_table, 
    fill_schema_proc, make_proc_old_format, 0, -1, -1, 0, 0},
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+  {"QUERY_RESPONSE_TIME", query_response_time_fields_info, create_schema_table, 
+   query_response_time_fill, make_old_format, 0, -1, -1, 0, 0},
+#else /* HAVE_RESPONSE_TIME_DISTRIBUTION */
+  {"QUERY_RESPONSE_TIME", query_response_time_fields_info, create_schema_table, 
+   0, make_old_format, 0, -1, -1, 0, 0},
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
   {"SCHEMATA", schema_fields_info, create_schema_table,
    fill_schema_schemata, make_schemata_old_format, 0, 1, -1, 0, 0},
   {"SCHEMA_PRIVILEGES", schema_privileges_fields_info, create_schema_table,
--- a/sql/sql_yacc.yy
+++ b/sql/sql_yacc.yy
@@ -1081,6 +1081,7 @@
 %token  PURGE
 %token  QUARTER_SYM
 %token  QUERY_SYM
+%token  QUERY_RESPONSE_TIME_SYM
 %token  QUICK
 %token  RANGE_SYM                     /* SQL-2003-R */
 %token  READS_SYM                     /* SQL-2003-R */
@@ -10416,6 +10417,15 @@
            if (prepare_schema_table(YYTHD, lex, 0, SCH_INDEX_STATS))
              MYSQL_YYABORT;
           }
+        | QUERY_RESPONSE_TIME_SYM wild_and_where
+	  {
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+           LEX *lex= Lex;
+           lex->sql_command= SQLCOM_SELECT;
+           if (prepare_schema_table(YYTHD, lex, 0, SCH_QUERY_RESPONSE_TIME))
+             MYSQL_YYABORT;	  
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
+	  }
         | CREATE PROCEDURE sp_name
           {
             LEX *lex= Lex;
@@ -10636,6 +10646,12 @@
           { Lex->type|= REFRESH_TABLE_STATS; }
         | INDEX_STATS_SYM
           { Lex->type|= REFRESH_INDEX_STATS; }
+        | QUERY_RESPONSE_TIME_SYM
+          { 
+#ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
+            Lex->type|= REFRESH_QUERY_RESPONSE_TIME; 
+#endif /* HAVE_RESPONSE_TIME_DISTRIBUTION */
+          }
         | MASTER_SYM
           { Lex->type|= REFRESH_MASTER; }
         | DES_KEY_FILE
@@ -11915,6 +11931,7 @@
         | PROFILES_SYM             {}
         | QUARTER_SYM              {}
         | QUERY_SYM                {}
+        | QUERY_RESPONSE_TIME_SYM  {}
         | QUICK                    {}
         | READ_ONLY_SYM            {}
         | REBUILD_SYM              {}
--- a/sql/table.h
+++ b/sql/table.h
@@ -964,6 +964,7 @@
   SCH_PROFILES,
   SCH_REFERENTIAL_CONSTRAINTS,
   SCH_PROCEDURES,
+  SCH_QUERY_RESPONSE_TIME,
   SCH_SCHEMATA,
   SCH_SCHEMA_PRIVILEGES,
   SCH_SESSION_STATUS,
--- a/configure.in
+++ b/configure.in
@@ -1738,6 +1738,7 @@
   int main()
   {
     int foo= -10; int bar= 10;
+    long long int foo64= -10; long long int bar64= 10;
     if (!__sync_fetch_and_add(&foo, bar) || foo)
       return -1;
     bar= __sync_lock_test_and_set(&foo, bar);
@@ -1746,6 +1747,14 @@
     bar= __sync_val_compare_and_swap(&bar, foo, 15);
     if (bar)
       return -1;
+    if (!__sync_fetch_and_add(&foo64, bar64) || foo64)
+      return -1;
+    bar64= __sync_lock_test_and_set(&foo64, bar64);
+    if (bar64 || foo64 != 10)
+      return -1;
+    bar64= __sync_val_compare_and_swap(&bar64, foo, 15);
+    if (bar64)
+      return -1;
     return 0;
   }
 ], [mysql_cv_gcc_atomic_builtins=yes],
@@ -1757,6 +1766,46 @@
             [Define to 1 if compiler provides atomic builtins.])
 fi
 
+AC_CACHE_CHECK([whether the OS provides atomic_* functions like Solaris],
+               [mysql_cv_solaris_atomic],
+  [AC_RUN_IFELSE(
+     [AC_LANG_PROGRAM(
+        [[
+        #include <atomic.h>
+        ]],
+     [[
+        int foo = -10; int bar = 10;
+        int64_t foo64 = -10; int64_t bar64 = 10;
+        if (atomic_add_int_nv((uint_t *)&foo, bar) || foo)
+          return -1;
+        bar = atomic_swap_uint((uint_t *)&foo, (uint_t)bar);
+        if (bar || foo != 10)
+          return -1;
+        bar = atomic_cas_uint((uint_t *)&bar, (uint_t)foo, 15);
+        if (bar)
+          return -1;
+        if (atomic_add_64_nv((volatile uint64_t *)&foo64, bar64) || foo64)
+          return -1;
+        bar64 = atomic_swap_64((volatile uint64_t *)&foo64, (uint64_t)bar64);
+        if (bar64 || foo64 != 10)
+          return -1;
+        bar64 = atomic_cas_64((volatile uint64_t *)&bar64, (uint_t)foo64, 15);
+        if (bar64)
+          return -1;
+        atomic_or_64((volatile uint64_t *)&bar64, 0);
+        return 0;
+     ]]
+     )],
+   [mysql_cv_solaris_atomic=yes],
+   [mysql_cv_solaris_atomic=no],
+   [mysql_cv_solaris_atomic=no]
+)])
+
+if test "x$mysql_cv_solaris_atomic" = xyes; then
+  AC_DEFINE(HAVE_SOLARIS_ATOMIC, 1,
+            [Define to 1 if OS provides atomic_* functions like Solaris.])
+fi
+
 # Force static compilation to avoid linking problems/get more speed
 AC_ARG_WITH(mysqld-ldflags,
     [  --with-mysqld-ldflags   Extra linking arguments for mysqld],
@@ -2683,7 +2732,16 @@
 AC_SUBST(readline_link)
 AC_SUBST(readline_h_ln_cmd)
 
+AC_ARG_WITH(response_time_distribution,
+    AC_HELP_STRING([--without-response_time_distribution],[Disable response_time_distribution feature.]),
+    [with_response_time_distribution=$withval],
+    [with_response_time_distribution=yes]
+)
 
+if test "$with_response_time_distribution" = "yes"
+then
+  AC_DEFINE([HAVE_RESPONSE_TIME_DISTRIBUTION], [1], [If we want to have response_time_distribution])
+fi
 
 # Include man pages, if desired, adapted to the configured parts.
 if test X"$with_man" = Xyes
--- /dev/null
+++ b/include/my_atomic.h
@@ -0,0 +1,287 @@
+#ifndef MY_ATOMIC_INCLUDED
+#define MY_ATOMIC_INCLUDED
+
+/* Copyright (C) 2006 MySQL AB
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+
+/*
+  This header defines five atomic operations:
+
+  my_atomic_add#(&var, what)
+    'Fetch and Add'
+    add 'what' to *var, and return the old value of *var
+
+  my_atomic_fas#(&var, what)
+    'Fetch And Store'
+    store 'what' in *var, and return the old value of *var
+
+  my_atomic_cas#(&var, &old, new)
+    An odd variation of 'Compare And Set/Swap'
+    if *var is equal to *old, then store 'new' in *var, and return TRUE
+    otherwise store *var in *old, and return FALSE
+    Usually, &old should not be accessed if the operation is successful.
+
+  my_atomic_load#(&var)
+    return *var
+
+  my_atomic_store#(&var, what)
+    store 'what' in *var
+
+  '#' is substituted by a size suffix - 8, 16, 32, 64, or ptr
+  (e.g. my_atomic_add8, my_atomic_fas32, my_atomic_casptr).
+
+  NOTE This operations are not always atomic, so they always must be
+  enclosed in my_atomic_rwlock_rdlock(lock)/my_atomic_rwlock_rdunlock(lock)
+  or my_atomic_rwlock_wrlock(lock)/my_atomic_rwlock_wrunlock(lock).
+  Hint: if a code block makes intensive use of atomic ops, it make sense
+  to take/release rwlock once for the whole block, not for every statement.
+
+  On architectures where these operations are really atomic, rwlocks will
+  be optimized away.
+  8- and 16-bit atomics aren't implemented for windows (see generic-msvc.h),
+  but can be added, if necessary. 
+*/
+
+#ifndef my_atomic_rwlock_init
+
+#define intptr         void *
+/**
+  Currently we don't support 8-bit and 16-bit operations.
+  It can be added later if needed.
+*/
+#undef MY_ATOMIC_HAS_8_16
+
+#ifndef MY_ATOMIC_MODE_RWLOCKS
+/*
+ * Attempt to do atomic ops without locks
+ */
+#include "atomic/nolock.h"
+#endif
+
+#ifndef make_atomic_cas_body
+/* nolock.h was not able to generate even a CAS function, fall back */
+#include "atomic/rwlock.h"
+#endif
+
+/* define missing functions by using the already generated ones */
+#ifndef make_atomic_add_body
+#define make_atomic_add_body(S)                                 \
+  int ## S tmp=*a;                                              \
+  while (!my_atomic_cas ## S(a, &tmp, tmp+v)) ;                 \
+  v=tmp;
+#endif
+#ifndef make_atomic_fas_body
+#define make_atomic_fas_body(S)                                 \
+  int ## S tmp=*a;                                              \
+  while (!my_atomic_cas ## S(a, &tmp, v)) ;                     \
+  v=tmp;
+#endif
+#ifndef make_atomic_load_body
+#define make_atomic_load_body(S)                                \
+  ret= 0; /* avoid compiler warning */                          \
+  (void)(my_atomic_cas ## S(a, &ret, ret));
+#endif
+#ifndef make_atomic_store_body
+#define make_atomic_store_body(S)                               \
+  (void)(my_atomic_fas ## S (a, v));
+#endif
+
+/*
+  transparent_union doesn't work in g++
+  Bug ?
+
+  Darwin's gcc doesn't want to put pointers in a transparent_union
+  when built with -arch ppc64. Complains:
+  warning: 'transparent_union' attribute ignored
+*/
+#if defined(__GNUC__) && !defined(__cplusplus) && \
+      ! (defined(__APPLE__) && (defined(_ARCH_PPC64) ||defined (_ARCH_PPC)))
+/*
+  we want to be able to use my_atomic_xxx functions with
+  both signed and unsigned integers. But gcc will issue a warning
+  "passing arg N of `my_atomic_XXX' as [un]signed due to prototype"
+  if the signedness of the argument doesn't match the prototype, or
+  "pointer targets in passing argument N of my_atomic_XXX differ in signedness"
+  if int* is used where uint* is expected (or vice versa).
+  Let's shut these warnings up
+*/
+#define make_transparent_unions(S)                              \
+        typedef union {                                         \
+          int  ## S  i;                                         \
+          uint ## S  u;                                         \
+        } U_ ## S   __attribute__ ((transparent_union));        \
+        typedef union {                                         \
+          int  ## S volatile *i;                                \
+          uint ## S volatile *u;                                \
+        } Uv_ ## S   __attribute__ ((transparent_union));
+#define uintptr intptr
+make_transparent_unions(8)
+make_transparent_unions(16)
+make_transparent_unions(32)
+make_transparent_unions(64)
+make_transparent_unions(ptr)
+#undef uintptr
+#undef make_transparent_unions
+#define a       U_a.i
+#define cmp     U_cmp.i
+#define v       U_v.i
+#define set     U_set.i
+#else
+#define U_8    int8
+#define U_16   int16
+#define U_32   int32
+#define U_64   int64
+#define U_ptr  intptr
+#define Uv_8   int8
+#define Uv_16  int16
+#define Uv_32  int32
+#define Uv_64  int64
+#define Uv_ptr intptr
+#define U_a    volatile *a
+#define U_cmp  *cmp
+#define U_v    v
+#define U_set  set
+#endif /* __GCC__ transparent_union magic */
+
+#define make_atomic_cas(S)                                      \
+static inline int my_atomic_cas ## S(Uv_ ## S U_a,              \
+                            Uv_ ## S U_cmp, U_ ## S U_set)      \
+{                                                               \
+  int8 ret;                                                     \
+  make_atomic_cas_body(S);                                      \
+  return ret;                                                   \
+}
+
+#define make_atomic_add(S)                                      \
+static inline int ## S my_atomic_add ## S(                      \
+                        Uv_ ## S U_a, U_ ## S U_v)              \
+{                                                               \
+  make_atomic_add_body(S);                                      \
+  return v;                                                     \
+}
+
+#define make_atomic_fas(S)                                      \
+static inline int ## S my_atomic_fas ## S(                      \
+                         Uv_ ## S U_a, U_ ## S U_v)             \
+{                                                               \
+  make_atomic_fas_body(S);                                      \
+  return v;                                                     \
+}
+
+#define make_atomic_load(S)                                     \
+static inline int ## S my_atomic_load ## S(Uv_ ## S U_a)        \
+{                                                               \
+  int ## S ret;                                                 \
+  make_atomic_load_body(S);                                     \
+  return ret;                                                   \
+}
+
+#define make_atomic_store(S)                                    \
+static inline void my_atomic_store ## S(                        \
+                     Uv_ ## S U_a, U_ ## S U_v)                 \
+{                                                               \
+  make_atomic_store_body(S);                                    \
+}
+
+#ifdef MY_ATOMIC_HAS_8_16
+make_atomic_cas(8)
+make_atomic_cas(16)
+#endif
+make_atomic_cas(32)
+make_atomic_cas(64)
+make_atomic_cas(ptr)
+
+#ifdef MY_ATOMIC_HAS_8_16
+make_atomic_add(8)
+make_atomic_add(16)
+#endif
+make_atomic_add(32)
+make_atomic_add(64)
+
+#ifdef MY_ATOMIC_HAS_8_16
+make_atomic_load(8)
+make_atomic_load(16)
+#endif
+make_atomic_load(32)
+make_atomic_load(64)
+make_atomic_load(ptr)
+
+#ifdef MY_ATOMIC_HAS_8_16
+make_atomic_fas(8)
+make_atomic_fas(16)
+#endif
+make_atomic_fas(32)
+make_atomic_fas(64)
+make_atomic_fas(ptr)
+
+#ifdef MY_ATOMIC_HAS_8_16
+make_atomic_store(8)
+make_atomic_store(16)
+#endif
+make_atomic_store(32)
+make_atomic_store(64)
+make_atomic_store(ptr)
+
+#ifdef _atomic_h_cleanup_
+#include _atomic_h_cleanup_
+#undef _atomic_h_cleanup_
+#endif
+
+#undef U_8
+#undef U_16
+#undef U_32
+#undef U_64
+#undef U_ptr
+#undef Uv_8
+#undef Uv_16
+#undef Uv_32
+#undef Uv_64
+#undef Uv_ptr
+#undef a
+#undef cmp
+#undef v
+#undef set
+#undef U_a
+#undef U_cmp
+#undef U_v
+#undef U_set
+#undef make_atomic_add
+#undef make_atomic_cas
+#undef make_atomic_load
+#undef make_atomic_store
+#undef make_atomic_fas
+#undef make_atomic_add_body
+#undef make_atomic_cas_body
+#undef make_atomic_load_body
+#undef make_atomic_store_body
+#undef make_atomic_fas_body
+#undef intptr
+
+/*
+  the macro below defines (as an expression) the code that
+  will be run in spin-loops. Intel manuals recummend to have PAUSE there.
+  It is expected to be defined in include/atomic/ *.h files
+*/
+#ifndef LF_BACKOFF
+#define LF_BACKOFF (1)
+#endif
+
+#define MY_ATOMIC_OK       0
+#define MY_ATOMIC_NOT_1CPU 1
+extern int my_atomic_initialize();
+
+#endif
+
+#endif /* MY_ATOMIC_INCLUDED */
--- a/mysys/Makefile.am
+++ b/mysys/Makefile.am
@@ -51,7 +51,8 @@
 			rijndael.c my_aes.c sha1.c \
 			my_compare.c my_netware.c my_largepage.c \
 			my_memmem.c stacktrace.c \
-			my_windac.c my_access.c base64.c my_libwrap.c
+			my_windac.c my_access.c base64.c my_libwrap.c \
+			my_atomic.c
 
 if NEED_THREAD
 # mf_keycache is used only in the server, so it is safe to leave the file
--- a/mysys/CMakeLists.txt
+++ b/mysys/CMakeLists.txt
@@ -41,7 +41,8 @@
 				my_static.c my_symlink.c my_symlink2.c my_sync.c my_thr_init.c my_wincond.c
 				my_windac.c my_winthread.c my_write.c ptr_cmp.c queues.c stacktrace.c
 				rijndael.c safemalloc.c sha1.c string.c thr_alarm.c thr_lock.c thr_mutex.c
-				thr_rwlock.c tree.c typelib.c my_vle.c base64.c my_memmem.c my_getpagesize.c)
+				thr_rwlock.c tree.c typelib.c my_vle.c base64.c my_memmem.c my_getpagesize.c
+                                my_atomic.c)
 
 IF(NOT SOURCE_SUBLIBS)
   ADD_LIBRARY(mysys ${MYSYS_SOURCES})
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -38,7 +38,10 @@
 			my_aes.h my_tree.h my_trie.h hash.h thr_alarm.h \
 			thr_lock.h t_ctype.h violite.h my_md5.h base64.h \
 			my_compare.h my_time.h my_vle.h my_user.h \
-			my_libwrap.h my_stacktrace.h welcome_copyright_notice.h
+			my_libwrap.h my_stacktrace.h  welcome_copyright_notice.h \
+                       my_atomic.h atomic/gcc_builtins.h atomic/generic-msvc.h \
+			atomic/nolock.h atomic/rwlock.h atomic/solaris.h \
+			atomic/x86-gcc.h
 
 EXTRA_DIST =        mysql.h.pp mysql/plugin.h.pp
 
--- /dev/null
+++ b/include/atomic/gcc_builtins.h
@@ -0,0 +1,42 @@
+#ifndef ATOMIC_GCC_BUILTINS_INCLUDED
+#define ATOMIC_GCC_BUILTINS_INCLUDED
+
+/* Copyright (C) 2008 MySQL AB
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+
+#define make_atomic_add_body(S)                     \
+  v= __sync_fetch_and_add(a, v);
+#define make_atomic_fas_body(S)                     \
+  v= __sync_lock_test_and_set(a, v);
+#define make_atomic_cas_body(S)                     \
+  int ## S sav;                                     \
+  int ## S cmp_val= *cmp;                           \
+  sav= __sync_val_compare_and_swap(a, cmp_val, set);\
+  if (!(ret= (sav == cmp_val))) *cmp= sav
+
+#ifdef MY_ATOMIC_MODE_DUMMY
+#define make_atomic_load_body(S)   ret= *a
+#define make_atomic_store_body(S)  *a= v
+#define MY_ATOMIC_MODE "gcc-builtins-up"
+
+#else
+#define MY_ATOMIC_MODE "gcc-builtins-smp"
+#define make_atomic_load_body(S)                    \
+  ret= __sync_fetch_and_or(a, 0);
+#define make_atomic_store_body(S)                   \
+  (void) __sync_lock_test_and_set(a, v);
+#endif
+
+#endif /* ATOMIC_GCC_BUILTINS_INCLUDED */
--- /dev/null
+++ b/include/atomic/generic-msvc.h
@@ -0,0 +1,134 @@
+/* Copyright (C) 2006-2008 MySQL AB, 2008-2009 Sun Microsystems, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+
+#ifndef _atomic_h_cleanup_
+#define _atomic_h_cleanup_ "atomic/generic-msvc.h"
+
+/*
+  We don't implement anything specific for MY_ATOMIC_MODE_DUMMY, always use
+  intrinsics.
+  8 and 16-bit atomics are not implemented, but it can be done if necessary.
+*/
+#undef MY_ATOMIC_HAS_8_16
+
+#include <windows.h>
+/*
+  x86 compilers (both VS2003 or VS2005) never use instrinsics, but generate 
+  function calls to kernel32 instead, even in the optimized build. 
+  We force intrinsics as described in MSDN documentation for 
+  _InterlockedCompareExchange.
+*/
+#ifdef _M_IX86
+
+#if (_MSC_VER >= 1500)
+#include <intrin.h>
+#else
+C_MODE_START
+/*Visual Studio 2003 and earlier do not have prototypes for atomic intrinsics*/
+LONG _InterlockedCompareExchange (LONG volatile *Target, LONG Value, LONG Comp);
+LONGLONG _InterlockedCompareExchange64 (LONGLONG volatile *Target,
+                                        LONGLONG Value, LONGLONG Comp);
+C_MODE_END
+
+#pragma intrinsic(_InterlockedCompareExchange)
+#pragma intrinsic(_InterlockedCompareExchange64)
+#endif
+
+#define InterlockedCompareExchange _InterlockedCompareExchange
+#define InterlockedCompareExchange64 _InterlockedCompareExchange64
+/*
+ No need to do something special for InterlockedCompareExchangePointer
+ as it is a #define to InterlockedCompareExchange. The same applies to
+ InterlockedExchangePointer. 
+*/
+#endif /*_M_IX86*/
+
+#define MY_ATOMIC_MODE "msvc-intrinsics"
+/* Implement using CAS on WIN32 */
+#define IL_COMP_EXCHG32(X,Y,Z)  \
+  InterlockedCompareExchange((volatile LONG *)(X),(Y),(Z))
+#define IL_COMP_EXCHG64(X,Y,Z)  \
+  InterlockedCompareExchange64((volatile LONGLONG *)(X), \
+                               (LONGLONG)(Y),(LONGLONG)(Z))
+#define IL_COMP_EXCHGptr        InterlockedCompareExchangePointer
+
+#define make_atomic_cas_body(S)                                 \
+  int ## S initial_cmp= *cmp;                                   \
+  int ## S initial_a= IL_COMP_EXCHG ## S (a, set, initial_cmp); \
+  if (!(ret= (initial_a == initial_cmp))) *cmp= initial_a;
+
+#ifndef _M_IX86
+/* Use full set of optimised functions on WIN64 */
+#define IL_EXCHG_ADD32(X,Y)     \
+  InterlockedExchangeAdd((volatile LONG *)(X),(Y))
+#define IL_EXCHG_ADD64(X,Y)     \
+  InterlockedExchangeAdd64((volatile LONGLONG *)(X),(LONGLONG)(Y))
+#define IL_EXCHG32(X,Y)         \
+  InterlockedExchange((volatile LONG *)(X),(Y))
+#define IL_EXCHG64(X,Y)         \
+  InterlockedExchange64((volatile LONGLONG *)(X),(LONGLONG)(Y))
+#define IL_EXCHGptr             InterlockedExchangePointer
+
+#define make_atomic_add_body(S) \
+  v= IL_EXCHG_ADD ## S (a, v)
+#define make_atomic_swap_body(S) \
+  v= IL_EXCHG ## S (a, v)
+#define make_atomic_load_body(S)       \
+  ret= 0; /* avoid compiler warning */ \
+  ret= IL_COMP_EXCHG ## S (a, ret, ret);
+#endif
+/*
+  my_yield_processor (equivalent of x86 PAUSE instruction) should be used
+  to improve performance on hyperthreaded CPUs. Intel recommends to use it in
+  spin loops also on non-HT machines to reduce power consumption (see e.g 
+  http://softwarecommunity.intel.com/articles/eng/2004.htm)
+
+  Running benchmarks for spinlocks implemented with InterlockedCompareExchange
+  and YieldProcessor shows that much better performance is achieved by calling
+  YieldProcessor in a loop - that is, yielding longer. On Intel boxes setting
+  loop count in the range 200-300 brought best results.
+ */
+#ifndef YIELD_LOOPS
+#define YIELD_LOOPS 200
+#endif
+
+static __inline int my_yield_processor()
+{
+  int i;
+  for(i=0; i<YIELD_LOOPS; i++)
+  {
+#if (_MSC_VER <= 1310)
+    /* On older compilers YieldProcessor is not available, use inline assembly*/
+    __asm { rep nop }
+#else
+    YieldProcessor();
+#endif
+  }
+  return 1;
+}
+
+#define LF_BACKOFF my_yield_processor()
+#else /* cleanup */
+
+#undef IL_EXCHG_ADD32
+#undef IL_EXCHG_ADD64
+#undef IL_COMP_EXCHG32
+#undef IL_COMP_EXCHG64
+#undef IL_COMP_EXCHGptr
+#undef IL_EXCHG32
+#undef IL_EXCHG64
+#undef IL_EXCHGptr
+
+#endif
--- /dev/null
+++ b/include/atomic/nolock.h
@@ -0,0 +1,69 @@
+#ifndef ATOMIC_NOLOCK_INCLUDED
+#define ATOMIC_NOLOCK_INCLUDED
+
+/* Copyright (C) 2006 MySQL AB
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+
+#if defined(__i386__) || defined(_MSC_VER) || defined(__x86_64__)   \
+    || defined(HAVE_GCC_ATOMIC_BUILTINS) \
+    || defined(HAVE_SOLARIS_ATOMIC)
+
+#  ifdef MY_ATOMIC_MODE_DUMMY
+#    define LOCK_prefix ""
+#  else
+#    define LOCK_prefix "lock"
+#  endif
+/*
+  We choose implementation as follows:
+  ------------------------------------
+  On Windows using Visual C++ the native implementation should be
+  preferrable. When using gcc we prefer the Solaris implementation
+  before the gcc because of stability preference, we choose gcc
+  builtins if available, otherwise we choose the somewhat broken
+  native x86 implementation. If neither Visual C++ or gcc we still
+  choose the Solaris implementation on Solaris (mainly for SunStudio
+  compilers).
+*/
+#  if defined(_MSV_VER)
+#    include "generic-msvc.h"
+#  elif __GNUC__
+#    if defined(HAVE_SOLARIS_ATOMIC)
+#      include "solaris.h"
+#    elif defined(HAVE_GCC_ATOMIC_BUILTINS)
+#      include "gcc_builtins.h"
+#    elif defined(__i386__) || defined(__x86_64__)
+#      include "x86-gcc.h"
+#    endif
+#  elif defined(HAVE_SOLARIS_ATOMIC)
+#    include "solaris.h"
+#  endif
+#endif
+
+#if defined(make_atomic_cas_body)
+/*
+  Type not used so minimal size (emptry struct has different size between C
+  and C++, zero-length array is gcc-specific).
+*/
+typedef char my_atomic_rwlock_t __attribute__ ((unused));
+#define my_atomic_rwlock_destroy(name)
+#define my_atomic_rwlock_init(name)
+#define my_atomic_rwlock_rdlock(name)
+#define my_atomic_rwlock_wrlock(name)
+#define my_atomic_rwlock_rdunlock(name)
+#define my_atomic_rwlock_wrunlock(name)
+
+#endif
+
+#endif /* ATOMIC_NOLOCK_INCLUDED */
--- /dev/null
+++ b/include/atomic/rwlock.h
@@ -0,0 +1,100 @@
+#ifndef ATOMIC_RWLOCK_INCLUDED
+#define ATOMIC_RWLOCK_INCLUDED
+
+/* Copyright (C) 2006 MySQL AB, 2009 Sun Microsystems, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+
+#define MY_ATOMIC_MODE_RWLOCKS 1
+
+#ifdef MY_ATOMIC_MODE_DUMMY
+/*
+  the following can never be enabled by ./configure, one need to put #define in
+  a source to trigger the following warning. The resulting code will be broken,
+  it only makes sense to do it to see now test_atomic detects broken
+  implementations (another way is to run a UP build on an SMP box).
+*/
+#warning MY_ATOMIC_MODE_DUMMY and MY_ATOMIC_MODE_RWLOCKS are incompatible
+
+typedef char my_atomic_rwlock_t;
+
+#define my_atomic_rwlock_destroy(name)
+#define my_atomic_rwlock_init(name)
+#define my_atomic_rwlock_rdlock(name)
+#define my_atomic_rwlock_wrlock(name)
+#define my_atomic_rwlock_rdunlock(name)
+#define my_atomic_rwlock_wrunlock(name)
+#define MY_ATOMIC_MODE "dummy (non-atomic)"
+#else /* not MY_ATOMIC_MODE_DUMMY */
+
+typedef struct {pthread_mutex_t rw;} my_atomic_rwlock_t;
+
+#ifndef SAFE_MUTEX
+
+/*
+  we're using read-write lock macros but map them to mutex locks, and they're
+  faster. Still, having semantically rich API we can change the
+  underlying implementation, if necessary.
+*/
+#define my_atomic_rwlock_destroy(name)     pthread_mutex_destroy(& (name)->rw)
+#define my_atomic_rwlock_init(name)        pthread_mutex_init(& (name)->rw, 0)
+#define my_atomic_rwlock_rdlock(name)      pthread_mutex_lock(& (name)->rw)
+#define my_atomic_rwlock_wrlock(name)      pthread_mutex_lock(& (name)->rw)
+#define my_atomic_rwlock_rdunlock(name)    pthread_mutex_unlock(& (name)->rw)
+#define my_atomic_rwlock_wrunlock(name)    pthread_mutex_unlock(& (name)->rw)
+
+#else /* SAFE_MUTEX */
+
+/*
+  SAFE_MUTEX pollutes the compiling name space with macros
+  that alter pthread_mutex_t, pthread_mutex_init, etc.
+  Atomic operations should never use the safe mutex wrappers.
+  Unfortunately, there is no way to have both:
+  - safe mutex macros expanding pthread_mutex_lock to safe_mutex_lock
+  - my_atomic macros expanding to unmodified pthread_mutex_lock
+  inlined in the same compilation unit.
+  So, in case of SAFE_MUTEX, a function call is required.
+  Given that SAFE_MUTEX is a debugging facility,
+  this extra function call is not a performance concern for
+  production builds.
+*/
+C_MODE_START
+extern void plain_pthread_mutex_init(safe_mutex_t *);
+extern void plain_pthread_mutex_destroy(safe_mutex_t *);
+extern void plain_pthread_mutex_lock(safe_mutex_t *);
+extern void plain_pthread_mutex_unlock(safe_mutex_t *);
+C_MODE_END
+
+#define my_atomic_rwlock_destroy(name)     plain_pthread_mutex_destroy(&(name)->rw)
+#define my_atomic_rwlock_init(name)        plain_pthread_mutex_init(&(name)->rw)
+#define my_atomic_rwlock_rdlock(name)      plain_pthread_mutex_lock(&(name)->rw)
+#define my_atomic_rwlock_wrlock(name)      plain_pthread_mutex_lock(&(name)->rw)
+#define my_atomic_rwlock_rdunlock(name)    plain_pthread_mutex_unlock(&(name)->rw)
+#define my_atomic_rwlock_wrunlock(name)    plain_pthread_mutex_unlock(&(name)->rw)
+
+#endif /* SAFE_MUTEX */
+
+#define MY_ATOMIC_MODE "mutex"
+#ifndef MY_ATOMIC_MODE_RWLOCKS
+#define MY_ATOMIC_MODE_RWLOCKS 1
+#endif
+#endif
+
+#define make_atomic_add_body(S)     int ## S sav; sav= *a; *a+= v; v=sav;
+#define make_atomic_fas_body(S)     int ## S sav; sav= *a; *a= v; v=sav;
+#define make_atomic_cas_body(S)     if ((ret= (*a == *cmp))) *a= set; else *cmp=*a;
+#define make_atomic_load_body(S)    ret= *a;
+#define make_atomic_store_body(S)   *a= v;
+
+#endif /* ATOMIC_RWLOCK_INCLUDED */
--- /dev/null
+++ b/include/atomic/solaris.h
@@ -0,0 +1,72 @@
+/* Copyright (C) 2008 MySQL AB, 2009 Sun Microsystems, Inc
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+
+#ifndef _atomic_h_cleanup_
+#define _atomic_h_cleanup_ "atomic/solaris.h"
+
+#include <atomic.h>
+
+#define	MY_ATOMIC_MODE	"solaris-atomic"
+
+#if defined(__GNUC__)
+#define atomic_typeof(T,V)      __typeof__(V)
+#else
+#define atomic_typeof(T,V)      T
+#endif
+
+#define uintptr_t void *
+#define atomic_or_ptr_nv(X,Y) (void *)atomic_or_ulong_nv((volatile ulong_t *)X, Y)
+
+#define make_atomic_cas_body(S)                         \
+  atomic_typeof(uint ## S ## _t, *cmp) sav;             \
+  sav = atomic_cas_ ## S(                               \
+           (volatile uint ## S ## _t *)a,               \
+           (uint ## S ## _t)*cmp,                       \
+           (uint ## S ## _t)set);                       \
+  if (! (ret= (sav == *cmp)))                           \
+    *cmp= sav;
+
+#define make_atomic_add_body(S)                         \
+  int ## S nv;  /* new value */                         \
+  nv= atomic_add_ ## S ## _nv((volatile uint ## S ## _t *)a, v); \
+  v= nv - v
+
+/* ------------------------------------------------------------------------ */
+
+#ifdef MY_ATOMIC_MODE_DUMMY
+
+#define make_atomic_load_body(S)  ret= *a
+#define make_atomic_store_body(S)   *a= v
+
+#else /* MY_ATOMIC_MODE_DUMMY */
+
+#define make_atomic_load_body(S)                        \
+  ret= atomic_or_ ## S ## _nv((volatile uint ## S ## _t *)a, 0)
+
+#define make_atomic_store_body(S)                       \
+  (void) atomic_swap_ ## S((volatile uint ## S ## _t *)a, (uint ## S ## _t)v)
+
+#endif
+
+#define make_atomic_fas_body(S)                        \
+  v= atomic_swap_ ## S((volatile uint ## S ## _t *)a, (uint ## S ## _t)v)
+
+#else /* cleanup */
+
+#undef uintptr_t
+#undef atomic_or_ptr_nv
+
+#endif
+
--- /dev/null
+++ b/include/atomic/x86-gcc.h
@@ -0,0 +1,140 @@
+#ifndef ATOMIC_X86_GCC_INCLUDED
+#define ATOMIC_X86_GCC_INCLUDED
+
+/* Copyright (C) 2006 MySQL AB
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+
+/*
+  XXX 64-bit atomic operations can be implemented using
+  cmpxchg8b, if necessary. Though I've heard that not all 64-bit
+  architectures support double-word (128-bit) cas.
+*/
+
+/*
+  No special support of 8 and 16 bit operations are implemented here
+  currently.
+*/
+#undef MY_ATOMIC_HAS_8_AND_16
+
+#ifdef __x86_64__
+#  ifdef MY_ATOMIC_NO_XADD
+#    define MY_ATOMIC_MODE "gcc-amd64" LOCK_prefix "-no-xadd"
+#  else
+#    define MY_ATOMIC_MODE "gcc-amd64" LOCK_prefix
+#  endif
+#else
+#  ifdef MY_ATOMIC_NO_XADD
+#    define MY_ATOMIC_MODE "gcc-x86" LOCK_prefix "-no-xadd"
+#  else
+#    define MY_ATOMIC_MODE "gcc-x86" LOCK_prefix
+#  endif
+#endif
+
+/* fix -ansi errors while maintaining readability */
+#ifndef asm
+#define asm __asm__
+#endif
+
+#ifndef MY_ATOMIC_NO_XADD
+#define make_atomic_add_body(S)         make_atomic_add_body ## S
+#define make_atomic_cas_body(S)         make_atomic_cas_body ## S
+#endif
+
+#define make_atomic_add_body32                                  \
+  asm volatile (LOCK_prefix "; xadd %0, %1;"                    \
+                : "+r" (v), "=m" (*a)                           \
+                : "m" (*a)                                      \
+                : "memory")
+
+#define make_atomic_cas_body32                                  \
+  __typeof__(*cmp) sav;                                         \
+  asm volatile (LOCK_prefix "; cmpxchg %3, %0; setz %2;"	\
+                : "=m" (*a), "=a" (sav), "=q" (ret)             \
+                : "r" (set), "m" (*a), "a" (*cmp)               \
+                : "memory");                                    \
+  if (!ret)                                                     \
+    *cmp= sav
+
+#ifdef __x86_64__
+#define make_atomic_add_body64 make_atomic_add_body32
+#define make_atomic_cas_body64 make_atomic_cas_body32
+
+#define make_atomic_fas_body(S)                                 \
+  asm volatile ("xchg %0, %1;"                                  \
+                : "+r" (v), "=m" (*a)                           \
+                : "m" (*a)                                      \
+                : "memory")
+
+/*
+  Actually 32/64-bit reads/writes are always atomic on x86_64,
+  nonetheless issue memory barriers as appropriate.
+*/
+#define make_atomic_load_body(S)                                \
+  /* Serialize prior load and store operations. */              \
+  asm volatile ("mfence" ::: "memory");                         \
+  ret= *a;                                                      \
+  /* Prevent compiler from reordering instructions. */          \
+  asm volatile ("" ::: "memory")
+#define make_atomic_store_body(S)                               \
+  asm volatile ("; xchg %0, %1;"                                \
+                : "=m" (*a), "+r" (v)                           \
+                : "m" (*a)                                      \
+                : "memory")
+
+#else
+/*
+  Use default implementations of 64-bit operations since we solved
+  the 64-bit problem on 32-bit platforms for CAS, no need to solve it
+  once more for ADD, LOAD, STORE and FAS as well.
+  Since we already added add32 support, we need to define add64
+  here, but we haven't defined fas, load and store at all, so
+  we can fallback on default implementations.
+*/
+#define make_atomic_add_body64                                  \
+  int64 tmp=*a;                                                 \
+  while (!my_atomic_cas64(a, &tmp, tmp+v)) ;                    \
+  v=tmp;
+
+/*
+  cmpxchg8b works on both 32-bit platforms and 64-bit platforms but
+  the code here is only used on 32-bit platforms, on 64-bit
+  platforms the much simpler make_atomic_cas_body32 will work
+  fine.
+*/
+#define make_atomic_cas_body64                                              \
+  asm volatile ("movl %%edi, -4(%%esp);"                                    \
+                "leal %0, %%edi;"                                           \
+                "xchgl %%ebx, %%esi;"                                       \
+                LOCK_prefix "; cmpxchg8b (%%edi);"                          \
+                "movl %%esi, %%ebx;"                                        \
+                "movl -4(%%esp), %%edi;"                                    \
+                "setz %1;"                                                  \
+                : "+m" (*a), "=q" (ret), "+A" (*cmp)                        \
+                : "S" ((int32)(set & 0xFFFFFFFF)), "c" ((int32)(set >> 32)) \
+                : "memory", "flags")
+#endif
+
+/*
+  The implementation of make_atomic_cas_body32 is adaptable to
+  the OS word size, so on 64-bit platforms it will automatically
+  adapt to 64-bits and so it will work also on 64-bit platforms
+*/
+#define make_atomic_cas_bodyptr make_atomic_cas_body32
+
+#ifdef MY_ATOMIC_MODE_DUMMY
+#define make_atomic_load_body(S)   ret=*a
+#define make_atomic_store_body(S)  *a=v
+#endif
+#endif /* ATOMIC_X86_GCC_INCLUDED */
--- /dev/null
+++ b/mysys/my_atomic.c
@@ -0,0 +1,289 @@
+#ifndef MY_ATOMIC_INCLUDED
+#define MY_ATOMIC_INCLUDED
+
+/* Copyright (C) 2006 MySQL AB
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+
+/*
+  This header defines five atomic operations:
+
+  my_atomic_add#(&var, what)
+    'Fetch and Add'
+    add 'what' to *var, and return the old value of *var
+
+  my_atomic_fas#(&var, what)
+    'Fetch And Store'
+    store 'what' in *var, and return the old value of *var
+
+  my_atomic_cas#(&var, &old, new)
+    An odd variation of 'Compare And Set/Swap'
+    if *var is equal to *old, then store 'new' in *var, and return TRUE
+    otherwise store *var in *old, and return FALSE
+    Usually, &old should not be accessed if the operation is successful.
+
+  my_atomic_load#(&var)
+    return *var
+
+  my_atomic_store#(&var, what)
+    store 'what' in *var
+
+  '#' is substituted by a size suffix - 8, 16, 32, 64, or ptr
+  (e.g. my_atomic_add8, my_atomic_fas32, my_atomic_casptr).
+
+  NOTE This operations are not always atomic, so they always must be
+  enclosed in my_atomic_rwlock_rdlock(lock)/my_atomic_rwlock_rdunlock(lock)
+  or my_atomic_rwlock_wrlock(lock)/my_atomic_rwlock_wrunlock(lock).
+  Hint: if a code block makes intensive use of atomic ops, it make sense
+  to take/release rwlock once for the whole block, not for every statement.
+
+  On architectures where these operations are really atomic, rwlocks will
+  be optimized away.
+  8- and 16-bit atomics aren't implemented for windows (see generic-msvc.h),
+  but can be added, if necessary. 
+*/
+
+#include "my_global.h"
+
+#ifndef my_atomic_rwlock_init
+
+#define intptr         void *
+/**
+  Currently we don't support 8-bit and 16-bit operations.
+  It can be added later if needed.
+*/
+#undef MY_ATOMIC_HAS_8_16
+
+#ifndef MY_ATOMIC_MODE_RWLOCKS
+/*
+ * Attempt to do atomic ops without locks
+ */
+#include "atomic/nolock.h"
+#endif
+
+#ifndef make_atomic_cas_body
+/* nolock.h was not able to generate even a CAS function, fall back */
+#include "atomic/rwlock.h"
+#endif
+
+/* define missing functions by using the already generated ones */
+#ifndef make_atomic_add_body
+#define make_atomic_add_body(S)                                 \
+  int ## S tmp=*a;                                              \
+  while (!my_atomic_cas ## S(a, &tmp, tmp+v)) ;                 \
+  v=tmp;
+#endif
+#ifndef make_atomic_fas_body
+#define make_atomic_fas_body(S)                                 \
+  int ## S tmp=*a;                                              \
+  while (!my_atomic_cas ## S(a, &tmp, v)) ;                     \
+  v=tmp;
+#endif
+#ifndef make_atomic_load_body
+#define make_atomic_load_body(S)                                \
+  ret= 0; /* avoid compiler warning */                          \
+  (void)(my_atomic_cas ## S(a, &ret, ret));
+#endif
+#ifndef make_atomic_store_body
+#define make_atomic_store_body(S)                               \
+  (void)(my_atomic_fas ## S (a, v));
+#endif
+
+/*
+  transparent_union doesn't work in g++
+  Bug ?
+
+  Darwin's gcc doesn't want to put pointers in a transparent_union
+  when built with -arch ppc64. Complains:
+  warning: 'transparent_union' attribute ignored
+*/
+#if defined(__GNUC__) && !defined(__cplusplus) && \
+      ! (defined(__APPLE__) && (defined(_ARCH_PPC64) ||defined (_ARCH_PPC)))
+/*
+  we want to be able to use my_atomic_xxx functions with
+  both signed and unsigned integers. But gcc will issue a warning
+  "passing arg N of `my_atomic_XXX' as [un]signed due to prototype"
+  if the signedness of the argument doesn't match the prototype, or
+  "pointer targets in passing argument N of my_atomic_XXX differ in signedness"
+  if int* is used where uint* is expected (or vice versa).
+  Let's shut these warnings up
+*/
+#define make_transparent_unions(S)                              \
+        typedef union {                                         \
+          int  ## S  i;                                         \
+          uint ## S  u;                                         \
+        } U_ ## S   __attribute__ ((transparent_union));        \
+        typedef union {                                         \
+          int  ## S volatile *i;                                \
+          uint ## S volatile *u;                                \
+        } Uv_ ## S   __attribute__ ((transparent_union));
+#define uintptr intptr
+make_transparent_unions(8)
+make_transparent_unions(16)
+make_transparent_unions(32)
+make_transparent_unions(64)
+make_transparent_unions(ptr)
+#undef uintptr
+#undef make_transparent_unions
+#define a       U_a.i
+#define cmp     U_cmp.i
+#define v       U_v.i
+#define set     U_set.i
+#else
+#define U_8    int8
+#define U_16   int16
+#define U_32   int32
+#define U_64   int64
+#define U_ptr  intptr
+#define Uv_8   int8
+#define Uv_16  int16
+#define Uv_32  int32
+#define Uv_64  int64
+#define Uv_ptr intptr
+#define U_a    volatile *a
+#define U_cmp  *cmp
+#define U_v    v
+#define U_set  set
+#endif /* __GCC__ transparent_union magic */
+
+#define make_atomic_cas(S)                                      \
+static inline int my_atomic_cas ## S(Uv_ ## S U_a,              \
+                            Uv_ ## S U_cmp, U_ ## S U_set)      \
+{                                                               \
+  int8 ret;                                                     \
+  make_atomic_cas_body(S);                                      \
+  return ret;                                                   \
+}
+
+#define make_atomic_add(S)                                      \
+static inline int ## S my_atomic_add ## S(                      \
+                        Uv_ ## S U_a, U_ ## S U_v)              \
+{                                                               \
+  make_atomic_add_body(S);                                      \
+  return v;                                                     \
+}
+
+#define make_atomic_fas(S)                                      \
+static inline int ## S my_atomic_fas ## S(                      \
+                         Uv_ ## S U_a, U_ ## S U_v)             \
+{                                                               \
+  make_atomic_fas_body(S);                                      \
+  return v;                                                     \
+}
+
+#define make_atomic_load(S)                                     \
+static inline int ## S my_atomic_load ## S(Uv_ ## S U_a)        \
+{                                                               \
+  int ## S ret;                                                 \
+  make_atomic_load_body(S);                                     \
+  return ret;                                                   \
+}
+
+#define make_atomic_store(S)                                    \
+static inline void my_atomic_store ## S(                        \
+                     Uv_ ## S U_a, U_ ## S U_v)                 \
+{                                                               \
+  make_atomic_store_body(S);                                    \
+}
+
+#ifdef MY_ATOMIC_HAS_8_16
+make_atomic_cas(8)
+make_atomic_cas(16)
+#endif
+make_atomic_cas(32)
+make_atomic_cas(64)
+make_atomic_cas(ptr)
+
+#ifdef MY_ATOMIC_HAS_8_16
+make_atomic_add(8)
+make_atomic_add(16)
+#endif
+make_atomic_add(32)
+make_atomic_add(64)
+
+#ifdef MY_ATOMIC_HAS_8_16
+make_atomic_load(8)
+make_atomic_load(16)
+#endif
+make_atomic_load(32)
+make_atomic_load(64)
+make_atomic_load(ptr)
+
+#ifdef MY_ATOMIC_HAS_8_16
+make_atomic_fas(8)
+make_atomic_fas(16)
+#endif
+make_atomic_fas(32)
+make_atomic_fas(64)
+make_atomic_fas(ptr)
+
+#ifdef MY_ATOMIC_HAS_8_16
+make_atomic_store(8)
+make_atomic_store(16)
+#endif
+make_atomic_store(32)
+make_atomic_store(64)
+make_atomic_store(ptr)
+
+#ifdef _atomic_h_cleanup_
+#include _atomic_h_cleanup_
+#undef _atomic_h_cleanup_
+#endif
+
+#undef U_8
+#undef U_16
+#undef U_32
+#undef U_64
+#undef U_ptr
+#undef Uv_8
+#undef Uv_16
+#undef Uv_32
+#undef Uv_64
+#undef Uv_ptr
+#undef a
+#undef cmp
+#undef v
+#undef set
+#undef U_a
+#undef U_cmp
+#undef U_v
+#undef U_set
+#undef make_atomic_add
+#undef make_atomic_cas
+#undef make_atomic_load
+#undef make_atomic_store
+#undef make_atomic_fas
+#undef make_atomic_add_body
+#undef make_atomic_cas_body
+#undef make_atomic_load_body
+#undef make_atomic_store_body
+#undef make_atomic_fas_body
+#undef intptr
+
+/*
+  the macro below defines (as an expression) the code that
+  will be run in spin-loops. Intel manuals recummend to have PAUSE there.
+  It is expected to be defined in include/atomic/ *.h files
+*/
+#ifndef LF_BACKOFF
+#define LF_BACKOFF (1)
+#endif
+
+#define MY_ATOMIC_OK       0
+#define MY_ATOMIC_NOT_1CPU 1
+extern int my_atomic_initialize();
+
+#endif
+
+#endif /* MY_ATOMIC_INCLUDED */
