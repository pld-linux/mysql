--- a/include/my_sys.h
+++ b/include/my_sys.h
@@ -346,8 +346,8 @@
 typedef struct st_dynamic_array
 {
   uchar *buffer;
-  uint elements,max_element;
-  uint alloc_increment;
+  ulong elements, max_element;
+  ulong alloc_increment;
   uint size_of_element;
 } DYNAMIC_ARRAY;
 
@@ -809,23 +809,23 @@
 #define my_init_dynamic_array2(A,B,C,D,E) init_dynamic_array2(A,B,C,D,E CALLER_INFO)
 #define my_init_dynamic_array2_ci(A,B,C,D,E) init_dynamic_array2(A,B,C,D,E ORIG_CALLER_INFO)
 extern my_bool init_dynamic_array2(DYNAMIC_ARRAY *array,uint element_size,
-                                   void *init_buffer, uint init_alloc, 
-                                   uint alloc_increment
+                                   void *init_buffer, ulong init_alloc,
+                                   ulong alloc_increment
                                    CALLER_INFO_PROTO);
 /* init_dynamic_array() function is deprecated */
 extern my_bool init_dynamic_array(DYNAMIC_ARRAY *array,uint element_size,
-                                  uint init_alloc,uint alloc_increment
+                                  ulong init_alloc, ulong alloc_increment
                                   CALLER_INFO_PROTO);
 extern my_bool insert_dynamic(DYNAMIC_ARRAY *array,uchar * element);
 extern uchar *alloc_dynamic(DYNAMIC_ARRAY *array);
 extern uchar *pop_dynamic(DYNAMIC_ARRAY*);
-extern my_bool set_dynamic(DYNAMIC_ARRAY *array,uchar * element,uint array_index);
-extern my_bool allocate_dynamic(DYNAMIC_ARRAY *array, uint max_elements);
-extern void get_dynamic(DYNAMIC_ARRAY *array,uchar * element,uint array_index);
+extern my_bool set_dynamic(DYNAMIC_ARRAY *array, uchar * element, ulong array_index);
+extern my_bool allocate_dynamic(DYNAMIC_ARRAY *array, ulong max_elements);
+extern void get_dynamic(DYNAMIC_ARRAY *array, uchar * element, ulong array_index);
 extern void delete_dynamic(DYNAMIC_ARRAY *array);
-extern void delete_dynamic_element(DYNAMIC_ARRAY *array, uint array_index);
+extern void delete_dynamic_element(DYNAMIC_ARRAY *array, ulong array_index);
 extern void freeze_size(DYNAMIC_ARRAY *array);
-extern int  get_index_dynamic(DYNAMIC_ARRAY *array, uchar * element);
+extern long get_index_dynamic(DYNAMIC_ARRAY *array, uchar * element);
 #define dynamic_array_ptr(array,array_index) ((array)->buffer+(array_index)*(array)->size_of_element)
 #define dynamic_element(array,array_index,type) ((type)((array)->buffer) +(array_index))
 #define push_dynamic(A,B) insert_dynamic((A),(B))
--- a/mysys/array.c
+++ b/mysys/array.c
@@ -44,8 +44,8 @@
 */
 
 my_bool init_dynamic_array2(DYNAMIC_ARRAY *array, uint element_size,
-                            void *init_buffer, uint init_alloc, 
-                            uint alloc_increment CALLER_INFO_PROTO)
+                            void *init_buffer, ulong init_alloc, 
+                            ulong alloc_increment CALLER_INFO_PROTO)
 {
   DBUG_ENTER("init_dynamic_array");
   if (!alloc_increment)
@@ -76,8 +76,8 @@
 } 
 
 my_bool init_dynamic_array(DYNAMIC_ARRAY *array, uint element_size,
-                           uint init_alloc, 
-                           uint alloc_increment CALLER_INFO_PROTO)
+                           ulong init_alloc,
+                           ulong alloc_increment CALLER_INFO_PROTO)
 {
   /* placeholder to preserve ABI */
   return my_init_dynamic_array_ci(array, element_size, init_alloc, 
@@ -200,7 +200,7 @@
     FALSE	Ok
 */
 
-my_bool set_dynamic(DYNAMIC_ARRAY *array, uchar* element, uint idx)
+my_bool set_dynamic(DYNAMIC_ARRAY *array, uchar* element, ulong idx)
 {
   if (idx >= array->elements)
   {
@@ -232,11 +232,11 @@
     TRUE	Allocation of new memory failed
 */
 
-my_bool allocate_dynamic(DYNAMIC_ARRAY *array, uint max_elements)
+my_bool allocate_dynamic(DYNAMIC_ARRAY *array, ulong max_elements)
 {
   if (max_elements >= array->max_element)
   {
-    uint size;
+    ulong size;
     uchar *new_ptr;
     size= (max_elements + array->alloc_increment)/array->alloc_increment;
     size*= array->alloc_increment;
@@ -277,11 +277,11 @@
       idx	Index of element wanted. 
 */
 
-void get_dynamic(DYNAMIC_ARRAY *array, uchar* element, uint idx)
+void get_dynamic(DYNAMIC_ARRAY *array, uchar* element, ulong idx)
 {
   if (idx >= array->elements)
   {
-    DBUG_PRINT("warning",("To big array idx: %d, array size is %d",
+    DBUG_PRINT("warning",("To big array idx: %lu, array size is %lu",
                           idx,array->elements));
     bzero(element,array->size_of_element);
     return;
@@ -324,7 +324,7 @@
       idx        Index of element to be deleted
 */
 
-void delete_dynamic_element(DYNAMIC_ARRAY *array, uint idx)
+void delete_dynamic_element(DYNAMIC_ARRAY *array, ulong idx)
 {
   char *ptr= (char*) array->buffer+array->size_of_element*idx;
   array->elements--;
@@ -344,7 +344,7 @@
 
 void freeze_size(DYNAMIC_ARRAY *array)
 {
-  uint elements=max(array->elements,1);
+  ulong elements= max(array->elements, 1);
 
   /*
     Do nothing if we are using a static buffer
@@ -372,7 +372,7 @@
 
 */
 
-int get_index_dynamic(DYNAMIC_ARRAY *array, uchar* element)
+long get_index_dynamic(DYNAMIC_ARRAY *array, uchar* element)
 {
   size_t ret;
   if (array->buffer > element)
--- a/storage/myisam/mi_check.c
+++ b/storage/myisam/mi_check.c
@@ -2435,7 +2435,7 @@
 
     if (_create_index_by_sort(&sort_param,
 			      (my_bool) (!(param->testflag & T_VERBOSE)),
-			      (uint) param->sort_buffer_length))
+			      param->sort_buffer_length))
     {
       param->retry_repair=1;
       goto err;
--- a/storage/myisam/myisamdef.h
+++ b/storage/myisam/myisamdef.h
@@ -347,10 +347,10 @@
   int (*key_write)(struct st_mi_sort_param *, const void *);
   void (*lock_in_memory)(MI_CHECK *);
   NEAR int (*write_keys)(struct st_mi_sort_param *, register uchar **,
-                     uint , struct st_buffpek *, IO_CACHE *);
-  NEAR uint (*read_to_buffer)(IO_CACHE *,struct st_buffpek *, uint);
+                         ulong, struct st_buffpek *, IO_CACHE *);
+  NEAR ulong (*read_to_buffer)(IO_CACHE *,struct st_buffpek *, uint);
   NEAR int (*write_key)(struct st_mi_sort_param *, IO_CACHE *,uchar *,
-                       uint, uint);
+                       uint, ulong);
 } MI_SORT_PARAM;
 
 	/* Some defines used by isam-funktions */
--- a/storage/myisam/sort.c
+++ b/storage/myisam/sort.c
@@ -47,42 +47,42 @@
 
 /* Functions defined in this file */
 
-static ha_rows NEAR_F find_all_keys(MI_SORT_PARAM *info,uint keys,
+static ha_rows NEAR_F find_all_keys(MI_SORT_PARAM *info, ulong keys,
                                     uchar **sort_keys,
-                                    DYNAMIC_ARRAY *buffpek,int *maxbuffer,
+                                    DYNAMIC_ARRAY *buffpek, long *maxbuffer,
                                     IO_CACHE *tempfile,
                                     IO_CACHE *tempfile_for_exceptions);
 static int NEAR_F write_keys(MI_SORT_PARAM *info,uchar **sort_keys,
-                             uint count, BUFFPEK *buffpek,IO_CACHE *tempfile);
+                             ulong count, BUFFPEK *buffpek,IO_CACHE *tempfile);
 static int NEAR_F write_key(MI_SORT_PARAM *info, uchar *key,
 			    IO_CACHE *tempfile);
 static int NEAR_F write_index(MI_SORT_PARAM *info,uchar * *sort_keys,
-                              uint count);
-static int NEAR_F merge_many_buff(MI_SORT_PARAM *info,uint keys,
+                              ulong count);
+static int NEAR_F merge_many_buff(MI_SORT_PARAM *info, ulong keys,
                                   uchar * *sort_keys,
-                                  BUFFPEK *buffpek,int *maxbuffer,
+                                  BUFFPEK *buffpek, long *maxbuffer,
                                   IO_CACHE *t_file);
-static uint NEAR_F read_to_buffer(IO_CACHE *fromfile,BUFFPEK *buffpek,
-                                  uint sort_length);
-static int NEAR_F merge_buffers(MI_SORT_PARAM *info,uint keys,
+static ulong NEAR_F read_to_buffer(IO_CACHE *fromfile,BUFFPEK *buffpek,
+                                   uint sort_length);
+static int NEAR_F merge_buffers(MI_SORT_PARAM *info, ulong keys,
                                 IO_CACHE *from_file, IO_CACHE *to_file,
                                 uchar * *sort_keys, BUFFPEK *lastbuff,
                                 BUFFPEK *Fb, BUFFPEK *Tb);
-static int NEAR_F merge_index(MI_SORT_PARAM *,uint,uchar **,BUFFPEK *, int,
+static int NEAR_F merge_index(MI_SORT_PARAM *, ulong, uchar **, BUFFPEK *, long,
                               IO_CACHE *);
 static int flush_ft_buf(MI_SORT_PARAM *info);
 
 static int NEAR_F write_keys_varlen(MI_SORT_PARAM *info,uchar **sort_keys,
-                                    uint count, BUFFPEK *buffpek,
+                                    ulong count, BUFFPEK *buffpek,
                                     IO_CACHE *tempfile);
-static uint NEAR_F read_to_buffer_varlen(IO_CACHE *fromfile,BUFFPEK *buffpek,
+static ulong NEAR_F read_to_buffer_varlen(IO_CACHE *fromfile,BUFFPEK *buffpek,
                                          uint sort_length);
 static int NEAR_F write_merge_key(MI_SORT_PARAM *info, IO_CACHE *to_file,
-                                  uchar *key, uint sort_length, uint count);
+                                  uchar *key, uint sort_length, ulong count);
 static int NEAR_F write_merge_key_varlen(MI_SORT_PARAM *info,
 					 IO_CACHE *to_file,
 					 uchar* key, uint sort_length,
-					 uint count);
+					 ulong count);
 static inline int
 my_var_write(MI_SORT_PARAM *info, IO_CACHE *to_file, uchar *bufs);
 
@@ -103,8 +103,9 @@
 int _create_index_by_sort(MI_SORT_PARAM *info,my_bool no_messages,
 			  ulong sortbuff_size)
 {
-  int error,maxbuffer,skr;
-  uint memavl,old_memavl,keys,sort_length;
+  int error;
+  long maxbuffer, skr;
+  ulong memavl, old_memavl, keys, sort_length;
   DYNAMIC_ARRAY buffpek;
   ha_rows records;
   uchar **sort_keys;
@@ -138,25 +139,25 @@
 
   while (memavl >= MIN_SORT_BUFFER)
   {
-    if ((records < UINT_MAX32) && 
+    if ((records < ULONG_MAX) &&
        ((my_off_t) (records + 1) * 
         (sort_length + sizeof(char*)) <= (my_off_t) memavl))
-      keys= (uint)records+1;
+      keys= (ulong) records + 1;
     else
       do
       {
 	skr=maxbuffer;
-	if (memavl < sizeof(BUFFPEK)*(uint) maxbuffer ||
-	    (keys=(memavl-sizeof(BUFFPEK)*(uint) maxbuffer)/
+        if (memavl < sizeof(BUFFPEK) * (ulong) maxbuffer ||
+            (keys = (memavl - sizeof(BUFFPEK) * (ulong) maxbuffer) /
              (sort_length+sizeof(char*))) <= 1 ||
-            keys < (uint) maxbuffer)
+            keys < (ulong) maxbuffer)
 	{
 	  mi_check_print_error(info->sort_info->param,
 			       "myisam_sort_buffer_size is too small");
 	  goto err;
 	}
       }
-      while ((maxbuffer= (int) (records/(keys-1)+1)) != skr);
+      while ((maxbuffer= (long) (records / (keys - 1) + 1)) != skr);
 
     if ((sort_keys=(uchar **)my_malloc(keys*(sort_length+sizeof(char*))+
 				       HA_FT_MAXBYTELEN, MYF(0))))
@@ -182,7 +183,7 @@
   (*info->lock_in_memory)(info->sort_info->param);/* Everything is allocated */
 
   if (!no_messages)
-    printf("  - Searching for keys, allocating buffer for %d keys\n",keys);
+    printf("  - Searching for keys, allocating buffer for %lu keys\n", keys);
 
   if ((records=find_all_keys(info,keys,sort_keys,&buffpek,&maxbuffer,
                                   &tempfile,&tempfile_for_exceptions))
@@ -192,7 +193,7 @@
   {
     if (!no_messages)
       printf("  - Dumping %lu keys\n", (ulong) records);
-    if (write_index(info,sort_keys, (uint) records))
+    if (write_index(info,sort_keys, (ulong) records))
       goto err; /* purecov: inspected */
   }
   else
@@ -256,13 +257,13 @@
 
 /* Search after all keys and place them in a temp. file */
 
-static ha_rows NEAR_F find_all_keys(MI_SORT_PARAM *info, uint keys,
+static ha_rows NEAR_F find_all_keys(MI_SORT_PARAM *info, ulong keys,
 				    uchar **sort_keys, DYNAMIC_ARRAY *buffpek,
-				    int *maxbuffer, IO_CACHE *tempfile,
+				    long *maxbuffer, IO_CACHE *tempfile,
 				    IO_CACHE *tempfile_for_exceptions)
 {
   int error;
-  uint idx;
+  ulong idx;
   DBUG_ENTER("find_all_keys");
 
   idx=error=0;
@@ -312,8 +313,8 @@
 {
   MI_SORT_PARAM *sort_param= (MI_SORT_PARAM*) arg;
   int error;
-  uint memavl,old_memavl,keys,sort_length;
-  uint idx, maxbuffer;
+  ulong memavl,old_memavl,keys,sort_length;
+  ulong idx, maxbuffer;
   uchar **sort_keys=0;
 
   LINT_INIT(keys);
@@ -349,7 +350,7 @@
     sort_keys= (uchar **) NULL;
 
     memavl=       max(sort_param->sortbuff_size, MIN_SORT_BUFFER);
-    idx=          (uint)sort_param->sort_info->max_records;
+    idx=          (ulong) sort_param->sort_info->max_records;
     sort_length=  sort_param->key_length;
     maxbuffer=    1;
 
@@ -360,21 +361,21 @@
         keys= idx+1;
       else
       {
-        uint skr;
+        ulong skr;
         do
         {
           skr= maxbuffer;
           if (memavl < sizeof(BUFFPEK)*maxbuffer ||
               (keys=(memavl-sizeof(BUFFPEK)*maxbuffer)/
                (sort_length+sizeof(char*))) <= 1 ||
-              keys < (uint) maxbuffer)
+              keys < maxbuffer)
           {
             mi_check_print_error(sort_param->sort_info->param,
                                  "myisam_sort_buffer_size is too small");
             goto err;
           }
         }
-        while ((maxbuffer= (int) (idx/(keys-1)+1)) != skr);
+        while ((maxbuffer= (idx/(keys-1)+1)) != skr);
       }
       if ((sort_keys= (uchar**)
            my_malloc(keys*(sort_length+sizeof(char*))+
@@ -403,7 +404,7 @@
     }
 
     if (sort_param->sort_info->param->testflag & T_VERBOSE)
-      printf("Key %d - Allocating buffer for %d keys\n",
+      printf("Key %d - Allocating buffer for %lu keys\n",
              sort_param->key + 1, keys);
     sort_param->sort_keys= sort_keys;
 
@@ -560,7 +561,7 @@
     }
     if (sinfo->buffpek.elements)
     {
-      uint maxbuffer=sinfo->buffpek.elements-1;
+      ulong maxbuffer=sinfo->buffpek.elements-1;
       if (!mergebuf)
       {
         length=param->sort_buffer_length;
@@ -583,7 +584,7 @@
           printf("Key %d  - Merging %u keys\n",sinfo->key+1, sinfo->keys);
         if (merge_many_buff(sinfo, keys, (uchar **)mergebuf,
 			    dynamic_element(&sinfo->buffpek, 0, BUFFPEK *),
-			    (int*) &maxbuffer, &sinfo->tempfile))
+			    (long *) &maxbuffer, &sinfo->tempfile))
         {
           got_error=1;
           continue;
@@ -648,7 +649,7 @@
         /* Write all keys in memory to file for later merge */
 
 static int NEAR_F write_keys(MI_SORT_PARAM *info, register uchar **sort_keys,
-                             uint count, BUFFPEK *buffpek, IO_CACHE *tempfile)
+                             ulong count, BUFFPEK *buffpek, IO_CACHE *tempfile)
 {
   uchar **end;
   uint sort_length=info->key_length;
@@ -690,7 +691,7 @@
 
 static int NEAR_F write_keys_varlen(MI_SORT_PARAM *info,
 				    register uchar **sort_keys,
-                                    uint count, BUFFPEK *buffpek,
+                                    ulong count, BUFFPEK *buffpek,
 				    IO_CACHE *tempfile)
 {
   uchar **end;
@@ -736,7 +737,7 @@
 /* Write index */
 
 static int NEAR_F write_index(MI_SORT_PARAM *info, register uchar **sort_keys,
-                              register uint count)
+                              register ulong count)
 {
   DBUG_ENTER("write_index");
 
@@ -753,11 +754,11 @@
 
         /* Merge buffers to make < MERGEBUFF2 buffers */
 
-static int NEAR_F merge_many_buff(MI_SORT_PARAM *info, uint keys,
+static int NEAR_F merge_many_buff(MI_SORT_PARAM *info, ulong keys,
                                   uchar **sort_keys, BUFFPEK *buffpek,
-                                  int *maxbuffer, IO_CACHE *t_file)
+                                  long *maxbuffer, IO_CACHE *t_file)
 {
-  register int i;
+  register long i;
   IO_CACHE t_file2, *from_file, *to_file, *temp;
   BUFFPEK *lastbuff;
   DBUG_ENTER("merge_many_buff");
@@ -787,7 +788,7 @@
     if (flush_io_cache(to_file))
       break;                                    /* purecov: inspected */
     temp=from_file; from_file=to_file; to_file=temp;
-    *maxbuffer= (int) (lastbuff-buffpek)-1;
+    *maxbuffer= (long) (lastbuff-buffpek)-1;
   }
 cleanup:
   close_cached_file(to_file);                   /* This holds old result */
@@ -816,17 +817,17 @@
     -1	Error
 */
 
-static uint NEAR_F read_to_buffer(IO_CACHE *fromfile, BUFFPEK *buffpek,
-                                  uint sort_length)
+static ulong NEAR_F read_to_buffer(IO_CACHE *fromfile, BUFFPEK *buffpek,
+                                   uint sort_length)
 {
-  register uint count;
-  uint length;
+  register ulong count;
+  ulong length;
 
-  if ((count=(uint) min((ha_rows) buffpek->max_keys,buffpek->count)))
+  if ((count=(ulong) min((ha_rows) buffpek->max_keys,buffpek->count)))
   {
     if (my_pread(fromfile->file,(uchar*) buffpek->base,
                  (length= sort_length*count),buffpek->file_pos,MYF_RW))
-      return((uint) -1);                        /* purecov: inspected */
+      return((ulong) -1);                        /* purecov: inspected */
     buffpek->key=buffpek->base;
     buffpek->file_pos+= length;                 /* New filepos */
     buffpek->count-=    count;
@@ -835,15 +836,15 @@
   return (count*sort_length);
 } /* read_to_buffer */
 
-static uint NEAR_F read_to_buffer_varlen(IO_CACHE *fromfile, BUFFPEK *buffpek,
-                                         uint sort_length)
+static ulong NEAR_F read_to_buffer_varlen(IO_CACHE *fromfile, BUFFPEK *buffpek,
+                                          uint sort_length)
 {
-  register uint count;
+  register ulong count;
   uint16 length_of_key = 0;
-  uint idx;
+  ulong idx;
   uchar *buffp;
 
-  if ((count=(uint) min((ha_rows) buffpek->max_keys,buffpek->count)))
+  if ((count= (ulong) min((ha_rows) buffpek->max_keys,buffpek->count)))
   {
     buffp = buffpek->base;
 
@@ -851,11 +852,11 @@
     {
       if (my_pread(fromfile->file,(uchar*)&length_of_key,sizeof(length_of_key),
                    buffpek->file_pos,MYF_RW))
-        return((uint) -1);
+        return((ulong) -1);
       buffpek->file_pos+=sizeof(length_of_key);
       if (my_pread(fromfile->file,(uchar*) buffp,length_of_key,
                    buffpek->file_pos,MYF_RW))
-        return((uint) -1);
+        return((ulong) -1);
       buffpek->file_pos+=length_of_key;
       buffp = buffp + sort_length;
     }
@@ -869,9 +870,9 @@
 
 static int NEAR_F write_merge_key_varlen(MI_SORT_PARAM *info,
 					 IO_CACHE *to_file, uchar* key,
-                                         uint sort_length, uint count)
+                                         uint sort_length, ulong count)
 {
-  uint idx;
+  ulong idx;
   uchar *bufs = key;
 
   for (idx=1;idx<=count;idx++)
@@ -887,7 +888,7 @@
 
 static int NEAR_F write_merge_key(MI_SORT_PARAM *info __attribute__((unused)),
 				  IO_CACHE *to_file, uchar *key,
-				  uint sort_length, uint count)
+				  uint sort_length, ulong count)
 {
   return my_b_write(to_file, key, (size_t) sort_length*count);
 }
@@ -898,12 +899,13 @@
 */
 
 static int NEAR_F
-merge_buffers(MI_SORT_PARAM *info, uint keys, IO_CACHE *from_file,
+merge_buffers(MI_SORT_PARAM *info, ulong keys, IO_CACHE *from_file,
               IO_CACHE *to_file, uchar **sort_keys, BUFFPEK *lastbuff,
               BUFFPEK *Fb, BUFFPEK *Tb)
 {
-  int error;
-  uint sort_length,maxcount;
+  ulong error;
+  uint sort_length;
+  ulong maxcount;
   ha_rows count;
   my_off_t UNINIT_VAR(to_start_filepos);
   uchar *strpos;
@@ -913,7 +915,7 @@
   DBUG_ENTER("merge_buffers");
 
   count=error=0;
-  maxcount=keys/((uint) (Tb-Fb) +1);
+  maxcount= keys / ((ulong) (Tb-Fb) + 1);
   DBUG_ASSERT(maxcount > 0);
   LINT_INIT(to_start_filepos);
   if (to_file)
@@ -921,7 +923,7 @@
   strpos=(uchar*) sort_keys;
   sort_length=info->key_length;
 
-  if (init_queue(&queue,(uint) (Tb-Fb)+1,offsetof(BUFFPEK,key),0,
+  if (init_queue(&queue, (uint) (Tb-Fb)+1, offsetof(BUFFPEK,key), 0,
                  (int (*)(void*, uchar *,uchar*)) info->key_cmp,
                  (void*) info))
     DBUG_RETURN(1); /* purecov: inspected */
@@ -931,9 +933,8 @@
     count+= buffpek->count;
     buffpek->base= strpos;
     buffpek->max_keys=maxcount;
-    strpos+= (uint) (error=(int) info->read_to_buffer(from_file,buffpek,
-                                                      sort_length));
-    if (error == -1)
+    strpos+= (error= info->read_to_buffer(from_file,buffpek, sort_length));
+    if (error == (ulong) -1)
       goto err; /* purecov: inspected */
     queue_insert(&queue,(uchar*) buffpek);
   }
@@ -965,10 +966,10 @@
       buffpek->key+=sort_length;
       if (! --buffpek->mem_count)
       {
-        if (!(error=(int) info->read_to_buffer(from_file,buffpek,sort_length)))
+        if (!(error= info->read_to_buffer(from_file,buffpek,sort_length)))
         {
           uchar *base=buffpek->base;
-          uint max_keys=buffpek->max_keys;
+          ulong max_keys=buffpek->max_keys;
 
           VOID(queue_remove(&queue,0));
 
@@ -993,7 +994,7 @@
           break;                /* One buffer have been removed */
         }
       }
-      else if (error == -1)
+      else if (error == (ulong) -1)
         goto err;               /* purecov: inspected */
       queue_replaced(&queue);   /* Top element has been replaced */
     }
@@ -1026,23 +1027,23 @@
       }
     }
   }
-  while ((error=(int) info->read_to_buffer(from_file,buffpek,sort_length)) != -1 &&
-         error != 0);
+  while ((error= info->read_to_buffer(from_file, buffpek, sort_length)) !=
+         (ulong) -1 && error != 0);
 
   lastbuff->count=count;
   if (to_file)
     lastbuff->file_pos=to_start_filepos;
 err:
   delete_queue(&queue);
-  DBUG_RETURN(error);
+  DBUG_RETURN(error != 0);
 } /* merge_buffers */
 
 
         /* Do a merge to output-file (save only positions) */
 
 static int NEAR_F
-merge_index(MI_SORT_PARAM *info, uint keys, uchar **sort_keys,
-            BUFFPEK *buffpek, int maxbuffer, IO_CACHE *tempfile)
+merge_index(MI_SORT_PARAM *info, ulong keys, uchar **sort_keys,
+            BUFFPEK *buffpek, long maxbuffer, IO_CACHE *tempfile)
 {
   DBUG_ENTER("merge_index");
   if (merge_buffers(info,keys,tempfile,(IO_CACHE*) 0,sort_keys,buffpek,buffpek,
--- /dev/null
+++ b/mysql-test/r/percona_bug45702.result
@@ -0,0 +1,21 @@
+CREATE TABLE t1 (a BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY) ENGINE=MyISAM;
+INSERT INTO t1 VALUES (), (), (), (), (), (), (), ();
+INSERT INTO t1 SELECT NULL FROM t1;
+INSERT INTO t1 SELECT NULL FROM t1;
+INSERT INTO t1 SELECT NULL FROM t1;
+INSERT INTO t1 SELECT NULL FROM t1;
+INSERT INTO t1 SELECT NULL FROM t1;
+INSERT INTO t1 SELECT NULL FROM t1;
+INSERT INTO t1 SELECT NULL FROM t1;
+INSERT INTO t1 SELECT NULL FROM t1;
+INSERT INTO t1 SELECT NULL FROM t1;
+SET @old_myisam_sort_buffer_size = @@myisam_sort_buffer_size;
+SET @@myisam_sort_buffer_size = 4 * 1024 * 1024 * 1024;
+REPAIR TABLE t1;
+Table	Op	Msg_type	Msg_text
+test.t1	repair	status	OK
+- recovering (with sort) MyISAM-table 'MYSQLD_DATADIR/test/t1'
+Data records: 4096
+- Fixing index 1
+SET @@myisam_sort_buffer_size = @old_myisam_sort_buffer_size;
+DROP TABLE t1;
--- /dev/null
+++ b/mysql-test/t/percona_bug45702.test
@@ -0,0 +1,34 @@
+###############################################################################
+# Bug #45702: Impossible to specify myisam_sort_buffer > 4GB on 64 bit machines
+###############################################################################
+
+--source include/have_64bit.inc
+
+# Check that having data larger than MIN_SORT_BUFFER bytes can be handled by
+# _create_index_by_sort() with myisam_sort_buffer_size = 4 GB without errors.
+# The full test with large data volumes can not be a part of the test suite.
+
+CREATE TABLE t1 (a BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY) ENGINE=MyISAM;
+INSERT INTO t1 VALUES (), (), (), (), (), (), (), ();
+INSERT INTO t1 SELECT NULL FROM t1;
+INSERT INTO t1 SELECT NULL FROM t1;
+INSERT INTO t1 SELECT NULL FROM t1;
+INSERT INTO t1 SELECT NULL FROM t1;
+INSERT INTO t1 SELECT NULL FROM t1;
+INSERT INTO t1 SELECT NULL FROM t1;
+INSERT INTO t1 SELECT NULL FROM t1;
+INSERT INTO t1 SELECT NULL FROM t1;
+INSERT INTO t1 SELECT NULL FROM t1;
+
+SET @old_myisam_sort_buffer_size = @@myisam_sort_buffer_size;
+SET @@myisam_sort_buffer_size = 4 * 1024 * 1024 * 1024;
+
+REPAIR TABLE t1;
+
+--let $MYSQLD_DATADIR= `select @@datadir`
+--replace_result $MYSQLD_DATADIR MYSQLD_DATADIR
+--exec $MYISAMCHK -r --sort_buffer_size=4G $MYSQLD_DATADIR/test/t1
+
+SET @@myisam_sort_buffer_size = @old_myisam_sort_buffer_size;
+
+DROP TABLE t1;
--- a/sql/opt_range.cc
+++ b/sql/opt_range.cc
@@ -11524,7 +11524,7 @@
   }
   if (min_max_ranges.elements > 0)
   {
-    fprintf(DBUG_FILE, "%*susing %d quick_ranges for MIN/MAX:\n",
+    fprintf(DBUG_FILE, "%*susing %lu quick_ranges for MIN/MAX:\n",
             indent, "", min_max_ranges.elements);
   }
 }
--- a/mysys/my_pread.c
+++ b/mysys/my_pread.c
@@ -48,6 +48,7 @@
                 myf MyFlags)
 {
   size_t readbytes;
+  size_t total_readbytes= 0;
   int error= 0;
   DBUG_ENTER("my_pread");
   DBUG_PRINT("my",("Fd: %d  Seek: %lu  Buffer: 0x%lx  Count: %u  MyFlags: %d",
@@ -68,6 +69,9 @@
     if ((error= ((readbytes= pread(Filedes, Buffer, Count, offset)) != Count)))
       my_errno= errno ? errno : -1;
 #endif
+    if (readbytes > 0)
+      total_readbytes+= readbytes;
+
     if (error || readbytes != Count)
     {
       DBUG_PRINT("warning",("Read only %d bytes off %u from %d, errno: %d",
@@ -80,6 +84,24 @@
         continue;                              /* Interrupted */
       }
 #endif
+      if (readbytes > 0 && readbytes < Count && errno == 0)
+      {
+        /*
+          pread() may return less bytes than requested even if enough bytes are
+          available according to the Linux man page.
+          This makes determining the end-of-file condition a bit harder.
+          We just do another pread() call to see if more bytes can be read,
+          since all my_pread() users expect it to always return all available
+          bytes. For end-of-file 0 bytes is returned. This can never be the case
+          for a partial read, since according to the man page, -1 is returned
+          with errno set to EINTR if no data has been read.
+        */
+        Buffer+= readbytes;
+        offset+= readbytes;
+        Count-= readbytes;
+
+        continue;
+      }
       if (MyFlags & (MY_WME | MY_FAE | MY_FNABP))
       {
 	if (readbytes == (size_t) -1)
@@ -94,7 +116,7 @@
     }
     if (MyFlags & (MY_NABP | MY_FNABP))
       DBUG_RETURN(0);				/* Read went ok; Return 0 */
-    DBUG_RETURN(readbytes);			/* purecov: inspected */
+    DBUG_RETURN(total_readbytes);			/* purecov: inspected */
   }
 } /* my_pread */
 
