# name       : innodb_pass_corrupt_table.patch
# introduced : 11 or before
# maintainer : Yasufumi
#
#!!! notice !!!
# Any small change to this file in the main branch
# should be done or reviewed by the maintainer!
diff -ruN a/storage/innodb_plugin/btr/btr0btr.c b/storage/innodb_plugin/btr/btr0btr.c
--- a/storage/innodb_plugin/btr/btr0btr.c	2010-08-04 02:24:19.000000000 +0900
+++ b/storage/innodb_plugin/btr/btr0btr.c	2010-08-27 16:39:02.932248156 +0900
@@ -137,6 +137,12 @@
 	root_page_no = dict_index_get_page(index);
 
 	block = btr_block_get(space, zip_size, root_page_no, RW_X_LATCH, mtr);
+
+	if (srv_pass_corrupt_table && !block) {
+		return(0);
+	}
+	ut_a(block);
+
 	ut_a((ibool)!!page_is_comp(buf_block_get_frame(block))
 	     == dict_table_is_comp(index->table));
 #ifdef UNIV_BTR_DEBUG
@@ -422,6 +428,12 @@
 
 	root = btr_root_get(index, &mtr);
 
+	if (srv_pass_corrupt_table && !root) {
+		mtr_commit(&mtr);
+		return(0);
+	}
+	ut_a(root);
+
 	if (flag == BTR_N_LEAF_PAGES) {
 		seg_header = root + PAGE_HEADER + PAGE_BTR_SEG_LEAF;
 
@@ -868,6 +880,13 @@
 	mtr_start(&mtr);
 
 	root = btr_page_get(space, zip_size, root_page_no, RW_X_LATCH, &mtr);
+
+	if (srv_pass_corrupt_table && !root) {
+		mtr_commit(&mtr);
+		return;
+	}
+	ut_a(root);
+	
 #ifdef UNIV_BTR_DEBUG
 	ut_a(btr_root_fseg_validate(FIL_PAGE_DATA + PAGE_BTR_SEG_LEAF
 				    + root, space));
@@ -890,6 +909,12 @@
 	mtr_start(&mtr);
 
 	root = btr_page_get(space, zip_size, root_page_no, RW_X_LATCH, &mtr);
+
+	if (srv_pass_corrupt_table && !root) {
+		mtr_commit(&mtr);
+		return;
+	}
+	ut_a(root);
 #ifdef UNIV_BTR_DEBUG
 	ut_a(btr_root_fseg_validate(FIL_PAGE_DATA + PAGE_BTR_SEG_TOP
 				    + root, space));
@@ -923,6 +948,11 @@
 
 	block = btr_block_get(space, zip_size, root_page_no, RW_X_LATCH, mtr);
 
+	if (srv_pass_corrupt_table && !block) {
+		return;
+	}
+	ut_a(block);
+
 	btr_search_drop_page_hash_index(block);
 
 	header = buf_block_get_frame(block) + PAGE_HEADER + PAGE_BTR_SEG_TOP;
diff -ruN a/storage/innodb_plugin/btr/btr0cur.c b/storage/innodb_plugin/btr/btr0cur.c
--- a/storage/innodb_plugin/btr/btr0cur.c	2010-08-27 16:22:04.211409467 +0900
+++ b/storage/innodb_plugin/btr/btr0cur.c	2010-08-27 16:39:02.934087429 +0900
@@ -227,6 +227,11 @@
 	case BTR_MODIFY_LEAF:
 		mode = latch_mode == BTR_SEARCH_LEAF ? RW_S_LATCH : RW_X_LATCH;
 		get_block = btr_block_get(space, zip_size, page_no, mode, mtr);
+
+		if (srv_pass_corrupt_table && !get_block) {
+			return;
+		}
+		ut_a(get_block);
 #ifdef UNIV_BTR_DEBUG
 		ut_a(page_is_comp(get_block->frame) == page_is_comp(page));
 #endif /* UNIV_BTR_DEBUG */
@@ -240,6 +245,11 @@
 			get_block = btr_block_get(space, zip_size,
 						  left_page_no,
 						  RW_X_LATCH, mtr);
+
+			if (srv_pass_corrupt_table && !get_block) {
+				return;
+			}
+			ut_a(get_block);
 #ifdef UNIV_BTR_DEBUG
 			ut_a(page_is_comp(get_block->frame)
 			     == page_is_comp(page));
@@ -251,6 +261,11 @@
 
 		get_block = btr_block_get(space, zip_size, page_no,
 					  RW_X_LATCH, mtr);
+
+		if (srv_pass_corrupt_table && !get_block) {
+			return;
+		}
+		ut_a(get_block);
 #ifdef UNIV_BTR_DEBUG
 		ut_a(page_is_comp(get_block->frame) == page_is_comp(page));
 #endif /* UNIV_BTR_DEBUG */
@@ -262,6 +277,11 @@
 			get_block = btr_block_get(space, zip_size,
 						  right_page_no,
 						  RW_X_LATCH, mtr);
+
+			if (srv_pass_corrupt_table && !get_block) {
+				return;
+			}
+			ut_a(get_block);
 #ifdef UNIV_BTR_DEBUG
 			ut_a(page_is_comp(get_block->frame)
 			     == page_is_comp(page));
@@ -283,6 +303,11 @@
 			get_block = btr_block_get(space, zip_size,
 						  left_page_no, mode, mtr);
 			cursor->left_block = get_block;
+
+			if (srv_pass_corrupt_table && !get_block) {
+				return;
+			}
+			ut_a(get_block);
 #ifdef UNIV_BTR_DEBUG
 			ut_a(page_is_comp(get_block->frame)
 			     == page_is_comp(page));
@@ -293,6 +318,11 @@
 		}
 
 		get_block = btr_block_get(space, zip_size, page_no, mode, mtr);
+
+		if (srv_pass_corrupt_table && !get_block) {
+			return;
+		}
+		ut_a(get_block);
 #ifdef UNIV_BTR_DEBUG
 		ut_a(page_is_comp(get_block->frame) == page_is_comp(page));
 #endif /* UNIV_BTR_DEBUG */
@@ -524,6 +554,16 @@
 					 rw_latch, guess, buf_mode,
 					 file, line, mtr);
 		if (block == NULL) {
+			if (srv_pass_corrupt_table && buf_mode != BUF_GET_IF_IN_POOL) {
+				page_cursor->block = 0;
+				page_cursor->rec = 0;
+				if (estimate) {
+					cursor->path_arr->nth_rec = ULINT_UNDEFINED;
+				}
+				break;
+			}
+			ut_a(buf_mode == BUF_GET_IF_IN_POOL);
+
 			/* This must be a search to perform an insert;
 			try insert to the insert buffer */
 
@@ -551,6 +591,16 @@
 
 		page = buf_block_get_frame(block);
 
+		if (srv_pass_corrupt_table && !page) {
+			page_cursor->block = 0;
+			page_cursor->rec = 0;
+			if (estimate) {
+				cursor->path_arr->nth_rec = ULINT_UNDEFINED;
+			}
+			break;
+		}
+		ut_a(page);
+
 		block->check_index_page_at_flush = TRUE;
 
 		if (rw_latch != RW_NO_LATCH) {
@@ -734,6 +784,17 @@
 					 RW_NO_LATCH, NULL, BUF_GET,
 					 file, line, mtr);
 		page = buf_block_get_frame(block);
+
+		if (srv_pass_corrupt_table && !page) {
+			page_cursor->block = 0;
+			page_cursor->rec = 0;
+			if (estimate) {
+				cursor->path_arr->nth_rec = ULINT_UNDEFINED;
+			}
+			break;
+		}
+		ut_a(page);
+
 		ut_ad(0 == ut_dulint_cmp(index->id,
 					 btr_page_get_index_id(page)));
 
@@ -855,6 +916,14 @@
 					 RW_NO_LATCH, NULL, BUF_GET,
 					 file, line, mtr);
 		page = buf_block_get_frame(block);
+
+		if (srv_pass_corrupt_table && !page) {
+			page_cursor->block = 0;
+			page_cursor->rec = 0;
+			break;
+		}
+		ut_a(page);
+
 		ut_ad(0 == ut_dulint_cmp(index->id,
 					 btr_page_get_index_id(page)));
 
@@ -1171,6 +1240,12 @@
 	*big_rec = NULL;
 
 	block = btr_cur_get_block(cursor);
+
+	if (srv_pass_corrupt_table && !block) {
+		return(DB_CORRUPTION);
+	}
+	ut_a(block);
+
 	page = buf_block_get_frame(block);
 	index = cursor->index;
 	zip_size = buf_block_get_zip_size(block);
@@ -2895,6 +2970,11 @@
 
 	block = btr_cur_get_block(cursor);
 
+	if (srv_pass_corrupt_table && !block) {
+		return(DB_CORRUPTION);
+	}
+	ut_a(block);
+
 	ut_ad(page_is_leaf(buf_block_get_frame(block)));
 
 	rec = btr_cur_get_rec(cursor);
@@ -3540,6 +3620,11 @@
 
 		page = btr_cur_get_page(&cursor);
 
+		if (srv_pass_corrupt_table && !page) {
+			break;
+		}
+		ut_a(page);
+
 		supremum = page_get_supremum_rec(page);
 		if (stats_method == SRV_STATS_METHOD_IGNORE_NULLS && is_first_page) {
 			/* the cursor should be the first record of the page. */
diff -ruN a/storage/innodb_plugin/btr/btr0pcur.c b/storage/innodb_plugin/btr/btr0pcur.c
--- a/storage/innodb_plugin/btr/btr0pcur.c	2010-08-04 02:24:19.000000000 +0900
+++ b/storage/innodb_plugin/btr/btr0pcur.c	2010-08-27 16:39:02.936071298 +0900
@@ -32,7 +32,7 @@
 #include "ut0byte.h"
 #include "rem0cmp.h"
 #include "trx0trx.h"
-
+#include "srv0srv.h"
 /**************************************************************//**
 Allocates memory for a persistent cursor object and initializes the cursor.
 @return	own: persistent cursor */
@@ -102,6 +102,12 @@
 	ut_ad(cursor->latch_mode != BTR_NO_LATCHES);
 
 	block = btr_pcur_get_block(cursor);
+
+	if (srv_pass_corrupt_table && !block) {
+		return;
+	}
+	ut_a(block);
+
 	index = btr_cur_get_index(btr_pcur_get_btr_cur(cursor));
 
 	page_cursor = btr_pcur_get_page_cur(cursor);
@@ -419,6 +425,15 @@
 	next_block = btr_block_get(space, zip_size, next_page_no,
 				   cursor->latch_mode, mtr);
 	next_page = buf_block_get_frame(next_block);
+
+	if (srv_pass_corrupt_table && !next_page) {
+		btr_leaf_page_release(btr_pcur_get_block(cursor),
+				      cursor->latch_mode, mtr);
+		btr_pcur_get_page_cur(cursor)->block = 0;
+		btr_pcur_get_page_cur(cursor)->rec = 0;
+		return;
+	}
+	ut_a(next_page);
 #ifdef UNIV_BTR_DEBUG
 	ut_a(page_is_comp(next_page) == page_is_comp(page));
 	ut_a(btr_page_get_prev(next_page, mtr)
diff -ruN a/storage/innodb_plugin/btr/btr0sea.c b/storage/innodb_plugin/btr/btr0sea.c
--- a/storage/innodb_plugin/btr/btr0sea.c	2010-08-27 16:13:11.051989872 +0900
+++ b/storage/innodb_plugin/btr/btr0sea.c	2010-08-27 16:39:02.937071716 +0900
@@ -42,7 +42,7 @@
 #include "btr0pcur.h"
 #include "btr0btr.h"
 #include "ha0ha.h"
-
+#include "srv0srv.h"
 /** Flag: has the search system been enabled?
 Protected by btr_search_latch and btr_search_enabled_mutex. */
 UNIV_INTERN char		btr_search_enabled	= TRUE;
@@ -595,6 +595,11 @@
 
 	block = btr_cur_get_block(cursor);
 
+	if (srv_pass_corrupt_table && !block) {
+		return;
+	}
+	ut_a(block);
+
 	/* NOTE that the following two function calls do NOT protect
 	info or block->n_fields etc. with any semaphore, to save CPU time!
 	We cannot assume the fields are consistent when we return from
diff -ruN a/storage/innodb_plugin/buf/buf0buf.c b/storage/innodb_plugin/buf/buf0buf.c
--- a/storage/innodb_plugin/buf/buf0buf.c	2010-08-27 16:38:38.224976846 +0900
+++ b/storage/innodb_plugin/buf/buf0buf.c	2010-08-27 16:39:02.939057262 +0900
@@ -52,6 +52,7 @@
 #include "log0recv.h"
 #include "page0zip.h"
 #include "trx0trx.h"
+#include "srv0start.h"
 
 /* prototypes for new functions added to ha_innodb.cc */
 trx_t* innobase_get_trx();
@@ -895,6 +896,11 @@
 			ready = buf_flush_ready_for_replace(&block->page);
 			mutex_exit(&block->mutex);
 
+			if (block->page.is_corrupt) {
+				/* corrupt page may remain, it can be skipped */
+				break;
+			}
+
 			if (!ready) {
 
 				return(block);
@@ -1803,6 +1809,14 @@
 		return(NULL);
 	}
 
+	if (srv_pass_corrupt_table) {
+		if (bpage->is_corrupt) {
+			rw_lock_s_unlock(&page_hash_latch);
+			return(NULL);
+		}
+	}
+	ut_a(!(bpage->is_corrupt));
+
 	block_mutex = buf_page_get_mutex_enter(bpage);
 
 	rw_lock_s_unlock(&page_hash_latch);
@@ -2264,6 +2278,14 @@
 		return(NULL);
 	}
 
+	if (srv_pass_corrupt_table) {
+		if (block->page.is_corrupt) {
+			mutex_exit(block_mutex);
+			return(NULL);
+		}
+	}
+	ut_a(!(block->page.is_corrupt));
+
 	switch (buf_block_get_state(block)) {
 		buf_page_t*	bpage;
 		ibool		success;
@@ -2909,6 +2931,7 @@
 	bpage->newest_modification = 0;
 	bpage->oldest_modification = 0;
 	HASH_INVALIDATE(bpage, hash);
+	bpage->is_corrupt = FALSE;
 #ifdef UNIV_DEBUG_FILE_ACCESSES
 	bpage->file_page_was_freed = FALSE;
 #endif /* UNIV_DEBUG_FILE_ACCESSES */
@@ -3365,7 +3388,8 @@
 void
 buf_page_io_complete(
 /*=================*/
-	buf_page_t*	bpage)	/*!< in: pointer to the block in question */
+	buf_page_t*	bpage,	/*!< in: pointer to the block in question */
+	trx_t*		trx)
 {
 	enum buf_io_fix	io_type;
 	const ibool	uncompressed = (buf_page_get_state(bpage)
@@ -3443,6 +3467,7 @@
 				(ulong) bpage->offset);
 		}
 
+		if (!srv_pass_corrupt_table || !bpage->is_corrupt) {
 		/* From version 3.23.38 up we store the page checksum
 		to the 4 first bytes of the page end lsn field */
 
@@ -3484,6 +3509,19 @@
 			      REFMAN "forcing-innodb-recovery.html\n"
 			      "InnoDB: about forcing recovery.\n", stderr);
 
+			if (srv_pass_corrupt_table && !trx_sys_sys_space(bpage->space)
+			    && bpage->space < SRV_LOG_SPACE_FIRST_ID) {
+				fprintf(stderr,
+					"InnoDB: space %u will be treated as corrupt.\n",
+					bpage->space);
+				fil_space_set_corrupt(bpage->space);
+				if (trx && trx->dict_operation_lock_mode == 0) {
+					dict_table_set_corrupt_by_space(bpage->space, TRUE);
+				} else {
+					dict_table_set_corrupt_by_space(bpage->space, FALSE);
+				}
+				bpage->is_corrupt = TRUE;
+			} else
 			if (srv_force_recovery < SRV_FORCE_IGNORE_CORRUPT) {
 				fputs("InnoDB: Ending processing because of"
 				      " a corrupt database page.\n",
@@ -3491,6 +3529,7 @@
 				exit(1);
 			}
 		}
+		} /**/
 
 		if (recv_recovery_is_on()) {
 			/* Pages must be uncompressed for crash recovery. */
@@ -3500,8 +3539,11 @@
 
 		if (uncompressed && !recv_no_ibuf_operations) {
 			ibuf_merge_or_delete_for_page(
+				/* Delete possible entries, if bpage is_corrupt */
+				(srv_pass_corrupt_table && bpage->is_corrupt) ? NULL :
 				(buf_block_t*) bpage, bpage->space,
 				bpage->offset, buf_page_get_zip_size(bpage),
+				(srv_pass_corrupt_table && bpage->is_corrupt) ? FALSE :
 				TRUE);
 		}
 	}
diff -ruN a/storage/innodb_plugin/buf/buf0rea.c b/storage/innodb_plugin/buf/buf0rea.c
--- a/storage/innodb_plugin/buf/buf0rea.c	2010-08-27 16:38:38.228017562 +0900
+++ b/storage/innodb_plugin/buf/buf0rea.c	2010-08-27 16:39:02.941056860 +0900
@@ -189,12 +189,19 @@
 			      sync, space, 0, offset, 0, UNIV_PAGE_SIZE,
 			      ((buf_block_t*) bpage)->frame, bpage, trx);
 	}
+
+	if (srv_pass_corrupt_table) {
+		if (*err != DB_SUCCESS) {
+			bpage->is_corrupt = TRUE;
+		}
+	} else {
 	ut_a(*err == DB_SUCCESS);
+	}
 
 	if (sync) {
 		/* The i/o is already completed when we arrive from
 		fil_read */
-		buf_page_io_complete(bpage);
+		buf_page_io_complete(bpage, trx);
 	}
 
 	return(1);
diff -ruN a/storage/innodb_plugin/dict/dict0dict.c b/storage/innodb_plugin/dict/dict0dict.c
--- a/storage/innodb_plugin/dict/dict0dict.c	2010-08-27 16:22:04.220021017 +0900
+++ b/storage/innodb_plugin/dict/dict0dict.c	2010-08-27 16:39:02.943057100 +0900
@@ -54,6 +54,7 @@
 #include "row0merge.h"
 #include "m_ctype.h" /* my_isspace() */
 #include "ha_prototypes.h" /* innobase_strcasecmp() */
+#include "srv0start.h" /* SRV_LOG_SPACE_FIRST_ID */
 
 #include <ctype.h>
 
@@ -734,7 +735,7 @@
 
 	mutex_exit(&(dict_sys->mutex));
 
-	if (table != NULL) {
+	if (table != NULL && !table->is_corrupt) {
 		/* If table->ibd_file_missing == TRUE, this will
 		print an error message and return without doing
 		anything. */
@@ -1275,7 +1276,7 @@
 		    + dict_sys->size) > srv_dict_size_limit ) {
 		prev_table = UT_LIST_GET_PREV(table_LRU, table);
 
-		if (table == self || table->n_mysql_handles_opened)
+		if (table == self || table->n_mysql_handles_opened || table->is_corrupt)
 			goto next_loop;
 
 		cached_foreign_tables = 0;
@@ -4593,6 +4594,11 @@
 	}
 
 	do {
+		if (table->is_corrupt) {
+			ut_a(srv_pass_corrupt_table);
+			return;
+		}
+
 		if (UNIV_LIKELY
 		    (srv_force_recovery < SRV_FORCE_NO_IBUF_MERGE
 		     || (srv_force_recovery < SRV_FORCE_NO_LOG_REDO
@@ -5320,4 +5326,42 @@
 		rw_lock_free(&dict_table_stats_latches[i]);
 	}
 }
+
+/*************************************************************************
+set is_corrupt flag by space_id*/
+
+void
+dict_table_set_corrupt_by_space(
+/*============================*/
+	ulint	space_id,
+	ibool	need_mutex)
+{
+	dict_table_t*	table;
+	ibool		found = FALSE;
+
+	ut_a(!trx_sys_sys_space(space_id) && space_id < SRV_LOG_SPACE_FIRST_ID);
+
+	if (need_mutex)
+		mutex_enter(&(dict_sys->mutex));
+
+	table = UT_LIST_GET_FIRST(dict_sys->table_LRU);
+
+	while (table) {
+		if (table->space == space_id) {
+			table->is_corrupt = TRUE;
+			found = TRUE;
+		}
+
+		table = UT_LIST_GET_NEXT(table_LRU, table);
+	}
+
+	if (need_mutex)
+		mutex_exit(&(dict_sys->mutex));
+
+	if (!found) {
+		fprintf(stderr, "InnoDB: space to be marked as "
+			"crashed was not found for id %lu.\n",
+			(ulong) space_id);
+	}
+}
 #endif /* !UNIV_HOTBACKUP */
diff -ruN a/storage/innodb_plugin/dict/dict0mem.c b/storage/innodb_plugin/dict/dict0mem.c
--- a/storage/innodb_plugin/dict/dict0mem.c	2010-08-04 02:24:19.000000000 +0900
+++ b/storage/innodb_plugin/dict/dict0mem.c	2010-08-27 16:39:02.945072825 +0900
@@ -86,6 +86,8 @@
 	/* The number of transactions that are either waiting on the
 	AUTOINC lock or have been granted the lock. */
 	table->n_waiting_or_granted_auto_inc_locks = 0;
+
+	table->is_corrupt = FALSE;
 #endif /* !UNIV_HOTBACKUP */
 
 	ut_d(table->magic_n = DICT_TABLE_MAGIC_N);
diff -ruN a/storage/innodb_plugin/fil/fil0fil.c b/storage/innodb_plugin/fil/fil0fil.c
--- a/storage/innodb_plugin/fil/fil0fil.c	2010-08-27 16:38:38.234979673 +0900
+++ b/storage/innodb_plugin/fil/fil0fil.c	2010-08-27 16:39:02.947021155 +0900
@@ -223,6 +223,7 @@
 				file we have written to */
 	ibool		is_in_unflushed_spaces; /*!< TRUE if this space is
 				currently in unflushed_spaces */
+	ibool		is_corrupt;
 	UT_LIST_NODE_T(fil_space_t) space_list;
 				/*!< list of all spaces */
 	ulint		magic_n;/*!< FIL_SPACE_MAGIC_N */
@@ -1246,6 +1247,8 @@
 		    ut_fold_string(name), space);
 	space->is_in_unflushed_spaces = FALSE;
 
+	space->is_corrupt = FALSE;
+
 	UT_LIST_ADD_LAST(space_list, fil_system->space_list, space);
 
 	mutex_exit(&fil_system->mutex);
@@ -4893,6 +4896,22 @@
 	ut_a(byte_offset % OS_FILE_LOG_BLOCK_SIZE == 0);
 	ut_a((len % OS_FILE_LOG_BLOCK_SIZE) == 0);
 
+	if (srv_pass_corrupt_table && space->is_corrupt) {
+		/* should ignore i/o for the crashed space */
+		mutex_enter(&fil_system->mutex);
+		fil_node_complete_io(node, fil_system, type);
+		mutex_exit(&fil_system->mutex);
+		if (mode == OS_AIO_NORMAL) {
+			ut_a(space->purpose == FIL_TABLESPACE);
+			buf_page_io_complete(message, trx);
+		}
+		if (type == OS_FILE_READ) {
+			return(DB_TABLESPACE_DELETED);
+		} else {
+			return(DB_SUCCESS);
+		}
+	} else {
+		ut_a(!space->is_corrupt);
 #ifdef UNIV_HOTBACKUP
 	/* In ibbackup do normal i/o, not aio */
 	if (type == OS_FILE_READ) {
@@ -4907,6 +4926,8 @@
 	ret = os_aio(type, mode | wake_later, node->name, node->handle, buf,
 		     offset_low, offset_high, len, node, message, trx);
 #endif
+	} /**/
+
 	ut_a(ret);
 
 	if (mode == OS_AIO_SYNC) {
@@ -5045,7 +5066,7 @@
 
 	if (fil_node->space->purpose == FIL_TABLESPACE) {
 		srv_set_io_thread_op_info(segment, "complete io for buf page");
-		buf_page_io_complete(message);
+		buf_page_io_complete(message, NULL);
 	} else {
 		srv_set_io_thread_op_info(segment, "complete io for log");
 		log_io_complete(message);
@@ -5399,3 +5420,46 @@
                return 0;
        }
 }
+
+/*************************************************************************
+functions to access is_corrupt flag of fil_space_t*/
+
+ibool
+fil_space_is_corrupt(
+/*=================*/
+	ulint	space_id)
+{
+	fil_space_t*	space;
+	ibool		ret = FALSE;
+
+	mutex_enter(&fil_system->mutex);
+
+	space = fil_space_get_by_id(space_id);
+
+	if (space && space->is_corrupt) {
+		ret = TRUE;
+	}
+
+	mutex_exit(&fil_system->mutex);
+
+	return(ret);
+}
+
+void
+fil_space_set_corrupt(
+/*==================*/
+	ulint	space_id)
+{
+	fil_space_t*	space;
+
+	mutex_enter(&fil_system->mutex);
+
+	space = fil_space_get_by_id(space_id);
+
+	if (space) {
+		space->is_corrupt = TRUE;
+	}
+
+	mutex_exit(&fil_system->mutex);
+}
+
diff -ruN a/storage/innodb_plugin/fsp/fsp0fsp.c b/storage/innodb_plugin/fsp/fsp0fsp.c
--- a/storage/innodb_plugin/fsp/fsp0fsp.c	2010-08-27 16:38:38.240058836 +0900
+++ b/storage/innodb_plugin/fsp/fsp0fsp.c	2010-08-27 16:39:02.950021363 +0900
@@ -370,6 +370,12 @@
 	ut_ad(id || !zip_size);
 
 	block = buf_page_get(id, zip_size, 0, RW_X_LATCH, mtr);
+
+	if (srv_pass_corrupt_table && !block) {
+		return(0);
+	}
+	ut_a(block);
+
 	header = FSP_HEADER_OFFSET + buf_block_get_frame(block);
 	buf_block_dbg_add_level(block, SYNC_FSP_PAGE);
 
@@ -788,6 +794,12 @@
 	fsp_header_t*	sp_header;
 
 	block = buf_page_get(space, zip_size, 0, RW_X_LATCH, mtr);
+
+	if (srv_pass_corrupt_table && !block) {
+		return(0);
+	}
+	ut_a(block);
+
 	buf_block_dbg_add_level(block, SYNC_FSP_PAGE);
 
 	sp_header = FSP_HEADER_OFFSET + buf_block_get_frame(block);
@@ -1867,6 +1879,11 @@
 {
 	fseg_inode_t*	inode;
 
+	if (srv_pass_corrupt_table && !page) {
+		return(ULINT_UNDEFINED);
+	}
+	ut_a(page);
+
 	for (; i < FSP_SEG_INODES_PER_PAGE(zip_size); i++) {
 
 		inode = fsp_seg_inode_page_get_nth_inode(
@@ -1980,6 +1997,11 @@
 
 	page = buf_block_get_frame(block);
 
+	if (srv_pass_corrupt_table && !page) {
+		return(0);
+	}
+	ut_a(page);
+
 	n = fsp_seg_inode_page_find_free(page, 0, zip_size, mtr);
 
 	ut_a(n != ULINT_UNDEFINED);
@@ -2073,6 +2095,11 @@
 
 	inode = fut_get_ptr(space, zip_size, inode_addr, RW_X_LATCH, mtr);
 
+	if (srv_pass_corrupt_table && !inode) {
+		return(0);
+	}
+	ut_a(inode);
+
 	if (UNIV_UNLIKELY
 	    (ut_dulint_is_zero(mach_read_from_8(inode + FSEG_ID)))) {
 
@@ -2100,7 +2127,7 @@
 {
 	fseg_inode_t*	inode
 		= fseg_inode_try_get(header, space, zip_size, mtr);
-	ut_a(inode);
+	ut_a(srv_pass_corrupt_table || inode);
 	return(inode);
 }
 
@@ -3309,6 +3336,11 @@
 
 	descr = xdes_get_descriptor(space, zip_size, page, mtr);
 
+	if (srv_pass_corrupt_table && !descr) {
+		/* The page may be corrupt. pass it. */
+		return;
+	}
+
 	ut_a(descr);
 	if (xdes_get_bit(descr, XDES_FREE_BIT, page % FSP_EXTENT_SIZE, mtr)) {
 		fputs("InnoDB: Dump of the tablespace extent descriptor: ",
@@ -3561,6 +3593,11 @@
 
 	descr = xdes_get_descriptor(space, zip_size, header_page, mtr);
 
+	if (srv_pass_corrupt_table && !descr) {
+		/* The page may be corrupt. pass it. */
+		return(TRUE);
+	}
+
 	/* Check that the header resides on a page which has not been
 	freed yet */
 
@@ -3645,6 +3682,12 @@
 
 	inode = fseg_inode_get(header, space, zip_size, mtr);
 
+	if (srv_pass_corrupt_table && !inode) {
+		/* ignore the corruption */
+		return(TRUE);
+	}
+	ut_a(inode);
+
 	descr = fseg_get_first_extent(inode, space, zip_size, mtr);
 
 	if (descr != NULL) {
diff -ruN a/storage/innodb_plugin/handler/ha_innodb.cc b/storage/innodb_plugin/handler/ha_innodb.cc
--- a/storage/innodb_plugin/handler/ha_innodb.cc	2010-08-27 16:38:38.249059616 +0900
+++ b/storage/innodb_plugin/handler/ha_innodb.cc	2010-08-27 16:39:02.960021471 +0900
@@ -3716,6 +3716,12 @@
 		DBUG_RETURN(1);
 	}
 
+	if (share->ib_table && share->ib_table->is_corrupt) {
+		free_share(share);
+
+		DBUG_RETURN(HA_ERR_CRASHED_ON_USAGE);
+	}
+
 	/* Create buffers for packing the fields of a record. Why
 	table->reclength did not work here? Obviously, because char
 	fields when packed actually became 1 byte longer, when we also
@@ -3743,6 +3749,19 @@
 	/* Get pointer to a table object in InnoDB dictionary cache */
 	ib_table = dict_table_get(norm_name, TRUE);
 	
+	if (ib_table && ib_table->is_corrupt) {
+		free_share(share);
+		my_free(upd_buff, MYF(0));
+
+		DBUG_RETURN(HA_ERR_CRASHED_ON_USAGE);
+	}
+
+	if (share->ib_table) {
+		ut_a(share->ib_table == ib_table);
+	} else {
+		share->ib_table = ib_table;
+	}
+
 	if (NULL == ib_table) {
 		if (is_part && retries < 10) {
 			++retries;
@@ -4909,6 +4928,10 @@
 
 	ha_statistic_increment(&SSV::ha_write_count);
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	if (table->timestamp_field_type & TIMESTAMP_AUTO_SET_ON_INSERT)
 		table->timestamp_field->set_time();
 
@@ -5126,6 +5149,10 @@
 func_exit:
 	innobase_active_small();
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	DBUG_RETURN(error_result);
 }
 
@@ -5302,6 +5329,10 @@
 
 	ha_statistic_increment(&SSV::ha_update_count);
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	if (table->timestamp_field_type & TIMESTAMP_AUTO_SET_ON_UPDATE)
 		table->timestamp_field->set_time();
 
@@ -5391,6 +5422,10 @@
 
 	innobase_active_small();
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	DBUG_RETURN(error);
 }
 
@@ -5412,6 +5447,10 @@
 
 	ha_statistic_increment(&SSV::ha_delete_count);
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	if (!prebuilt->upd_node) {
 		row_get_prebuilt_update_vector(prebuilt);
 	}
@@ -5438,6 +5477,10 @@
 
 	innobase_active_small();
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	DBUG_RETURN(error);
 }
 
@@ -5677,6 +5720,10 @@
 
 	ha_statistic_increment(&SSV::ha_read_key_count);
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	index = prebuilt->index;
 
 	if (UNIV_UNLIKELY(index == NULL)) {
@@ -5742,6 +5789,10 @@
 		ret = DB_UNSUPPORTED;
 	}
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	switch (ret) {
 	case DB_SUCCESS:
 		error = 0;
@@ -5857,6 +5908,10 @@
 {
 	DBUG_ENTER("change_active_index");
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	ut_ad(user_thd == ha_thd());
 	ut_a(prebuilt->trx == thd_to_trx(user_thd));
 
@@ -5947,6 +6002,10 @@
 
 	DBUG_ENTER("general_fetch");
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	ut_a(prebuilt->trx == thd_to_trx(user_thd));
 
 	innodb_srv_conc_enter_innodb(prebuilt->trx);
@@ -5956,6 +6015,10 @@
 
 	innodb_srv_conc_exit_innodb(prebuilt->trx);
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	switch (ret) {
 	case DB_SUCCESS:
 		error = 0;
@@ -7214,6 +7277,10 @@
 		DBUG_RETURN(my_errno=HA_ERR_WRONG_COMMAND);
 	}
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	/* Truncate the table in InnoDB */
 
 	error = row_truncate_table_for_mysql(prebuilt->table, prebuilt->trx);
@@ -7222,6 +7289,10 @@
 		goto fallback;
 	}
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	error = convert_error_code_to_mysql(error, prebuilt->table->flags,
 					    NULL);
 
@@ -7734,6 +7805,16 @@
 	return(ranges + (double) rows / (double) total_rows * time_for_scan);
 }
 
+UNIV_INTERN
+bool
+ha_innobase::is_corrupt() const
+{
+	if (share->ib_table)
+		return ((bool)share->ib_table->is_corrupt);
+	else
+		return (FALSE);
+}
+
 /*********************************************************************//**
 Calculates the key number used inside MySQL for an Innobase index. We will
 first check the "index translation table" for a match of the index to get
@@ -7855,7 +7936,7 @@
 	ib_table = prebuilt->table;
 
 	if (flag & HA_STATUS_TIME) {
-		if (called_from_analyze || innobase_stats_on_metadata) {
+		if ((called_from_analyze || innobase_stats_on_metadata) && !share->ib_table->is_corrupt) {
 			/* In sql_show we call with this flag: update
 			then statistics so that they are up-to-date */
 
@@ -8146,10 +8227,18 @@
 	THD*		thd,		/*!< in: connection thread handle */
 	HA_CHECK_OPT*	check_opt)	/*!< in: currently ignored */
 {
+	if (share->ib_table->is_corrupt) {
+		return(HA_ADMIN_CORRUPT);
+	}
+
 	/* Simply call ::info() with all the flags */
 	info_low(HA_STATUS_TIME | HA_STATUS_CONST | HA_STATUS_VARIABLE,
 		 true /* called from analyze */);
 
+	if (share->ib_table->is_corrupt) {
+		return(HA_ADMIN_CORRUPT);
+	}
+
 	return(0);
 }
 
@@ -8331,6 +8420,10 @@
 		my_error(ER_QUERY_INTERRUPTED, MYF(0));
 	}
 
+	if (share->ib_table->is_corrupt) {
+		return(HA_ADMIN_CORRUPT);
+	}
+
 	DBUG_RETURN(is_ok ? HA_ADMIN_OK : HA_ADMIN_CORRUPT);
 }
 
@@ -9056,6 +9149,10 @@
 
 	update_thd(thd);
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	if (prebuilt->table->ibd_file_missing && !thd_tablespace_op(thd)) {
 		ut_print_timestamp(stderr);
 		fprintf(stderr,
@@ -11500,6 +11597,14 @@
   "0 (the default) disables automatic dumps.",
   NULL, NULL, 0, 0, UINT_MAX32, 0);
 
+static	MYSQL_SYSVAR_ULONG(pass_corrupt_table, srv_pass_corrupt_table,
+  PLUGIN_VAR_RQCMDARG,
+  "Pass corruptions of user tables as 'corrupt table' instead of not crashing itself, "
+  "when used with file_per_table. "
+  "All file io for the datafile after detected as corrupt are disabled, "
+  "except for the deletion.",
+  NULL, NULL, 0, 0, 1, 0);
+
 static struct st_mysql_sys_var* innobase_system_variables[]= {
   MYSQL_SYSVAR(additional_mem_pool_size),
   MYSQL_SYSVAR(autoextend_increment),
@@ -11585,6 +11690,7 @@
   MYSQL_SYSVAR(io_capacity),
   MYSQL_SYSVAR(auto_lru_dump),
   MYSQL_SYSVAR(use_purge_thread),
+  MYSQL_SYSVAR(pass_corrupt_table),
   NULL
 };
 
diff -ruN a/storage/innodb_plugin/handler/ha_innodb.h b/storage/innodb_plugin/handler/ha_innodb.h
--- a/storage/innodb_plugin/handler/ha_innodb.h	2010-08-04 02:24:19.000000000 +0900
+++ b/storage/innodb_plugin/handler/ha_innodb.h	2010-08-27 16:39:03.003058548 +0900
@@ -52,6 +52,7 @@
 	innodb_idx_translate_t	idx_trans_tbl;	/*!< index translation
 						table between MySQL and
 						Innodb */
+	dict_table_t*		ib_table;
 } INNOBASE_SHARE;
 
 
@@ -135,6 +136,7 @@
 	int close(void);
 	double scan_time();
 	double read_time(uint index, uint ranges, ha_rows rows);
+	bool is_corrupt() const;
 
 	int write_row(uchar * buf);
 	int update_row(const uchar * old_data, uchar * new_data);
diff -ruN a/storage/innodb_plugin/handler/innodb_patch_info.h b/storage/innodb_plugin/handler/innodb_patch_info.h
--- a/storage/innodb_plugin/handler/innodb_patch_info.h	2010-08-27 16:38:38.272105535 +0900
+++ b/storage/innodb_plugin/handler/innodb_patch_info.h	2010-08-27 16:39:03.003990202 +0900
@@ -43,5 +43,6 @@
 {"innodb_extend_slow","Extended statistics in slow.log","It is InnoDB-part only. It needs to patch also to mysqld.","http://www.percona.com/docs/wiki/percona-xtradb"},
 {"innodb_lru_dump_restore","Dump and restore command for content of buffer pool","","http://www.percona.com/docs/wiki/percona-xtradb"},
 {"innodb_separate_doublewrite","Add option 'innodb_doublewrite_file' to separate doublewrite dedicated tablespace","","http://www.percona.com/docs/wiki/percona-xtradb"},
+{"innodb_pass_corrupt_table","Treat tables as corrupt instead of crash, when meet corrupt blocks","","http://www.percona.com/docs/wiki/percona-xtradb"},
 {NULL, NULL, NULL, NULL}
 };
diff -ruN a/storage/innodb_plugin/include/btr0btr.ic b/storage/innodb_plugin/include/btr0btr.ic
--- a/storage/innodb_plugin/include/btr0btr.ic	2010-08-04 02:24:19.000000000 +0900
+++ b/storage/innodb_plugin/include/btr0btr.ic	2010-08-27 16:39:03.004990818 +0900
@@ -28,7 +28,7 @@
 #include "mtr0mtr.h"
 #include "mtr0log.h"
 #include "page0zip.h"
-
+#include "srv0srv.h"
 #define BTR_MAX_NODE_LEVEL	50	/*!< Maximum B-tree page level
 					(not really a hard limit).
 					Used in debug assertions
@@ -55,7 +55,9 @@
 	block = buf_page_get_gen(space, zip_size, page_no, mode,
 				 NULL, BUF_GET, file, line, mtr);
 
-	if (mode != RW_NO_LATCH) {
+	ut_a(srv_pass_corrupt_table || block);
+
+	if (block && mode != RW_NO_LATCH) {
 
 		buf_block_dbg_add_level(block, SYNC_TREE_NODE);
 	}
diff -ruN a/storage/innodb_plugin/include/buf0buf.h b/storage/innodb_plugin/include/buf0buf.h
--- a/storage/innodb_plugin/include/buf0buf.h	2010-08-27 16:13:11.081058676 +0900
+++ b/storage/innodb_plugin/include/buf0buf.h	2010-08-27 16:39:03.007006842 +0900
@@ -850,7 +850,7 @@
 	const buf_block_t*	block)	/*!< in: pointer to the control block */
 	__attribute__((pure));
 #else /* UNIV_DEBUG */
-# define buf_block_get_frame(block) (block)->frame
+# define buf_block_get_frame(block) (block ? (block)->frame : 0)
 #endif /* UNIV_DEBUG */
 /*********************************************************************//**
 Gets the space id of a block.
@@ -982,7 +982,8 @@
 void
 buf_page_io_complete(
 /*=================*/
-	buf_page_t*	bpage);	/*!< in: pointer to the block in question */
+	buf_page_t*	bpage,	/*!< in: pointer to the block in question */
+	trx_t*		trx);
 /********************************************************************//**
 Calculates a folded value of a file page address to use in the page hash
 table.
@@ -1150,6 +1151,7 @@
 					0 if the block was never accessed
 					in the buffer pool */
 	/* @} */
+	ibool		is_corrupt;
 # ifdef UNIV_DEBUG_FILE_ACCESSES
 	ibool		file_page_was_freed;
 					/*!< this is set to TRUE when fsp
diff -ruN a/storage/innodb_plugin/include/buf0buf.ic b/storage/innodb_plugin/include/buf0buf.ic
--- a/storage/innodb_plugin/include/buf0buf.ic	2010-08-27 16:13:11.082973631 +0900
+++ b/storage/innodb_plugin/include/buf0buf.ic	2010-08-27 16:39:03.009020919 +0900
@@ -35,7 +35,7 @@
 #include "buf0flu.h"
 #include "buf0lru.h"
 #include "buf0rea.h"
-
+#include "srv0srv.h"
 /********************************************************************//**
 Reads the freed_page_clock of a buffer block.
 @return	freed_page_clock */
@@ -581,6 +581,12 @@
 /*================*/
 	const buf_block_t*	block)	/*!< in: pointer to the control block */
 {
+	ut_a(srv_pass_corrupt_table || block);
+
+	if (srv_pass_corrupt_table && !block) {
+		return(0);
+	}
+
 	ut_ad(block);
 
 	switch (buf_block_get_state(block)) {
diff -ruN a/storage/innodb_plugin/include/dict0dict.h b/storage/innodb_plugin/include/dict0dict.h
--- a/storage/innodb_plugin/include/dict0dict.h	2010-08-27 16:22:04.264988090 +0900
+++ b/storage/innodb_plugin/include/dict0dict.h	2010-08-27 16:39:03.011025333 +0900
@@ -1199,6 +1199,15 @@
 dict_close(void);
 /*============*/
 
+/*************************************************************************
+set is_corrupt flag by space_id*/
+
+void
+dict_table_set_corrupt_by_space(
+/*============================*/
+	ulint	space_id,
+	ibool	need_mutex);
+
 #ifndef UNIV_NONINL
 #include "dict0dict.ic"
 #endif
diff -ruN a/storage/innodb_plugin/include/dict0mem.h b/storage/innodb_plugin/include/dict0mem.h
--- a/storage/innodb_plugin/include/dict0mem.h	2010-08-04 02:24:19.000000000 +0900
+++ b/storage/innodb_plugin/include/dict0mem.h	2010-08-27 16:39:03.013021149 +0900
@@ -560,6 +560,7 @@
 				the AUTOINC lock on this table. */
 				/* @} */
 	/*----------------------*/
+	ibool		is_corrupt;
 #endif /* !UNIV_HOTBACKUP */
 
 #ifdef UNIV_DEBUG
diff -ruN a/storage/innodb_plugin/include/fil0fil.h b/storage/innodb_plugin/include/fil0fil.h
--- a/storage/innodb_plugin/include/fil0fil.h	2010-08-27 16:36:03.499987483 +0900
+++ b/storage/innodb_plugin/include/fil0fil.h	2010-08-27 16:39:03.015021314 +0900
@@ -748,6 +748,19 @@
 fil_system_hash_nodes(void);
 /*========================*/
 
+/*************************************************************************
+functions to access is_corrupt flag of fil_space_t*/
+
+ibool
+fil_space_is_corrupt(
+/*=================*/
+	ulint	space_id);
+
+void
+fil_space_set_corrupt(
+/*==================*/
+	ulint	space_id);
+
 typedef	struct fil_space_struct	fil_space_t;
 
 #endif
diff -ruN a/storage/innodb_plugin/include/fut0fut.ic b/storage/innodb_plugin/include/fut0fut.ic
--- a/storage/innodb_plugin/include/fut0fut.ic	2010-08-04 02:24:19.000000000 +0900
+++ b/storage/innodb_plugin/include/fut0fut.ic	2010-08-27 16:39:03.015990218 +0900
@@ -23,6 +23,7 @@
 Created 12/13/1995 Heikki Tuuri
 ***********************************************************************/
 
+#include "srv0srv.h"
 #include "sync0rw.h"
 #include "buf0buf.h"
 
@@ -48,6 +49,12 @@
 	ut_ad((rw_latch == RW_S_LATCH) || (rw_latch == RW_X_LATCH));
 
 	block = buf_page_get(space, zip_size, addr.page, rw_latch, mtr);
+
+	if (srv_pass_corrupt_table && !block) {
+		return(0);
+	}
+	ut_a(block);
+
 	ptr = buf_block_get_frame(block) + addr.boffset;
 
 	buf_block_dbg_add_level(block, SYNC_NO_ORDER_CHECK);
diff -ruN a/storage/innodb_plugin/include/page0page.h b/storage/innodb_plugin/include/page0page.h
--- a/storage/innodb_plugin/include/page0page.h	2010-08-04 02:24:19.000000000 +0900
+++ b/storage/innodb_plugin/include/page0page.h	2010-08-27 16:39:03.025058694 +0900
@@ -500,7 +500,7 @@
 page_is_leaf(
 /*=========*/
 	const page_t*	page)	/*!< in: page */
-	__attribute__((nonnull, pure));
+	__attribute__((pure));
 /************************************************************//**
 Gets the pointer to the next record on the page.
 @return	pointer to next record */
diff -ruN a/storage/innodb_plugin/include/page0page.ic b/storage/innodb_plugin/include/page0page.ic
--- a/storage/innodb_plugin/include/page0page.ic	2010-08-04 02:24:19.000000000 +0900
+++ b/storage/innodb_plugin/include/page0page.ic	2010-08-27 16:39:03.027021276 +0900
@@ -275,6 +275,9 @@
 /*=========*/
 	const page_t*	page)	/*!< in: page */
 {
+	if (!page) {
+		return(FALSE);
+	}
 	return(!*(const uint16*) (page + (PAGE_HEADER + PAGE_LEVEL)));
 }
 
diff -ruN a/storage/innodb_plugin/include/page0zip.h b/storage/innodb_plugin/include/page0zip.h
--- a/storage/innodb_plugin/include/page0zip.h	2010-08-04 02:24:19.000000000 +0900
+++ b/storage/innodb_plugin/include/page0zip.h	2010-08-27 16:39:03.027992946 +0900
@@ -114,7 +114,7 @@
 	const page_t*	page,	/*!< in: uncompressed page */
 	dict_index_t*	index,	/*!< in: index of the B-tree node */
 	mtr_t*		mtr)	/*!< in: mini-transaction, or NULL */
-	__attribute__((nonnull(1,2,3)));
+	__attribute__((nonnull(1,3)));
 
 /**********************************************************************//**
 Decompress a page.  This function should tolerate errors on the compressed
diff -ruN a/storage/innodb_plugin/include/srv0srv.h b/storage/innodb_plugin/include/srv0srv.h
--- a/storage/innodb_plugin/include/srv0srv.h	2010-08-27 16:38:38.275010935 +0900
+++ b/storage/innodb_plugin/include/srv0srv.h	2010-08-27 16:39:03.030004790 +0900
@@ -230,6 +230,7 @@
 extern ulint	srv_adaptive_checkpoint;
 
 extern ulint	srv_expand_import;
+extern ulint	srv_pass_corrupt_table;
 
 extern ulint	srv_extra_rsegments;
 extern ulint	srv_dict_size_limit;
diff -ruN a/storage/innodb_plugin/page/page0zip.c b/storage/innodb_plugin/page/page0zip.c
--- a/storage/innodb_plugin/page/page0zip.c	2010-08-04 02:24:19.000000000 +0900
+++ b/storage/innodb_plugin/page/page0zip.c	2010-08-27 16:39:03.033021517 +0900
@@ -1153,6 +1153,10 @@
 	FILE*		logfile = NULL;
 #endif
 
+	if (!page) {
+		return(FALSE);
+	}
+
 	ut_a(page_is_comp(page));
 	ut_a(fil_page_get_type(page) == FIL_PAGE_INDEX);
 	ut_ad(page_simple_validate_new((page_t*) page));
diff -ruN a/storage/innodb_plugin/row/row0ins.c b/storage/innodb_plugin/row/row0ins.c
--- a/storage/innodb_plugin/row/row0ins.c	2010-08-04 02:24:20.000000000 +0900
+++ b/storage/innodb_plugin/row/row0ins.c	2010-08-27 16:39:03.037022066 +0900
@@ -1348,6 +1348,12 @@
 		const rec_t*		rec = btr_pcur_get_rec(&pcur);
 		const buf_block_t*	block = btr_pcur_get_block(&pcur);
 
+		if (srv_pass_corrupt_table && !block) {
+			err = DB_CORRUPTION;
+			break;
+		}
+		ut_a(block);
+
 		if (page_rec_is_infimum(rec)) {
 
 			continue;
diff -ruN a/storage/innodb_plugin/row/row0merge.c b/storage/innodb_plugin/row/row0merge.c
--- a/storage/innodb_plugin/row/row0merge.c	2010-08-27 16:22:04.282058645 +0900
+++ b/storage/innodb_plugin/row/row0merge.c	2010-08-27 16:39:03.040985277 +0900
@@ -1224,6 +1224,13 @@
 
 		if (UNIV_LIKELY(has_next)) {
 			rec = btr_pcur_get_rec(&pcur);
+
+			if (srv_pass_corrupt_table && !rec) {
+				err = DB_CORRUPTION;
+				goto err_exit;
+			}
+			ut_a(rec);
+
 			offsets = rec_get_offsets(rec, clust_index, NULL,
 						  ULINT_UNDEFINED, &row_heap);
 
diff -ruN a/storage/innodb_plugin/row/row0sel.c b/storage/innodb_plugin/row/row0sel.c
--- a/storage/innodb_plugin/row/row0sel.c	2010-08-04 02:24:20.000000000 +0900
+++ b/storage/innodb_plugin/row/row0sel.c	2010-08-27 16:39:03.045021567 +0900
@@ -3856,6 +3856,13 @@
 	/* PHASE 4: Look for matching records in a loop */
 
 	rec = btr_pcur_get_rec(pcur);
+
+	if (srv_pass_corrupt_table && !rec) {
+		err = DB_CORRUPTION;
+		goto lock_wait_or_error;
+	}
+	ut_a(rec);
+
 	ut_ad(!!page_rec_is_comp(rec) == comp);
 #ifdef UNIV_SEARCH_DEBUG
 	/*
diff -ruN a/storage/innodb_plugin/srv/srv0srv.c b/storage/innodb_plugin/srv/srv0srv.c
--- a/storage/innodb_plugin/srv/srv0srv.c	2010-08-27 16:38:38.286989546 +0900
+++ b/storage/innodb_plugin/srv/srv0srv.c	2010-08-27 16:39:03.048990992 +0900
@@ -402,6 +402,7 @@
 UNIV_INTERN ulint	srv_adaptive_checkpoint = 0; /* 0: none  1: reflex  2: estimate */
 
 UNIV_INTERN ulint	srv_expand_import = 0; /* 0:disable 1:enable */
+UNIV_INTERN ulint	srv_pass_corrupt_table = 0; /* 0:disable 1:enable */
 
 UNIV_INTERN ulint	srv_extra_rsegments = 0; /* extra rseg for users */
 UNIV_INTERN ulint	srv_dict_size_limit = 0;
diff -ruN a/storage/innodb_plugin/srv/srv0start.c b/storage/innodb_plugin/srv/srv0start.c
--- a/storage/innodb_plugin/srv/srv0start.c	2010-08-27 16:38:38.290021700 +0900
+++ b/storage/innodb_plugin/srv/srv0start.c	2010-08-27 16:39:03.052021423 +0900
@@ -1994,6 +1994,13 @@
 
 	os_fast_mutex_free(&srv_os_test_mutex);
 
+	if (!srv_file_per_table_original_value
+	    && srv_pass_corrupt_table) {
+		fprintf(stderr, "InnoDB: Warning:"
+			" innodb_file_per_table is diabled."
+			" So innodb_pass_corrupt_table doesn't make sence\n");
+	}
+
 	if (srv_print_verbose_log) {
 		ut_print_timestamp(stderr);
 		fprintf(stderr,
