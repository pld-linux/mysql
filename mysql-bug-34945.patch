From: Sergey&nbsp;PetruniaDate: March 3 2008 6:35pm
Subject: bk commit into 5.0 tree (sergefp:1.2598) BUG#34945

Below is the list of changes that have just been committed into a local
5.0 repository of sergefp.  When sergefp does a push these changes
will be propagated to the main repository and, within 24 hours after the
push, to the public repository.
For information on how to access the public repository
see http://dev.mysql.com/doc/mysql/en/installing-source-tree.html

ChangeSet@stripped, 2008-03-03 20:35:44+03:00, sergefp@stripped +3 -0
  BUG#34945: "ref_or_null queries that are null_rejecting and have a null value crash mysql"
  - Apply Eric Bergen's patch: in join_read_always_key(), move ha_index_init() call
    to before the late NULLs filtering code.
  - Backport function comments from 6.0.

  mysql-test/r/null_key.result@stripped, 2008-03-03 20:35:38+03:00, sergefp@stripped +18 -0
    BUG#34945: "ref_or_null queries that are null_rejecting and have a null value crash mysql"
    - Testcase

  mysql-test/t/null_key.test@stripped, 2008-03-03 20:35:38+03:00, sergefp@stripped +23 -0
    BUG#34945: "ref_or_null queries that are null_rejecting and have a null value crash mysql"
    - Testcase

  sql/sql_select.cc@stripped, 2008-03-03 20:35:38+03:00, sergefp@stripped +26 -3
    BUG#34945: "ref_or_null queries that are null_rejecting and have a null value crash mysql"
    - Apply Eric Bergen's patch: in join_read_always_key(), move ha_index_init() call
      to before the late NULLs filtering code.
    - Backport function comments from 6.0

diff -Nrup a/mysql-test/r/null_key.result b/mysql-test/r/null_key.result
--- a/mysql-test/r/null_key.result	2007-05-30 16:04:02 +04:00
+++ b/mysql-test/r/null_key.result	2008-03-03 20:35:38 +03:00
@@ -429,3 +429,21 @@ Handler_read_prev	0
 Handler_read_rnd	0
 Handler_read_rnd_next	5
 DROP TABLE t1,t2,t3,t4;
+CREATE TABLE t1 (
+a int(11) default NULL,
+b int(11) default NULL,
+KEY a (a,b)
+);
+INSERT INTO t1 VALUES (0,10),(0,11),(0,12);
+CREATE TABLE t2 (
+a int(11) default NULL,
+b int(11) default NULL,
+KEY a (a)
+);
+INSERT INTO t2 VALUES (3,NULL),(3,11),(3,12);
+SELECT * FROM t2 inner join t1 WHERE ( t1.a = 0 OR t1.a IS NULL) AND t2.a = 3 AND t2.b = t1.b;
+a	b	a	b
+3	11	0	11
+3	12	0	12
+drop table t1, t2;
+End of 5.0 tests
diff -Nrup a/mysql-test/t/null_key.test b/mysql-test/t/null_key.test
--- a/mysql-test/t/null_key.test	2005-08-23 19:08:01 +04:00
+++ b/mysql-test/t/null_key.test	2008-03-03 20:35:38 +03:00
@@ -240,3 +240,26 @@ SHOW STATUS LIKE "handler_read%";
 
 DROP TABLE t1,t2,t3,t4;
 # End of 4.1 tests
+
+#
+# BUG#34945 "ref_or_null queries that are null_rejecting and have a null value crash mysql"
+# 
+CREATE TABLE t1 (
+  a int(11) default NULL,
+  b int(11) default NULL,
+  KEY a (a,b)
+);
+INSERT INTO t1 VALUES (0,10),(0,11),(0,12);
+
+CREATE TABLE t2 (
+  a int(11) default NULL,
+  b int(11) default NULL,
+  KEY a (a)
+);
+INSERT INTO t2 VALUES (3,NULL),(3,11),(3,12);
+
+SELECT * FROM t2 inner join t1 WHERE ( t1.a = 0 OR t1.a IS NULL) AND t2.a = 3 AND t2.b = t1.b;
+
+drop table t1, t2;
+-- echo End of 5.0 tests
+
diff -Nrup a/sql/sql_select.cc b/sql/sql_select.cc
--- a/sql/sql_select.cc	2008-02-29 14:02:47 +03:00
+++ b/sql/sql_select.cc	2008-03-03 20:35:38 +03:00
@@ -11173,19 +11173,42 @@ join_read_key(JOIN_TAB *tab)
 }
 
 
+/*
+  ref access method implementation: "read_first" function
+
+  SYNOPSIS
+    join_read_always_key()
+      tab  JOIN_TAB of the accessed table
+
+  DESCRIPTION
+    This is "read_fist" function for the "ref" access method.
+   
+    The functon must leave the index initialized when it returns.
+    ref_or_null access implementation depends on that.
+
+  RETURN
+    0  - Ok
+   -1  - Row not found 
+    1  - Error
+*/
+
 static int
 join_read_always_key(JOIN_TAB *tab)
 {
   int error;
   TABLE *table= tab->table;
 
+  /* Initialize the index first */
+  if (!table->file->inited)
+    table->file->ha_index_init(tab->ref.key);
+
+  /* Perform "Late NULLs Filtering" (see internals manual for explanations) */
   for (uint i= 0 ; i < tab->ref.key_parts ; i++)
   {
     if ((tab->ref.null_rejecting & 1 << i) && tab->ref.items[i]->is_null())
         return -1;
-  } 
-  if (!table->file->inited)
-    table->file->ha_index_init(tab->ref.key);
+  }
+
   if (cp_buffer_from_ref(tab->join->thd, &tab->ref))
     return -1;
   if ((error=table->file->index_read(table->record[0],
