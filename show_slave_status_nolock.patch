# name       : show_slave_status_nolock.patch
# introduced : 12
# maintainer : Oleg
#
#!!! notice !!!
# Any small change to this file in the main branch
# should be done or reviewed by the maintainer!
--- /dev/null
+++ b/patch_info/show_slave_status_nolock.patch
@@ -0,0 +1,6 @@
+File=show_slave_status_nolock.patch
+Name= SHOW SLAVE STATUS NOLOCK
+Version=1.0
+Author=Percona <info@percona.com>
+License=GPL
+Comment= Implement SHOW SLAVE STATUS without lock (STOP SLAVE lock the same mutex what lock SHOW SLAVE STATUS)
--- a/sql/lex.h
+++ b/sql/lex.h
@@ -378,6 +378,7 @@
   { "NONE",		SYM(NONE_SYM)},
   { "NOT",		SYM(NOT_SYM)},
   { "NO_WRITE_TO_BINLOG",  SYM(NO_WRITE_TO_BINLOG)},
+  { "NOLOCK",           SYM(NOLOCK_SYM)},
   { "NULL",		SYM(NULL_SYM)},
   { "NUMERIC",		SYM(NUMERIC_SYM)},
   { "NVARCHAR",		SYM(NVARCHAR_SYM)},
--- a/sql/mysqld.cc
+++ b/sql/mysqld.cc
@@ -3121,6 +3121,7 @@
   {"show_relaylog_events", (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_RELAYLOG_EVENTS]), SHOW_LONG_STATUS},
   {"show_slave_hosts",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_SLAVE_HOSTS]), SHOW_LONG_STATUS},
   {"show_slave_status",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_SLAVE_STAT]), SHOW_LONG_STATUS},
+  {"show_slave_status_nolock", (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_SLAVE_NOLOCK_STAT]), SHOW_LONG_STATUS},
   {"show_status",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_STATUS]), SHOW_LONG_STATUS},
   {"show_storage_engines", (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_STORAGE_ENGINES]), SHOW_LONG_STATUS},
   {"show_table_status",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_SHOW_TABLE_STATUS]), SHOW_LONG_STATUS},
--- a/sql/sql_lex.h
+++ b/sql/sql_lex.h
@@ -190,6 +190,8 @@
   SQLCOM_SHOW_PROFILE, SQLCOM_SHOW_PROFILES,
   SQLCOM_SIGNAL, SQLCOM_RESIGNAL,
   SQLCOM_SHOW_RELAYLOG_EVENTS, 
+  /* SHOW SLAVE STATUS NOLOCK */
+  SQLCOM_SHOW_SLAVE_NOLOCK_STAT,
   /*
     When a command is added here, be sure it's also added in mysqld.cc
     in "struct show_var_st status_vars[]= {" ...
--- a/sql/sql_parse.cc
+++ b/sql/sql_parse.cc
@@ -335,6 +335,7 @@
   sql_command_flags[SQLCOM_SHOW_CREATE]=  CF_STATUS_COMMAND;
   sql_command_flags[SQLCOM_SHOW_MASTER_STAT]= CF_STATUS_COMMAND;
   sql_command_flags[SQLCOM_SHOW_SLAVE_STAT]=  CF_STATUS_COMMAND;
+  sql_command_flags[SQLCOM_SHOW_SLAVE_NOLOCK_STAT]=  CF_STATUS_COMMAND;
   sql_command_flags[SQLCOM_SHOW_CREATE_PROC]= CF_STATUS_COMMAND;
   sql_command_flags[SQLCOM_SHOW_CREATE_FUNC]= CF_STATUS_COMMAND;
   sql_command_flags[SQLCOM_SHOW_CREATE_TRIGGER]=  CF_STATUS_COMMAND;
@@ -2359,12 +2360,16 @@
     mysql_mutex_unlock(&LOCK_active_mi);
     break;
   }
+  case SQLCOM_SHOW_SLAVE_NOLOCK_STAT:
   case SQLCOM_SHOW_SLAVE_STAT:
   {
     /* Accept one of two privileges */
     if (check_global_access(thd, SUPER_ACL | REPL_CLIENT_ACL))
       goto error;
-    mysql_mutex_lock(&LOCK_active_mi);
+    if(SQLCOM_SHOW_SLAVE_NOLOCK_STAT != lex->sql_command)
+    {
+      mysql_mutex_lock(&LOCK_active_mi);
+    }
     if (active_mi != NULL)
     {
       res = show_master_info(thd, active_mi);
@@ -2375,7 +2380,10 @@
                    WARN_NO_MASTER_INFO, ER(WARN_NO_MASTER_INFO));
       my_ok(thd);
     }
-    mysql_mutex_unlock(&LOCK_active_mi);
+    if(SQLCOM_SHOW_SLAVE_NOLOCK_STAT != lex->sql_command)
+    {
+      mysql_mutex_unlock(&LOCK_active_mi);
+    }
     break;
   }
   case SQLCOM_SHOW_MASTER_STAT:
--- a/sql/sql_yacc.yy
+++ b/sql/sql_yacc.yy
@@ -1293,6 +1293,7 @@
 %token  STARTS_SYM
 %token  START_SYM                     /* SQL-2003-R */
 %token  STATUS_SYM
+%token  NOLOCK_SYM                    /* SHOW SLAVE STATUS NOLOCK */
 %token  STDDEV_SAMP_SYM               /* SQL-2003-N */
 %token  STD_SYM
 %token  STOP_SYM
@@ -11086,6 +11087,10 @@
           {
             Lex->sql_command = SQLCOM_SHOW_SLAVE_STAT;
           }
+        | SLAVE STATUS_SYM NOLOCK_SYM
+          {
+	    Lex->sql_command = SQLCOM_SHOW_SLAVE_NOLOCK_STAT; //SQLCOM_SHOW_SLAVE_NOLOCK_STAT;
+          }
         | QUERY_RESPONSE_TIME_SYM wild_and_where
          {
 #ifdef HAVE_RESPONSE_TIME_DISTRIBUTION
--- /dev/null
+++ b/mysql-test/r/percona_show_slave_status_nolock.result
@@ -0,0 +1,21 @@
+include/master-slave.inc
+[connection master]
+DROP TABLE IF EXISTS t;
+CREATE TABLE t(id INT);
+INSERT INTO t SELECT SLEEP(10);
+STOP SLAVE;
+Warnings:
+Note	1592	Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT. Statement is unsafe because it uses a system function that may return a different value on the slave.
+master	count(*)
+master	1
+slave	count(*)
+slave	0
+SHOW SLAVE STATUS NOLOCK;
+include/wait_for_slave_to_stop.inc
+START SLAVE;
+include/wait_for_slave_to_start.inc
+slave	count(*)
+slave	1
+DROP TABLE t;
+STOP SLAVE;
+include/wait_for_slave_to_stop.inc
--- /dev/null
+++ b/mysql-test/t/percona_show_slave_status_nolock.test
@@ -0,0 +1,53 @@
+--source include/master-slave.inc
+--source include/have_binlog_format_statement.inc
+--disable_query_log
+call mtr.add_suppression("Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT. Statement is unsafe because it uses a system function that may return a different value on the slave. Statement:");
+call mtr.add_suppression("Slave SQL.*Request to stop slave SQL Thread received while applying a group that has non-transactional changes; waiting for completion of the group");
+--enable_query_log
+connection master;
+  --disable_warnings
+  DROP TABLE IF EXISTS t;
+  --enable_warnings
+  CREATE TABLE t(id INT);
+  sync_slave_with_master;
+
+connection master;
+  send INSERT INTO t SELECT SLEEP(10);
+
+connection slave;
+  sleep 15;
+  send STOP SLAVE;
+
+connection master;
+  reap;
+
+  --disable_query_log
+  select "master",count(*) from t;
+  --enable_query_log
+
+connection slave1;
+  --disable_query_log
+  select "slave",count(*) from t;
+  --enable_query_log
+
+  --disable_result_log
+  SHOW SLAVE STATUS NOLOCK;
+  --enable_result_log
+
+connection slave;
+  reap;
+
+  --source include/wait_for_slave_to_stop.inc
+  START SLAVE;
+  --source include/wait_for_slave_to_start.inc
+
+  --disable_query_log
+  select "slave",count(*) from t;
+  --enable_query_log
+
+connection master;
+  DROP TABLE t;
+sync_slave_with_master;
+STOP SLAVE;
+--source include/wait_for_slave_to_stop.inc
+ 
\ No newline at end of file
